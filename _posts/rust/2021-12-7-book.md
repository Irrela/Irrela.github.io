---
title: Rust Book
categories: Rust
tags:
- Rust
---

- [Warning and Error](#warning-and-error)
- [ShortCut](#shortcut)
- [1. Getting Started](#1-getting-started)
  - [1.1 First Program](#11-first-program)
  - [1.2 Cargo](#12-cargo)
    - [！！！Cargo 操作慢](#cargo-操作慢)
    - [使用 Cargo 创建项目](#使用-cargo-创建项目)
    - [Cargo.toml结构](#cargotoml结构)
    - [为没有使用Cargo的项目引入Cargo](#为没有使用cargo的项目引入cargo)
    - [Cargo构建与运行](#cargo构建与运行)
    - [发布（release）构建](#发布release构建)
  - [2. Guessing Game](#2-guessing-game)
    - [使用变量储存值](#使用变量储存值)
    - [静态方法](#静态方法)
    - [输入输出(std::io)](#输入输出stdio)
    - [使用 Result 类型来处理潜在的错误](#使用-result-类型来处理潜在的错误)
    - [使用 println! 占位符打印值](#使用-println-占位符打印值)
    - [使用crate](#使用crate)
    - [Cargo.lock 文件确保构建是可重现的](#cargolock-文件确保构建是可重现的)
    - [更新 crate 到一个新版本](#更新-crate-到一个新版本)
    - [使用rand生成一个随机数](#使用rand生成一个随机数)
    - [比较猜测的数字和秘密数字](#比较猜测的数字和秘密数字)
    - [静态强类型 \& 类型推断](#静态强类型--类型推断)
    - [使用循环来允许多次猜测](#使用循环来允许多次猜测)
    - [处理无效输入](#处理无效输入)
- [3. Common Programming Concepts](#3-common-programming-concepts)
  - [3.1 Variables and Mutability](#31-variables-and-mutability)
    - [可变性](#可变性)
    - [常量](#常量)
    - [隐藏](#隐藏)
  - [3.2 数据类型](#32-数据类型)
    - [标量类型](#标量类型)
      - [数值运算](#数值运算)
      - [字符类型](#字符类型)
    - [复合类型](#复合类型)
      - [元组类型](#元组类型)
      - [数组类型](#数组类型)
      - [访问数组元素](#访问数组元素)
  - [3.2 函数](#32-函数)
    - [](#)
    - [具有返回值的函数](#具有返回值的函数)
  - [3.4 注释](#34-注释)
  - [3.5 控制流](#35-控制流)
    - [if](#if)
    - [else if](#else-if)
    - [loop、while 和 for](#loopwhile-和-for)
      - [loop](#loop)
      - [循环标签：在多个循环之间消除歧义](#循环标签在多个循环之间消除歧义)
      - [while](#while)
      - [for](#for)
- [4. Understanding Ownership](#4-understanding-ownership)
  - [4.1 什么是所有权？](#41-什么是所有权)
    - [所有权规则](#所有权规则)
    - [变量作用域](#变量作用域)
    - [演示所有权的规则 - String 类型](#演示所有权的规则---string-类型)
    - [变量与数据交互的方式（一）：移动](#变量与数据交互的方式一移动)
    - [变量与数据交互的方式（二）：克隆](#变量与数据交互的方式二克隆)
      - [只在栈上的数据：拷贝](#只在栈上的数据拷贝)
      - [Trait: Copy](#trait-copy)
      - [所有权与函数](#所有权与函数)
      - [返回值与作用域](#返回值与作用域)
  - [4.2 引用与借用](#42-引用与借用)
      - [尝试修改借用的变量](#尝试修改借用的变量)
    - [可变引用](#可变引用)
    - [悬垂引用（Dangling References）](#悬垂引用dangling-references)
  - [4.3 Slice 类型](#43-slice-类型)
      - ['' 和 b''](#-和-b)
      - [\&str 和 String](#str-和-string)
    - [其他类型的 slice](#其他类型的-slice)
- [5. `Structs` to Structure Related Data](#5-structs-to-structure-related-data)
  - [5.1 结构体的定义和实例化](#51-结构体的定义和实例化)
      - [访问和修改属性](#访问和修改属性)
      - [Builder](#builder)
    - [使用`结构体更新`语法从其他实例创建实例](#使用结构体更新语法从其他实例创建实例)
    - [元组结构体（tuple structs）](#元组结构体tuple-structs)
    - [类单元结构体（unit-like structs）](#类单元结构体unit-like-structs)
  - [5.2 结构体示例程序](#52-结构体示例程序)
    - [通过派生 trait 增加实用功能](#通过派生-trait-增加实用功能)
    - [使用 dbg!](#使用-dbg)
  - [5.3 方法语法](#53-方法语法)
      - [getter](#getter)
      - [-\> 运算符到哪去了？](#--运算符到哪去了)
    - [带有更多参数的方法](#带有更多参数的方法)
    - [关联函数](#关联函数)
- [6. Enums and Pattern Matching](#6-enums-and-pattern-matching)
    - [Option 枚举和其相对于空值的优势](#option-枚举和其相对于空值的优势)
  - [6.2 match 控制流结构](#62-match-控制流结构)
    - [绑定值的模式](#绑定值的模式)
    - [匹配 Option](#匹配-option)
    - [匹配是穷尽的(exhaustive)](#匹配是穷尽的exhaustive)
    - [通配模式和 \_ 占位符](#通配模式和-_-占位符)
  - [6.3 if let 简洁控制流](#63-if-let-简洁控制流)
- [7. Packages, Crates, and Modules](#7-packages-crates-and-modules)
  - [7.1 Package 和 Crate](#71-package-和-crate)
    - [Crate](#crate)
    - [Package](#package)
  - [7.2 定义模块来控制作用域与私有性](#72-定义模块来控制作用域与私有性)
    - [Module](#module)
    - [对相关代码进行分组](#对相关代码进行分组)
  - [7.3 引用模块项目的路径](#73-引用模块项目的路径)
    - [使用 pub 关键字暴露路径](#使用-pub-关键字暴露路径)
      - [executable 和 library 的最佳实践](#executable-和-library-的最佳实践)
    - [super 开始的相对路径](#super-开始的相对路径)
    - [创建公有的结构体和枚举](#创建公有的结构体和枚举)
  - [7.4 使用 use 关键字将路径引入作用域](#74-使用-use-关键字将路径引入作用域)
    - [使用 as 关键字提供新的名称](#使用-as-关键字提供新的名称)
    - [使用 pub use 重导出名称](#使用-pub-use-重导出名称)
    - [使用外部包](#使用外部包)
    - [嵌套路径来消除大量的 use 行](#嵌套路径来消除大量的-use-行)
    - [通过 glob 运算符(\*)将所有的公有定义引入作用域](#通过-glob-运算符将所有的公有定义引入作用域)
  - [7.5 将模块拆分成多个文件](#75-将模块拆分成多个文件)
- [8. 常见集合](#8-常见集合)
  - [8.1 Vector](#81-vector)
    - [Create](#create)
    - [Update](#update)
    - [Access](#access)
      - [借用规则与读取vec元素](#借用规则与读取vec元素)
    - [遍历 vector 中的元素](#遍历-vector-中的元素)
    - [使用枚举来储存多种类型](#使用枚举来储存多种类型)
    - [丢弃 vector 时也会丢弃其所有元素](#丢弃-vector-时也会丢弃其所有元素)
  - [8.2 字符串(String) 和 UTF-8 encoded Text](#82-字符串string-和-utf-8-encoded-text)
    - [新建字符串](#新建字符串)
    - [更新字符串](#更新字符串)
      - [push\_str](#push_str)
      - [+](#-1)
      - [format!](#format)
    - [索引字符串](#索引字符串)
    - [遍历字符串的方法](#遍历字符串的方法)
  - [8.3 HashMap and Key-Value entry](#83-hashmap-and-key-value-entry)
    - [新建一个哈希 map](#新建一个哈希-map)
    - [访问哈希 map 中的值](#访问哈希-map-中的值)
    - [哈希 map 和所有权](#哈希-map-和所有权)
    - [更新哈希 map](#更新哈希-map)
    - [哈希函数](#哈希函数)
- [9.错误处理](#9错误处理)
  - [9.1 用 panic! 处理不可恢复的错误](#91-用-panic-处理不可恢复的错误)
      - [对应 panic 时的栈展开或终止](#对应-panic-时的栈展开或终止)
    - [使用 panic! 的 backtrace](#使用-panic-的-backtrace)
      - [设置 RUST\_BACKTRACE 环境变量](#设置-rust_backtrace-环境变量)
  - [9.2 用 Result 处理可恢复的错误](#92-用-result-处理可恢复的错误)
    - [匹配不同的错误](#匹配不同的错误)
      - [使用闭包代替match和Result\<T, E\>](#使用闭包代替match和resultt-e)
    - [失败时 panic 的简写：unwrap 和 expect](#失败时-panic-的简写unwrap-和-expect)
    - [传播错误](#传播错误)
    - [传播错误的简写：? 运算符](#传播错误的简写-运算符)
  - [9.3 要不要 panic!](#93-要不要-panic)
- [10. Generic Types, Traits, and Lifetimes](#10-generic-types-traits-and-lifetimes)
    - [没有泛型时的处理方式：提取函数](#没有泛型时的处理方式提取函数)
  - [9.2 泛型数据类型](#92-泛型数据类型)
    - [在函数定义中使用泛型](#在函数定义中使用泛型)
    - [结构体定义中的泛型](#结构体定义中的泛型)
    - [枚举定义中的泛型](#枚举定义中的泛型)
    - [方法定义中的泛型](#方法定义中的泛型)
      - [定义中的泛型类型 \& 方法签名中使用的泛型](#定义中的泛型类型--方法签名中使用的泛型)
    - [泛型代码的性能](#泛型代码的性能)
  - [10.2 Trait：定义共同行为](#102-trait定义共同行为)
    - [定义 trait](#定义-trait)
    - [为类型实现 trait](#为类型实现-trait)
    - [默认实现](#默认实现)
    - [trait 作为参数](#trait-作为参数)
    - [通过 `+` 指定多个 trait bound](#通过--指定多个-trait-bound)
    - [通过 where 简化 trait bound](#通过-where-简化-trait-bound)
    - [返回 实现了 trait 的类型](#返回-实现了-trait-的类型)
    - [使用 trait bound 有条件地实现方法](#使用-trait-bound-有条件地实现方法)
  - [10.2 使用生命周期来确保引用有效](#102-使用生命周期来确保引用有效)
    - [生命周期避免了悬垂引用](#生命周期避免了悬垂引用)
    - [借用检查器](#借用检查器)
    - [函数中的泛型生命周期](#函数中的泛型生命周期)
    - [生命周期注解语法](#生命周期注解语法)
    - [函数签名中的生命周期注解](#函数签名中的生命周期注解)
    - [深入理解生命周期](#深入理解生命周期)
    - [结构体定义中的生命周期注解](#结构体定义中的生命周期注解)
    - [生命周期省略（Lifetime Elision）](#生命周期省略lifetime-elision)
    - [方法定义中的生命周期注解](#方法定义中的生命周期注解)
    - [静态生命周期](#静态生命周期)
    - [结合泛型类型参数、trait bounds 和生命周期](#结合泛型类型参数trait-bounds-和生命周期)
- [11. 编写自动化测试](#11-编写自动化测试)
- [12. 一个 I/O 项目：构建一个命令行程序](#12-一个-io-项目构建一个命令行程序)
  - [11.2 读取文件](#112-读取文件)
  - [11.3 重构改进模块性和错误处理](#113-重构改进模块性和错误处理)
    - [二进制项目的关注分离](#二进制项目的关注分离)
      - [使用 clone 的权衡取舍](#使用-clone-的权衡取舍)
  - [12.4 采用测试驱动开发完善库的功能](#124-采用测试驱动开发完善库的功能)
  - [12.5 处理环境变量](#125-处理环境变量)
  - [12.6 将错误信息输出到标准错误而不是标准输出](#126-将错误信息输出到标准错误而不是标准输出)
    - [检查错误应该写入何处](#检查错误应该写入何处)
    - [将错误打印到标准错误](#将错误打印到标准错误)
- [13. Rust 中的函数式语言功能：迭代器与闭包](#13-rust-中的函数式语言功能迭代器与闭包)
  - [13.1 闭包：可以捕获环境的匿名函数](#131-闭包可以捕获环境的匿名函数)
    - [使用闭包创建行为的抽象](#使用闭包创建行为的抽象)
    - [闭包类型推断和标注](#闭包类型推断和标注)
    - [使用带有泛型和 Fn trait 的闭包](#使用带有泛型和-fn-trait-的闭包)
    - [Cacher 实现的限制](#cacher-实现的限制)
    - [闭包会捕获其环境](#闭包会捕获其环境)
      - [move](#move)
  - [13.2 使用迭代器处理元素序列](#132-使用迭代器处理元素序列)
    - [创建](#创建)
    - [Iterator trait 和 next 方法](#iterator-trait-和-next-方法)
    - [消费迭代器的方法](#消费迭代器的方法)
    - [产生其他迭代器的方法](#产生其他迭代器的方法)
    - [使用闭包获取环境](#使用闭包获取环境)
    - [实现 Iterator trait 来创建自定义迭代器](#实现-iterator-trait-来创建自定义迭代器)
  - [13.3 改进 I/O 项目](#133-改进-io-项目)
    - [使用迭代器并去掉 new 中的 clone](#使用迭代器并去掉-new-中的-clone)
    - [使用迭代器适配器来使代码更简明](#使用迭代器适配器来使代码更简明)
    - [性能对比：循环 VS 迭代器](#性能对比循环-vs-迭代器)
- [14. 进一步认识 Cargo 和 Crates.io -todo](#14-进一步认识-cargo-和-cratesio--todo)
- [15. 智能指针](#15-智能指针)
  - [15.1 使用 Box 指向堆上的数据](#151-使用-box-指向堆上的数据)
    - [Box 允许创建递归类型](#box-允许创建递归类型)
  - [15.2 通过 Deref trait 将智能指针当作常规引用处理](#152-通过-deref-trait-将智能指针当作常规引用处理)
    - [通过解引用运算符追踪指针的值](#通过解引用运算符追踪指针的值)
    - [像引用一样使用 Box](#像引用一样使用-box)
    - [自定义智能指针](#自定义智能指针)
    - [通过实现 Deref trait 将某类型像引用一样处理](#通过实现-deref-trait-将某类型像引用一样处理)
      - [关联类型"（Associated Types）](#关联类型associated-types)
    - [函数和方法的隐式解引用强制转换](#函数和方法的隐式解引用强制转换)
    - [解引用强制转换如何与可变性交互](#解引用强制转换如何与可变性交互)
    - [15.3 使用 Drop Trait 运行清理代码](#153-使用-drop-trait-运行清理代码)
    - [通过 std::mem::drop 提早丢弃值](#通过-stdmemdrop-提早丢弃值)
  - [15.4 Rc 引用计数智能指针](#154-rc-引用计数智能指针)
    - [使用 Rc 共享数据](#使用-rc-共享数据)
    - [克隆 Rc 会增加引用计数](#克隆-rc-会增加引用计数)


# Warning and Error

- Cargo更新下载慢
    换源, `/Users/<your user name>/.cargo` 下新建config文件：
    ```xml
    [source.crates-io]
    registry = "https://github.com/rust-lang/crates.io-index"

    replace-with = 'ustc'

    [source.ustc]
    registry = "git://mirrors.ustc.edu.cn/crates.io-index"
    ```

- `No Cargo projects are found`
    
    这个错误通常意味着CLion无法找到任何Cargo项目，因此它无法在您的Rust代码上运行Cargo命令。
    
    检错：
    1. 确保您位于正确的目录中：导航到Rust项目的根目录。这是包含Cargo.toml文件的目录。您应该从此目录运行货物命令。
    2. 初始化Rust项目：如果您不在包含Cargo.toml文件的目录中，则可以通过运行以下命令来初始化新的Rust项目：
    > `cargo new your_project_name`

    extra:
    使用rust rover新建项目之后第一次cargo check完成以前会报这个错。等初始化完成就好了



- `module declaration missing`

- 检查模块声明(Check Module Declarations)：验证您已经在Rust代码中声明了模块。在Rust中，使用mod关键字声明模块。例如：
    ```rust
    // In your main.rs or lib.rs file
    mod my_module;
    ```


# ShortCut

- `cmd + option + t`: 包裹代码块

# 1. Getting Started
## 1.1 First Program

编译：`rustc main.rs`

编译完成会生成可执行文件`main.exe`, 包含调试信息文件`main.pdb`

## 1.2 Cargo
`cargo --version` 查看版本

### ！！！Cargo 操作慢


### 使用 Cargo 创建项目

`cargo new hello_cargo` 默认会在 hello_cargo 目录初始化一个 git 仓库, 以及一个.gitignore 文件

如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 `cargo new --vcs=git` 来覆盖这些行为。

### Cargo.toml结构
```rust
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

`[dependencies]`，是罗列项目依赖的片段的开始。在 Rust 中，代码包被称为 `crates`。

Cargo 期望源文件存放在 src 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。

### 为没有使用Cargo的项目引入Cargo
要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建：

```rust
$ git clone example.org/some_project
$ cd some_project
$ cargo build
```

### Cargo构建与运行
1. `build`: 在根目录下运行 `cargo build`, 会创建一个可执行文件 `target/debug/hello_cargo`。
   - 由于默认的构建方法是`调试构建（debug build）`，Cargo 会将可执行文件放在名为 `debug` 的目录中。
   - 首次运行 `cargo build` 时，也会使 Cargo 在项目根目录创建一个新文件：`Cargo.lock`。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你自己永远也不需要碰这个文件，让 Cargo 处理它就行了。
2. `run`: 同时编译并运行生成的可执行文件。
   - Cargo 会检查源文件是否有修改，如果没有它就不用重新编译，而是直接运行了可执行文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目
3. `check`: 快速检查代码确保其可以编译，但并`不产生可执行文件`。
   - 通常 `cargo check` 要比 `cargo build` 快得多，因为它省略了生成可执行文件的步骤。
   - 如果你在编写代码时持续的进行检查，`cargo check` 可以让你快速了解现在的代码能不能正常通过编译！当准备好使用可执行文件时才运行 `cargo build`

### 发布（release）构建
当项目最终准备好发布时，可以使用 `cargo build --release` 来`优化`编译项目。这会在 `target/release` 而不是 `target/debug` 下生成可执行文件。

这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。

如果你在测试代码的运行时间，请确保运行 `cargo build --release` 并使用 target/release 下的可执行文件进行测试。


## 2. Guessing Game

默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 `预导入（preclude）` 内容。

如果你需要的类型不在预导入内容中，就必须使用 `use` 语句显式地将其引入作用域。

`std::io` 库提供很多有用的功能，包括接收用户输入的功能。

### 使用变量储存值
在 Rust 中，`变量默认是不可变的`，这意味着一旦我们给变量赋值，这个值就不再可以修改了。

在变量名前使用 `mut` 来使一个变量可变:
```rust
let apples = 5; // 不可变
let mut bananas = 5; // 可变
```

### 静态方法
```rust
let mut guess = String::new();
```
`:: `语法表明 `new` 是 `String` 类型的一个 `关联函数（associated function）`。

关联函数是针对类型实现的，在这个例子中是 String，而不是 String 的某个特定实例。一些语言中把它称为 `静态方法（static method）`。

### 输入输出(std::io)
```rust
    io::stdin()
        .read_line(&mut guess)
        .`expect`("Failed to read line");
```
- 如果程序的开头没有使用 use std::io; 引入 io 库，我们仍可以通过把函数调用写成 std::io::stdin 来使用函数。
- 调用 `read_line` 方法从标准输入句柄获取用户输入。将 `&mut guess` 作为参数传递给 `read_line()` 函数，让其将用户输入储存到这个字符串中。
- `read_line` 的工作是，无论用户在标准输入中键入什么内容，都将其`追加（不会覆盖其原有内容）`到一个字符串中，因此它需要字符串作为参数。
- `&` 表示这个参数是一个 `引用（reference）`，它允许多处代码访问同一处数据，而无需在内存中多次拷贝。


### 使用 Result 类型来处理潜在的错误

```rust
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
```
- `read_line` 会将用户输入附加到传递给它的字符串中，返回一个类型为 `Result` 的值
- `Result` 是一种枚举类型，通常也写作 `enum` 。枚举类型变量的值可以是`多种可能状态`中的一个。我们把每种可能的状态称为一种 `枚举成员（variant）`。
- `Result` 的成员是 `Ok` 和 `Err`:
  - `Ok` 成员表示操作成功，内部包含成功时产生的值。 
  - `Err` 成员则意味着操作失败，并且包含失败的前因后果。
- `Result` 的实例拥有 `expect` 方法。
  - 如果 `io::Result` 实例的值是 `Err` ， `expect` 会导致程序崩溃，并显示当做参数传递给 `expect` 的信息。
  - 如果 `Result` 实例的值是 `Ok`, `expect` 会获取 `Ok` 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。

### 使用 println! 占位符打印值

`{} `是预留在特定位置的占位符.

当打印变量的值时，`变量名可以写进大括号中`。当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。

```rust
let x = 5;
let y = 10;
println!("x = {x} and y + 2 = {}", y + 2);
```
这行代码会打印出` x = 5` and `y + 2 = 12`。

### 使用crate
`crate` 分为`库crate`和`二进制crate`：
  - 库crate 可以包含任意能被其他程序使用的代码，但是不能自执行
  - 二进制crate，如我们正在构建的项目，它生成一个可执行文件

Cargo 对外部 crate 的运用是其真正的亮点所在。在我们使用 rand 编写代码之前，需要修改 Cargo.toml 文件，引入一个 rand 依赖。
```toml
[dependencies]
rand = "0.8.5"
```
> 0.8.5 事实上是 `^0.8.5 `的简写，它表示任何至少是 0.8.5 但小于 0.9.0 的版本。


### Cargo.lock 文件确保构建是可重现的

Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。

Rust 在你第一次运行 `cargo build` 时建立了 Cargo.lock 文件, 当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本. 例如，如果下周 rand crate 的 0.8.6 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷, 多亏有了 Cargo.lock 文件, 项目会持续使用 0.8.5 直到你显式升级。


### 更新 crate 到一个新版本
`cargo update` 会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本. Cargo 接下来会把这些版本写入 Cargo.lock 文件。

不过，Cargo 默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果想要使用 0.9.0 版本的 rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.toml 文件：
```toml
[dependencies]

rand = "0.9.0"
```
下一次运行 `cargo build` 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。


### 使用rand生成一个随机数
```rust
use rand::Rng;
// ...
    let secret_number =
        rand::thread_rng()
            .gen_range(1..=100);
```
- `Rng` 是一个 `trait` ，它定义了随机数生成器应实现的方法
- `rand::thread_rng` 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed
- 接着调用随机数生成器的 `gen_range` 方法: 获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数:
  - 这里使用的这类范围表达式使用了 `start..=end` 这样的形式，也就是说包含了上下端点，所以需要指定 `1..=100` 来请求一个 1 和 100 之间的数。

> 你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法，因此每个 crate 有使用说明文档。
> Cargo 有一个很棒的功能是：运行 `cargo doc --open` 命令来构建所有本地依赖提供的文档，并在浏览器中打开。
> 例如，假设你对 rand crate 中的其他功能感兴趣，你可以运行 `cargo doc --open` 并点击左侧导航栏中的 rand。


### 比较猜测的数字和秘密数字
```rust
use std::cmp::Ordering;

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }

```
- `Ordering` 也是一个枚举，不过它的成员是 `Less` `、Greater` 和 `Equal` 。这是比较两个值时可能出现的三种结果。
- `cmp` 方法用来比较两个值, 并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 guess 与 secret_number 做比较。然后它会返回一个 `Ordering` 枚举的成员。
- `match` 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。


### 静态强类型 & 类型推断
Rust 有一个`静态强类型`系统，同时也有`类型推断`。

当我们写出 `let guess = String::new()` 时，Rust 推断出 `guess` 应该是 `String` 类型，并不需要我们写出类型。

另一方面，`secret_number`，是数字类型。Rust 默认使用 `i32` ，所以它是 secret_number 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。
> Rust的一些数字类型的值可以介于1和100之间：i32为 32位数字；u32为 无符号32位数字；i64为64位数字；以及其他

所以我们必须把从输入中读取到的 `String` 转换为一个真正的数字类型，才好与 `secret_number` 进行比较。

```rust
    let guess: u32 =
        guess.trim()
            .parse()
            .expect("Please type a number!");
```
这里创建了一个叫做 guess 的变量。不过等等，不是已经有了一个叫做 guess 的变量了吗？确实如此，不过 Rust 允许用一个新值来 `隐藏 （Shadowing）` guess 之前的值。这个功能常用在需要`转换值类型`之类的场景。它允许我们`复用 guess` 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。

- String 实例的 `trim` 方法会去除字符串开头和结尾的空白字符. 
  - 用户必须输入 `enter` 键才能让 read_line 返回并输入他们的猜想，这将会在字符串中增加一个`换行（newline）符`。
  - 例如，用户输入 5 并按下 enter（在 Windows 上，按下 enter 键会得到一个回车符和一个换行符，`\r\n`），guess 看起来像这样：5\n 或者 5\r\n。
  - \n 代表 “换行”; \r 代表 “回车”
  - trim 方法会消除 \n 或者 \r\n，只留下 5。


String 实例的 `parse` 方法 将字符串转换成其他类型。
  - 这里用它来把字符串转换为数值。
  - 我们需要告诉 Rust 具体的数字类型，guess 后面的冒号 `:` 指定了变量的类型 `u32`
  - `parse` 方法只有在 String 逻辑上可以转换为数字的时候才能工作, 所以非常容易出错。因此，`parse` 方法返回一个 `Result` 类型。如果 `parse` 不能从字符串生成一个数字，返回一个 `Err` 成员


### 使用循环来允许多次猜测

`loop` 关键字创建了一个无限循环。我们会增加循环来给用户更多机会猜数字：

```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
```

我们想要当猜测正确的数字时游戏停止, 增加一个 `break` 语句:
```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
```

退出循环也意味着退出程序，因为循环是 main 的最后一部分。

### 处理无效输入
```rust
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
```
- 我们将 `expect` 调用换成 `match` 语句，以从遇到错误就崩溃转换为处理错误.
- `Err(_)` 模式：`_` 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息
- break, continue必须处于loop中


# 3. Common Programming Concepts
## 3.1 Variables and Mutability
### 可变性
Rust变量默认是不可改变的（immutable）: 当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。 否则就会报错
Error: `cannot assign twice to immutable variable`

不过`可变性`也是非常有用的，尽管变量默认是不可变的，你仍然可以在变量名前添加 `mut` 来使其可变

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
通过 `mut` ，允许把绑定到 x 的值从 5 改成 6。

### 常量
类似于不可变变量，`常量 (constants)` 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别：
- 不允许对常量使用 `mut`, 常量不光默认不可变，它总是不可变。
- 声明常量使用 `const` 关键字而不是 let，并且 `必须 注明值的类型`。
- 常量可以在任何作用域中声明，包括`全局作用域`，这在一个值需要被很多部分的代码用到时很有用。
- 常量只能被设置为`常量表达式`，而`不可以是`其他任何`只能在运行时计算出的值`。
- Rust 对常量的`命名约定`是在单词之间使用全大写加下划线
  
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

> 在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。
>
> 将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。

### 隐藏
我们可以定义一个与之前变量同名的新变量。实际上，第二个变量“遮蔽”了第一个变量， 此时任何使用该变量名的行为，编译器将其视为是在使用第二个变量，直到第二个变量自己也被隐藏或第二个变量的作用域结束。

可以用相同变量名称来隐藏一个变量，以及`重复使用 let 关键字来多次隐藏`，如下所示：
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

// The value of x in the inner scope is: 12
// The value of x is: 6
```

`隐藏`与将变量标记为 `mut` 是有区别的: 
- 当不小心尝试对变量重新赋值时，如果没有使用 `let` 关键字，就会导致编译时错误。
- 通过使用 `let` ，我们可以用这个值进行一些计算，不过计算完之后变量仍然是`不可变`的。
- 当再次使用 `let` 时，实际上创建了一个`新变量`，我们可以改变值的`类型`，并且复用这个名字。
    ```rust
        let spaces = "   "; // 字符串类型
        let spaces = spaces.len(); // 数字类型
    ```


## 3.2 数据类型

Rust 是 `静态类型（statically typed）`语言，也就是说在`编译时`就必须知道所有变量的类型。

根据值及其使用方式，编译器通常可以`推断`出我们想要用的类型。
当多种类型均有可能时，必须增加`类型注解`:
```rust
let guess: u32 = "42".parse().expect("Not a number!"); // 类型注解 : u32
```
> 缺乏类型注解报错
> error[E0282]: type annotations needed 


### 标量类型

`标量（scalar）`类型代表一个单独的值。Rust 有四种基本的标量类型：
- 整型
- 浮点型
- 布尔类型
- 字符类型

#### 数值运算
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 结果为 -1

    // remainder
    let remainder = 43 % 5;
}
```
> `整数除法`会向`零舍入到最接近的整数`。


#### 字符类型
Rust 的 `char` 类型是语言中最原生的字母类型
```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```
- 用单引号声明 `char` 字面量. `char` 类型的大小为四个字节 (four bytes)
- 使用双引号声明 `字符串字面量(String Literals)`， 其数据类型为`&str`

### 复合类型
`复合类型（Compound types）`可以将多个值组合成一个类型。Rust 有`两个原生的复合类型`：
- 元组（tuple）
- 数组（array）

#### 元组类型

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组`长度固定`：一旦声明，其长度不会增大或缩小。

```rust
fn main() {
    let tup = (500, 6.4, 1);
    // let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (x, y, z) = tup; // 模式匹配（pattern matching）来解构（destructure）元组值

    println!("The value of y is: {y}");

    // 我们也可以使用点号（.）后跟值的索引来直接访问它们。
    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
访问元组元素：
- 模式匹配（pattern matching）来解构（destructure）元组值
- 使用`点号（.）`后跟值的索引来直接访问它们。

#### 数组类型

另一个包含多个值的方式是 数组（array）: 
- 数组中的`每个元素的类型必须相同`。
- 数组`长度是固定`的。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // 在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组
    // let a = [3, 3, 3, 3, 3]; 效果相同
    let a = [3; 5];

}

```

#### 访问数组元素
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 索引访问
    let first = a[0];
    let second = a[1];
}
```
> 访问越界: 如果我们访问数组结尾之后的元素时，导致 `运行时 错误(panic)`。程序带着错误信息退出


## 3.2 函数

函数拥有 `参数（parameters）（形参）`的函数，参数是特殊变量，是函数签名的一部分
为这些参数提供具体的`值（实参）`。技术上讲，这些具体值被称为参数（arguments），


在函数签名中，`必须声明每个参数的类型`。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。

### 

`语句（Statements）`是执行一些操作但不返回值的指令:
- `let y = 6;` 是一个语句。
- `语句`不返回值。因此，不能把 let 语句赋值给另一个变量

`表达式（Expressions）`计算并产生一个值:
- 语句 `let y = 6; `中的 `6` 是一个表达式
- 用大括号创建的一个新的块作用域也是一个表达式，例如：
   ```rust
   let y = {
        let x = 3;

        // 注意 x+1 这一行在结尾没有分号，与你见过的大部分代码行不同。
        // 如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值
        x + 1 
    };
   ```
   y的值是 4



### 具有返回值的函数

在 Rust 中，函数的返回值等同于函数体`最后一个表达式`的值。
```rust
fn five() -> i32 {
    5
}
```

使用 `return` 关键字和指定值，可从函数中提前返回

> 用最后一个表达式返回值时不要加`分号`


## 3.4 注释

用双斜杠` // `注释 Rust 代码

文档注释使用三斜杠 `///` 而以支持 Markdown 注解来格式化文本。
```rust 
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```


## 3.5 控制流

### if

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
> 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是`显式地使用布尔值`作为 if 的条件。


### else if
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }

    // 在 let 语句中使用 if
    let number = if condition { 5 } else { 6 };
}
```
> 使用过多的 else if 表达式会使代码显得杂乱无章，所以如果有多于一个 else if 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 `match`。


### loop、while 和 for
#### loop
```rust
// loop
fn main() {
    let mut counter = 0;
    
    // 赋值给 result 
    let result = loop {
        counter += 1;

        if counter == 10 {
            // 使用 break 关键字返回值 counter * 2
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
#### 循环标签：在多个循环之间消除歧义
如果存在嵌套循环，break 和 continue 应用于此时`最内层的循环`。
你可以选择在一个循环上指定一个 `循环标签（loop label）`，然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。

```rust
// loop
fn main() {
    let mut count = 0;

    // 标签 counting_up
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```


#### while
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```


#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }

    // 使用 for 循环来倒计时
    // rev，用来反转 range
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

# 4. Understanding Ownership
所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全.

## 4.1 什么是所有权？
> Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

在像 Rust 这样的系统编程语言中，`值是位于栈上还是堆上`在更大程度上影响了语言的行为以及为何必须做出这样的抉择。

栈中的所有数据都必须占用已知且固定的大小。

大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。

入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间. 其位置总是在栈顶

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。

> 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。


### 所有权规则
- Rust 中的每一个值都有一个 所有者（owner）。
- 值在任一时刻有且只有一个所有者。
- 当所有者（变量）离开作用域，这个值将被丢弃。


### 变量作用域
```rust
    {                      // s 在这里无效，它尚未声明
        let s = "hello";   // 从此处起，s 是有效的

        // 使用 s
    }                      // 此作用域已结束，s 不再有效
```


### 演示所有权的规则 - String 类型

我们已经见过`字符串字面值(String literals)`，即被硬编码进程序里的字符串值。 字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。
- 原因之一就是`它们是不可变的`。
- 另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？

> 为此，Rust 有第二个字符串类型，`String`。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。

```rust
    // 使用 from 函数基于字符串字面值来创建 String
    let mut s = String::from("hello");

    // String 可以修改
    s.push_str(", world!"); // push_str() 在字符串后追加字面值

    println!("{}", s); // 将打印 `hello, world!`
```

对于 `String` 类型，为了支持一个`可变，可增长`的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
- 必须在`运行时`向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将不再使用的内存返还给分配器的方法。

> Rust 采取了一个不同的策略：内存在`拥有它的变量离开作用域后`就被自动释放。

当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop` ，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的` } `处自动调用 `drop` 。


### 变量与数据交互的方式（一）：移动

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```
指针s1和s2同时指向同一块内存，是 `浅拷贝`。
这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 `二次释放（double free）`的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

为了确保内存安全，在 let s2 = s1; 之后，Rust `认为 s1 不再有效`，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

因而在 s2 被创建之后尝试使用 s1 会发生：`error[E0382]: borrow of moved value: s1`

> 如果你在其他语言中听说过术语 `浅拷贝（shallow copy）`和 `深拷贝（deep copy）`，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。`不过因为 Rust 同时使第一个变量无效了`，这个操作被称为 `移动（move）`，而不是叫做浅拷贝。

> 这里还隐含了一个设计选择：`Rust 永远也不会自动创建数据的 “深拷贝”`。因此，可以假定任何自动复制在运行时性能方面都是廉价的。


### 变量与数据交互的方式（二）：克隆
如果我们确实需要 `深度复制` String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。
```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

#### 只在栈上的数据：拷贝
```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

像`整型`这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。


#### Trait: Copy
Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的`存储在栈上的类型`上.
如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait。

作为一个通用的规则，任何一组`简单标量值的组合`都可以实现 `Copy` ，
任何`不需要分配内存或某种形式资源的类型`都可以实现 `Copy` 。


#### 所有权与函数

将值传递给函数与给变量赋值的原理相似。
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```

当尝试在调用 `takes_ownership` 后使用 `s` 时，Rust 会抛出一个编译时错误。


#### 返回值与作用域

> 返回值也可以转移所有权。变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到takes_and_gives_back 中, 它也将返回值移给 s3                                 
    // takes_and_gives_back返回后s2即被drop


} // 这里，s3，s1移出作用域并被丢弃。

fn gives_ownership() -> String {

    let some_string = String::from("yours");
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

在每一个函数中都获取所有权并接着返回所有权有些啰嗦。
如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了.
-> Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 `引用（references）`

除此之外，我们也可能想返回函数体中产生的一些数据。
-> 我们可以使用`元组`来返回多个值


## 4.2 引用与借用
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // calculate_length完成后并不会drop s1
    println!("The length of '{}' is {}.", s1, len);
}

// s 是 String 的引用
fn calculate_length(s: &String) -> usize {
    s.len()
}
// 当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权。
```

`&s1 `语法让我们创建一个 `指向 值 s1 `的引用，但是并不拥有它。
因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。

#### 尝试修改借用的变量
```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
> 试图修改引用的参数会报错：error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference

### 可变引用
通过一个小调整就能允许我们修改一个借用的值,`可变引用（mutable reference）`：
- 我们必须将 `s` 改为 `mut`。
- 然后在调用 change 函数的地方创建一个可变引用 `&mut s`
- 并更新函数签名以接受一个可变引用 `some_string: &mut String`

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
可变引用有一个很大的限制：
- 如果你有一个对该变量的可变引用，在这个可变引用不再使用前，你不能再创建另一个可变引用。
- 我们 也 不能在拥有不可变引用的同时拥有可变引用。
> 尝试创建两个 s 的可变引用的代码会失败: error[E0499]: cannot borrow `s` as mutable more than once at a time

这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。
这个限制的好处是 Rust 可以在编译时就避免`数据竞争`。

> 注意一个引用的作用域从声明的地方开始一直`持续到最后一次使用为止`。



### 悬垂引用（Dangling References）
在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 `悬垂指针（dangling pointer）`，所谓悬垂指针是`其指向的内存可能已经被分配给其它持有者`。

> 下述代码会报错：error[E0106]: missing lifetime specifier

```rust
fn main() {
    let reference_to_nothing = dangle();
}


// 返回一个String的引用
fn dangle() -> &String {
    let s = String::from("hello");

    &s
    // 预期返回s的引用，但注意此函数完成后s本身会被drop，因而返回的引用指向null
}
```


## 4.3 Slice 类型

`slice` 允许你引用集合中一段连续的元素序列，而不用引用整个集合。
`slice` 是引用，所以它没有所有权。

> usize 是 Rust 编程语言中的一种整数类型，它代表无符号整数。
> 它的大小取决于运行 Rust 代码的计算机架构，通常是与计算机的指针大小相同。在 32 位计算机上，usize 是 32 位无符号整数，而在 64 位计算机上，usize 是 64 位无符号整数。


#### '' 和 b''
注意：' ' 是 Rust 中的 char 字面值，它可以包含单个字符，
而 b' ' 是字节字面值，只包含一个字节。
在 Rust 中，字符字面值通常用于表示文本字符，而字节字面值用于处理二进制数据。


#### &str 和 String 
`&str：` 是一个字符串切片，它是一个`不可变引用（immutable reference）`，通常用于引用字符串文本的一部分，例如从一个 String 或字符串字面值中提取的子串。由于 str 是不可变的，你不能对其进行修改。str 类型通常用于参数传递和字符串处理的引用形式。

`String：`是 Rust 的标准库中提供的可变的、拥有（owned）的字符串类型。它是一个堆分配的字符串，可以随时进行增加、删除和修改操作。String 通常用于需要动态分配和修改字符串内容的情况。

> 当编写函数的入参为字符串时，最好让其类型为`&str`，如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。
> 定义一个获取 `&str` 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：


### 其他类型的 slice
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // data type of slice: &[i32]

assert_eq!(slice, &[2, 3]);
```


# 5. `Structs` to Structure Related Data
struct或structure是一种自定义数据类型，允许您将多个相关的值打包在一起并命名，这些值组成一个有意义的组。
如果您熟悉面向对象的语言， `struct` 就像对象的数据属性。在本章中，我们将比较和对比 `tuple` 和 `struct` ，以建立在您已经知道的基础上，并演示 `struct` 是分组数据的更好方法。

我们将演示如何定义和实例化 `struct` 。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与 `struct` 类型关联的行为。 `Structs` 和 `Enum` (在第6章中讨论)是在程序域中创建新类型以充分利用Rust的编译时类型检查的构建块。

## 5.1 结构体的定义和实例化

```rust
// Def
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
> 结构体数据的所有权: 我们使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型。
> 这是一个有意而为之的选择，因为我们想要这个结构体`拥有它所有的数据`，为此只要整个结构体是有效的话其数据也是有效的。
> 要使结构体存储`被其他对象拥有的数据的引用`, 需要用上 `生命周期（lifetimes）`

#### 访问和修改属性
注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变

```rust
fn main() {
    // Initialize an instance
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    // Access attribute with `.`
    // Modify attribute requires struct to be mutable
    user1.email = String::from("anotheremail@example.com");
}
```

#### Builder
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}

// 为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 email 和 username 字段名称与变量有些啰嗦。
// 如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！
fn build_user_compact(email: String, username: String) -> User {
    User {
        active: true,
        // 使用了字段初始化简写语法，因为 username 和 email 参数与结构体字段同名
        username,
        email,
        sign_in_count: 1,
    }
}
```

### 使用`结构体更新`语法从其他实例创建实例

`使用旧实例的大部分值`但`改变其部分值`来创建一个新的结构体实例通常是很有用的。这可以通过 `结构体更新语法（struct update syntax）`实现。

通过 `..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。

```rust
fn main() {
    let user2 = User {
        // 使用user1实例的属性
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,    
    };
}

// `..` 语法进一步减省
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
        // ..user1 必须放在最后
    };

```
> 请注意，`结构更新语法`就像带有 = 的赋值，因为它`移动`了数据
> 总体上说我们在创建 user2 后不能就再使用 user1 了，因为 user1 的 username 字段中的 String 被移到 user2 中.
> 但如果`更新的字段都是基础类型`如bool和i32，是`实现 Copy trait 的类型`。那么 user1 在创建 user2 后仍然有效


### 元组结构体（tuple structs）

元组结构体`有着结构体名称`提供的含义，但`没有具体的字段名`，只有字段的类型。

虽然Color，Point两个类型都由三个 i32 值组成，但black，origin是不同的元组结构体的实例

元组结构体实例类似于元组，你可以将它们`解构为单独的部分`，也`可以使用 . 后跟索引来访问单独的值`，等等。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
### 类单元结构体（unit-like structs）

我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）

类单元结构体常常在你想要`在某个类型上实现 trait 但不需要在类型中存储数据的时候`发挥作用

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```


## 5.2 结构体示例程序
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn area(rectangle: Rectangle) -> u32 {
    rectangle.height * rectangle.width
}

pub(crate) fn main() {

    let rectangle = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rectangle)
    );
}
```

### 通过派生 trait 增加实用功能

> 派生trait注解：自动生成指定的trait特质的实现， 如Clone，Debug
> 而自定义的trait要手自己编写实现

`println! `宏能处理很多类型的格式，不过，`{}` 默认告诉 `println! `使用被称为 Display 的格式：意在提供给直接终端用户查看的输出。

目前为止见过的基本类型都默认实现了 `Display` ，因为它就是向用户展示 1 或其他任何基本类型的唯一方式。

对于结构体，`println!` 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，所以`结构体并没有提供一个 Display 实现`来使用 `println!` 与 `{}` 占位符。

打印结构体时:
- 在 `{} `中加入 `:? `指示符告诉 `println!` 我们想要使用叫做 `Debug` 的输出格式。
- 结构体定义之前加上外部属性 #[derive(Debug)]

> 当我们有一个更大的结构体时，能有更易读一点的输出就好了，为此可以使用` {:#?}` 替换 println! 字符串中的 `{:?}`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    // Use {:?}
    println!("rect1 is {:?}", rect1);
}
```

### 使用 dbg!
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        // dbg! 返回表达式的值的所有权，所以 width 字段将获得相同的值，就像我们在那里没有 dbg! 调用一样
        width: dbg!(30 * scale),
        height: 50,
    };
    // 我们不希望 dbg! 拥有 rect1 的所有权，所以我们在下一次调用 dbg! 时传递一个引用
    dbg!(&rect1);
}
```

## 5.3 方法语法

`方法（method）`与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。

与函数是不同的，因为它们在结构体的上下文`impl`中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 `self` ，它代表调用该方法的结构体实例。

> `method` 是 结构体 `实现impl` 中定义的

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

#### getter
```rust
impl Rectangle {

    fn width(&self) -> u32 {
        self.width
    }
}

pub(crate) fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!(
        "The width of the rectangle is {} square pixels.",
        rect1.width()
    );
}
```

在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle，`&self 实际上是 self: &Self 的缩写。`, 有4种缩写：
- self 获取所有权
- &self 仅仅读取
- mut self 获取所有权
- &mut self 做出修改

这里选择 `&self `的理由跟在函数版本中使用 &Rectangle 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。

如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self`

> 使用方法替代函数的目的：
> 不需要在每个函数签名中重复 self 的类型之外，
> 其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 impl 块中，而不是让将来的用户在我们的库中到处寻找 Rectangle 的功能。


Getters 很有用，因为你`可以把字段变成私有的，但方法是公共的`，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。

#### -> 运算符到哪去了？
在 C/C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法, 这时需要先`解引用（dereference）指针`。换句话说，如果 object 是一个指针，那么 `object->something()` 就像 `(*object).something()` 一样。

Rust 并没有一个与 -> 等效的运算符；相反，Rust 有一个叫 `自动引用和解引用（automatic referencing and dereferencing）`的功能。`方法调用`是 Rust 中少数几个拥有这种行为的地方。


### 带有更多参数的方法
```rust
impl Rectangle {
    fn can_hold(&self, another_rectangle: &Rectangle) -> bool {
        self.width >= another_rectangle.width
            && self.height >= another_rectangle.height
    }
}
```

### 关联函数
所有在 `impl` 块中定义的函数被称为 `关联函数（associated functions）`，因为它们与 `impl` 后面命名的类型相关。

可以定义`不以 self 为第一参数的关联函数（因此不是方法）`，因为它们并`不作用于一个结构体的实例`。我们已经使用了一个这样的函数：在 String 类型上定义的 `String::from` 函数。

不是方法的关联函数`经常被用作返回一个结构体新实例的构造函数`。

> 使用结构体名和 `::` 语法来调用这个关联函数

```rust
impl Rectangle {
    fn square(size: u32) -> Self { // Self 即是 Rectangle
        Self {
            width: size,
            height: size,
        }
    }
}
```

# 6. Enums and Pattern Matching

enums 提供了一种说明一个 value 是一组可能的 value 之一的方法

假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4（version four）和 IPv6（version six）。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以 `枚举` 出所有可能的值. 

任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个成员。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// 类似于定义多个不同类型的结构体，如下
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
```

枚举还有另一个相似点：就像可以使用 `impl` 来为结构体定义方法那样
```rust
    impl Message {
        fn call(&self) {
            // 在这里定义方法体
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```

### Option 枚举和其相对于空值的优势

`Option` 是标准库定义的一个枚举. `Option` 类型应用广泛因为它编码了一个非常普遍的场景，`即一个值要么有值要么没值。`

Rust 并`没有`很多其他语言中有的`空值功能`。空值（Null ）是一个值，它代表没有值。空值是一个因为某种原因目前无效或缺失的值。
在有空值的语言中，变量总是这两种状态之一：空值和非空值。

`Rust 并没有空值`，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`, 它定义于标准库中:
```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T> `枚举是如此有用以至于它甚至被包含在了 `prelude` 之中, 可以不需要 Option:: 前缀来`直接使用 Some 和 None`

> <T> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。

我们在 Some 成员中指定了值，`Rust 可以推断其类型。`
```rust
    // some_number 的类型是 Option<i32>
    let some_number = Some(5);
    // some_char 的类型是 Option<char>
    let some_char = Some('e');
    // 需要指定 Option 整体的类型，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型
    // 我们告诉 Rust 希望 absent_number 是 Option<i32> 类型的。
    let absent_number: Option<i32> = None;
```

`Option<T>` 为什么就比空值要好呢？
-> 因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个`肯定有效的值`那样使用 `Option<T>`
```rust
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```
上述代码会报错：error[E0277]: cannot add `Option<i8>` to `i8`。因为它尝试将 `Option<i8>` 与 `i8` 相加.
换句话说，在对 `Option<T>` 进行运算之前必须将其转换为` T`.

如何从 `Some` 成员中取出 `T` 的值来使用它呢?
-> 为了使用` Option<T>` 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 `Some(T)` 值时运行，允许这些代码使用其中的 `T`。也希望一些代码只在值为 `None` 时运行，这些代码并没有一个可用的 `T` `值。match` 表达式就是这么一个处理枚举的控制流结构


## 6.2 match 控制流结构
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }, // 分支后的逗号是可选的
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 绑定值的模式
```rust
#[derive(Debug)] // 这样可以立刻看到州的名称
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```
调用 `value_in_cents(Coin::Quarter(UsState::Alaska))` 会打印 `State quarter from Alaska`, 且返回值为`25`

### 匹配 Option<T>
比如我们想要编写一个函数，它获取一个 `Option<i32>` ，如果其中含有一个值，将其加一。
如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => {
            Some(i + 1)
        },
        None => None,
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

### 匹配是穷尽的(exhaustive)
match 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。否则会报错：`error[E0004]: non-exhaustive patterns: `None` not covered`

### 通配模式和 _ 占位符
```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other), // other变量名不matter, 可以用其他名称
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
```
即使我们没有列出 `u8` 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。
这种通配模式满足了 `match` 必须被穷尽的要求。
> 请注意，我们必须将`通配分支放在最后`，因为模式是按顺序匹配的。

Rust 还提供了一个模式，当我们`不想使用通配模式获取的值`时，请使用 `_` ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。
这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。
> 使用 _ 时，=>右边不能有使用 _ 的场景
```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(), // reroll函数不关心也不使用 _
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
```

## 6.3 if let 简洁控制流
`if let `语法让我们以一种不那么冗长的方式结合 `if` 和 `let` ，来处理`只匹配一个模式的值`而忽略其他模式的情况。

```rust
    let config_max = Some(3u8); // 等价于 let config_max: Option<u8> = Some(3);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
```
上述代码为了满足 match 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 `_ => ()`，这样也要增加很多烦人的样板代码。
我们可以使用 if let 这种更短的方式编写:

```rust
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
```
> if let 必须严格按照 `if let SomePattern = some_expression { \\ }` 的格式，不能对换Pattern 和 expression


可以在 if let 中包含一个 else。else 块中的代码与 match 表达式中的 _ 分支块中的代码相同，这样的 match 表达式就等同于 if let 和 else。

```rust
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }

    // 上述代码等价于下：
    if let coin = Coin::Quarter(state) { // = 左右顺序不重要
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }

```

换句话说，可以认为 `if let` 是 match 的一个`语法糖`，它当值匹配某一模式时执行代码而忽略所有其他值。

# 7. Packages, Crates, and Modules

- 包（Packages）：Cargo 的一个功能，它允许你构建、测试和分享 crate。
- Crates ：一个模块的树形结构，它形成了库(library)或二进制项目(executable)。
- 模块（Modules）和 use：允许你控制作用域和路径的私有性。
- 路径（path）：一个命名例如结构体、函数或模块等项的方式

## 7.1 Package 和 Crate

### Crate
crate 是 Rust 在编译时最小的代码单位。

crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译，我们会在接下来的章节中遇到。

crate 有两种形式：
- library: `没有 main 函数`，它们也不会编译为可执行程序，它们提供一些诸如函数之类的东西，使其他项目也能使用这些东西
- executable: 被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个 main 函数来定义当程序被执行的时候所需要做的事情。

> `crate root` 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块
> 对于一个 executable , crate root = src/main.rs 
> 对于一个 library, crate root = src/lib.rs

### Package
package 是提供一系列功能的一个或者多个 crate。一个package会包含一个 `Cargo.toml` 文件，阐述如何去构建这些 crate。

package 必须至少包含一个 crate:
- 可以包含至多一个 library
- 可以包含任意多个 executable

> 通过将文件放在 `src/bin` 目录下，一个包可以拥有多个 executable ：每个` src/bin `下的文件都会被编译成一个独立的 executable 。


## 7.2 定义模块来控制作用域与私有性
### Module

声明模块
```rust
// in main.rs or lib.rs

// normal declaration
mod normal_module;
// inline declaration
mod inline_module {
    fn some_function() {
        println!("This is a function inside the my_module.");
    }

    pub fn public_function() {
        println!("This is a public function inside the my_module.");
    }
}

fn main() {
    normal_module::some_function();
    inline_module::public_function();
}
```

- 一个模块里的代码默认对其父模块私有。
- 为了使一个模块公用，应当在声明时使用`pub mod`替代mod。
- 为了使一个公用模块内部的成员公用，应当在声明前使用`pub`。


`use `关键字: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。
```rust
use crate::garden::vegetables::Asparagus;

pub mod garden; // 意味着在src/garden/vegetables.rs中的代码也应该被包括

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
```

### 对相关代码进行分组
模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。

一个模块中的代码默认是`私有的`，所以还可以利用模块控制项的 私有性。

```rust
mod front_of_house {
    mod hosting { // child mod
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving { // child mod
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

## 7.3 引用模块项目的路径

我们使用`路径`的方式在模块树中找到一个项的位置

路径有两种形式：
- 绝对路径（absolute path）是以 crate root开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 crate 开头。
- 相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    // front_of_house 模块与 eat_at_restaurant 定义于同一模块，
    // 所以从 eat_at_restaurant 中开始定义的该模块相对路径是有效的。
    front_of_house::hosting::add_to_waitlist();
}
```

上述代码会报错：`error[E0603]: module `hosting` is private`。虽然调用路径是合法的，但在 Rust 中，默认所有项（函数、方法、结构体、枚举、模块和常量）`对父模块都是私有的`。

父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项

不过 Rust 也确实提供了通过使用 `pub` 关键字来创建公共项，使子模块的内部部分暴露给上级模块。

### 使用 pub 关键字暴露路径
```rust
mod front_of_house {
    // 让父模块中的 eat_at_restaurant 函数可以访问子模块 hosting
    pub mod hosting {
        //  让父模块中的 eat_at_restaurant 函数可以访问子模块内部代码add_to_waitlist
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
```

#### executable 和 library 的最佳实践
- 在 executable 中只有足够的代码来启动一个可执行文件，可执行文件调用 library 的代码。
- 模块树应该定义在 src/lib.rs 中。这样通过以包名开头的路径，公有项就可以在 executable 中使用。
-  executable 就完全变成了同其它 外部 crate 一样的 library 的用户：它只能使用公有 API
- 这有助于你设计一个好的 API；你不仅仅是作者，也是用户！ 


### super 开始的相对路径
```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        // 通过在路径的开头使用 super ，从父模块开始构建相对路径
        super::deliver_order();
    }

    fn cook_order() {}
}
```

super可以`多重使用`
```rust
mod a {
    pub fn hello() {
        println!("Hello from module a");
    }

    pub(crate) mod b {
        pub fn hello() {
            println!("Greetings from module b");
        }

        pub(crate) mod c {
            pub fn greet() {
                // b::hello()
                super::hello();
                // a::hello()
                super::super::hello();
            }
        }
    }
}

pub(crate) fn main() {
    a::b::c::greet();
}
```

### 创建公有的结构体和枚举

- 在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。
- 将枚举设为公有，则它的所有成员都将变为公有。

> 如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 pub 是很令人恼火的，因此枚举成员默认就是公有的。
> 结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String, // toast公有
        seasonal_fruit: String, // seasonal_fruit仍然是私有
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }

    // Soup, Salad都为公有
    pub enum Appetizer {
        Soup,
        Salad,
    }
}
```

## 7.4 使用 use 关键字将路径引入作用域

不得不编写路径来调用函数显得不便且重复。
-> 们可以使用 `use` 关键字创建一个短路径，然后就可以在`作用域中`的任何地方使用这个更短的名字。

在作用域中增加 `use` 和路径类似于在文件系统中创建`软连接（符号连接，symbolic link）`。

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

### 使用 as 关键字提供新的名称
考虑以下场景, fmt和io都有各自的Result, 通过use来区分
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

使用 use 将两个同名类型引入同一作用域这个问题还有另一个解决办法：在这个类型的路径后面，我们使用 as 指定一个新的本地名称或者别名。

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```


### 使用 pub use 重导出名称
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// 重导出（re-exporting)
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```
修改之前，外部代码需要使用路径 `restaurant::front_of_house::hosting::add_to_waitlist()`

现在, 外部代码现在可以使用路径 `restaurant::hosting::add_to_waitlist`

> 当你代码的内部结构与调用你代码的程序员所想象的结构不同时，重导出会很有用。

### 使用外部包

crates.io 上有很多 Rust 社区成员发布的包，将其引入你自己的项目都需要一道相同的步骤：
- 在 Cargo.toml 列出它们
- 并通过 use 将其中定义的项引入项目包的作用域中。

```rust
// in Cargo.toml
rand = "0.8.5"

// in your rs code
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
```

注意 `std` 标准库对于你的包来说也是外部 crate。
- 无需修改 Cargo.toml 来引入 std
- 不过需要通过 use 将标准库中定义的项引入项目包的作用域中来引用它们

```rust
use std::collections::HashMap;
```

### 嵌套路径来消除大量的 use 行

当需要引入很多`定义于相同包或相同模块的项`时，为每一项单独列出一行会占用源码很大的空间。

```rust
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--

// 等价于
use std::{cmp::Ordering, io};


use std::io;
use std::io::Write;

// 等价于
use std::io::{self, Write};

```

### 通过 glob 运算符(*)将所有的公有定义引入作用域
如果希望将一个路径下` 所有 公有项`引入作用域，可以指定路径后跟 glob 运算符(`*`)：
```rust
use std::collections::*;
```
> 使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。
> glob 运算符经常用于测试模块 tests 中，这时会将所有内容引入作用域

## 7.5 将模块拆分成多个文件

注意你只需在模块树中的某处使用一次 mod 声明就可以加载这个文件。

换句话说，mod 不是 你可能会在其他编程语言中看到的 "include" 操作。

# 8. 常见集合
## 8.1 Vector

类型 `Vec<T>` 允许我们在一个单独的数据结构中储存多于一个的值，它在`内存中彼此相邻地排`列所有的值。


### Create
```rust 
    // create a empty vector
    let v: Vec<i32> = Vec::new();
    // create an initialized vector with macro 'vec!'
    let v = vec![1, 2, 3];
```

### Update
```rust
    // 放入其中的所有值都是 i32 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 Vec<i32> 注解。
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
```

### Access
```rust
    let v = vec![1, 2, 3, 4, 5];

    // style-1: read with index
    let third: &i32 = &v[2];

    // style-2: read with .get()
    let third: Option<&i32> = v.get(2)
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```

> 索引语法, 当引用一个不存在的元素时 Rust 会造成 panic

#### 借用规则与读取vec元素
```rust
    let mut v = vec![1, 2, 3, 4, 5];

    // 获取了一个有效的引用
    // immutable borrow occurs here
    let first = &v[0];

    // 在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。
    // 这时，第一个元素的引用就指向了被释放的内存。
    // mutable borrow occurs here
    v.push(6);

    // immutable borrow later used here
    println!("The first element is: {first}");
```
上述代码会报错：`error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable`

> 如果没有 `println!("The first element is: {first}");` 或者这行在 `v.push(6);` 之前则不会有问题

### 遍历 vector 中的元素
```rust
    let v = vec![100, 32, 57];
    
    // 获取 v 中的每一个元素的不可变引用并将其打印
    for i in &v {
        println!("{i}");
    }

    // 遍历可变 vector 的每一个元素的可变引用以便能改变它们
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        // 解引用运算符（*）获取 i 中的值
        *i += 50;
    }
```

> 因为借用检查器的规则，无论可变还是不可变地遍历一个 vector 都是安全的。
> 如果尝试在 for 循环体内`插入或删除项`，都会得到`error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable`。
> for 循环中获取的 vector 引用阻止了同时对 `vector 整体`的修改。

### 使用枚举来储存多种类型

vector `只能储存相同类型的值`。这是很不方便的

会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！

```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(10.12),
        SpreadsheetCell::Text(String::from("blue")),
    ];
```

Rust 在编译时就必须准确的知道 vector 中类型:
- 它需要知道储存每个元素到底需要多少内存
- 如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误。

### 丢弃 vector 时也会丢弃其所有元素
```rust
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v

    } // <- v goes out of scope and is freed here
      // 借用检查器确保了任何 vector 中内容的引用仅在 vector 本身有效时才可用。
```

## 8.2 字符串(String) 和 UTF-8 encoded Text

Rust 的核心语言中只有一种字符串类型：字符串 `slice str`，它通常以被借用的形式出现，&str

### 新建字符串

很多 Vec 可用的操作在 String 中同样可用，事实上 String 被实现为一个带有一些额外保证、限制和功能的`字节 vector 的封装`。

```rust
    // new 函数新建了一个叫做 s 的空的字符串
    let mut s = String::new();

    // to_string 方法，它能用于任何实现了 Display trait 的类型，比如字符串字面值
    let data = "initial contents";
    let s = data.to_string();
    // 该方法也可直接用于字符串字面值：
    let s = "initial contents".to_string();

    // 使用 String::from 函数来从string slice 创建 String
    let s = String::from("initial contents");

```

### 更新字符串

String 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 Vec 的内容一样。

#### push_str
```rust
    // 通过 push_str 方法来附加字符串 slice，从而使 String 变长
    // -> foobar
    let mut s = String::from("foo");
    // "bar" 是 &str, 我们并不需要获取参数的所有权
    // 否则下面的println! s2就会出错
    s.push_str("bar"); 
    println!("s2 is {s2}"); 
```
#### + 
```rust
    // 使用 + 运算符 拼接字符串
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
```

+ 运算符使用了 add 函数，这个函数签名看起来像这样：
`fn add(self, s: &str) -> String {`

所以 `let s3 = &s1 + &s2;` 也是不行的，会报错 `Cannot add &String to &String [E0369]`

之所以能够在 add 调用中使用 &s2 是因为 &String 可以被 强转（coerced）成 &str。当add函数被调用时，Rust 使用了一个被称为 `Deref 强制转换（deref coercion）`的技术，你可以将其理解为它把 &s2 变成了 &s2[..]

> a + b 会获取a的所有权， 如果想要级联多个字符串，+ 的行为就显得笨重了，很难理解具体发生了什么。

#### format!
format! 与 println! 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 String。

宏 format! 生成的代码使用引用所以`不会获取任何参数的所有权`。

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
```


### 索引字符串

Rust 的字符串不支持索引，如`let h = s[0]`, 索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。

如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```
这里，s 会是一个 &str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。

如果获取 &hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：`thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З'`

### 遍历字符串的方法
操作字符串每一部分的最好的方法是明确表示需要字符还是字节。

```rust
// З
// д
for c in "Зд".chars() {
    println!("{c}");
}

// 208
// 151
// 208
// 180
for b in "Зд".bytes() {
    println!("{b}");
}

```

## 8.3 HashMap and Key-Value entry

HashMap<K, V> 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中。

### 新建一个哈希 map
```rust
    use std::collection::HashMap;

    let mut scores = HashMap::new();

    // push an entry
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
```

> 注意必须首先 use 标准库中集合部分的 HashMap。在这三个常用集合中，HashMap 是最不常用的，所以并没有被 prelude 自动引用。
> 标准库中对 HashMap 的支持也相对较少，例如，并没有内建的构建宏。

### 访问哈希 map 中的值
```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let score = scores.get(&String::from("Blue"))
                      .copied()
                      .unwrap_or(0);
```
- get 方法返回 Option<&V>, 如果某个键在哈希 map 中没有对应的值，get 会返回 None
- copied 方法来获取一个 Option<i32> 而不是 Option<&i32>
- unwrap_or在 scores 中没有该键所对应的项时将其设置为零。

可以使用与 vector 类似的方式来`遍历`哈希 map 中的每一个键值对，也就是 for 循环：
```rust
    for (key, value) in &scores {
        println!("{key}: {value}");
    }
```

### 哈希 map 和所有权
对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。
对于像 String 这样拥有所有权的值，其值将被移动而`哈希 map 会成为这些值的所有者`，

```rust
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // 这里 field_name 和 field_value 不再有效，
```

> 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。
> 但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。

### 更新哈希 map

当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况:
- 可以选择完全无视旧值并用新值代替旧值。-> insert
- 可以选择保留旧值而忽略新值，并只在键 没有 对应值时增加新值。 -> entry().or_insert()
- 可以结合新旧两值。-> 

```rust
    use std::collection::HashMap;

    let mut scores = HashMap::new();

    // 完全无视旧值并用新值代替旧值
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);
    
    // 保留旧值而忽略新值
    // 对应的值存在时就返回这个值的可变引用, 没有 对应值时增加新值
    scores.entry(String::from("Blue")).or_insert(50);
    
    // 找到一个键对应的值并根据旧的值更新它
    // 计数一些文本中每一个单词分别出现了多少次
    let text = "hello world wonderful world";
    let mut map = HashMap::new();
    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        // 为了赋值必须首先使用星号（*）解引用 count
        *count += 1;
    }

```

### 哈希函数
HashMap 默认使用一种叫做 `SipHash` 的哈希函数，它可以抵御涉及哈希表（hash table）1 的拒绝服务（Denial of Service, DoS）攻击

> 拒绝服务攻击（Denial of Service，缩写为DoS）是一种网络攻击，旨在使目标系统、网络或服务不可用，从而阻止合法用户访问或使用这些资源。这类攻击的目标是破坏系统的正常运行、削弱性能、或完全使其停止响应请求。拒绝服务攻击通常不涉及对系统的未经授权访问或数据盗窃，而是专注于瘫痪或干扰目标系统的可用性。
> 分布式拒绝服务攻击（DDoS，Distributed Denial of Service）是一种网络攻击，它旨在通过同时从多个来源发送大量请求或数据流量，使目标系统、网络或服务不可用。

# 9.错误处理
Rust 将错误分为两大类：
- 可恢复的（recoverable）: 对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。
- 不可恢复的（unrecoverable）: 错误不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。


`Rust 没有异常`。
相反，它有 `Result<T, E>` 类型，用于处理可恢复的错误，
还有 `panic!` 宏，在程序遇到不可恢复的错误时停止执行。

本章首先介绍 `panic!` 调用，接着会讲到如何返回 `Result<T, E>`。

## 9.1 用 panic! 处理不可恢复的错误
在实践中有两种方法造成 panic：
- 执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）
- 显式调用 panic! 宏。

通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。

#### 对应 panic 时的栈展开或终止
当出现 panic 时，程序会:
- 默认: 展开（unwinding）,Rust 会回溯栈并清理它遇到的每一个函数的数据
- 直接 终止（abort），这会不清理数据就退出程序。程序所使用的内存需要由操作系统来清理。

如果你需要项目的最终二进制文件越小越好, 可以由`展开`切换为`终止`。
```rust
// 在 release 模式中 panic 时直接终止
[profile.release]
panic = 'abort'
```

### 使用 panic! 的 backtrace

`RUST_BACKTRACE` 是一个用于 Rust 程序的环境变量，它用于控制程序在发生 panic（恐慌）时生成堆栈跟踪信息。

堆栈跟踪信息显示了程序在哪里发生了 panic，帮助开发人员定位问题并进行调试。

具体来说，RUST_BACKTRACE 环境变量有以下值：

- `RUST_BACKTRACE=0`：这是`默认值`。在发生 panic 时，程序不会生成堆栈跟踪信息。

- `RUST_BACKTRACE=1`：当发生 panic 时，程序会生成简单的堆栈跟踪信息，显示 panic 发生的位置（函数调用链），但不会包括源代码行号信息。

- `RUST_BACKTRACE=full`：当发生 panic 时，程序会生成详细的堆栈跟踪信息，包括源代码行号信息，帮助你更容易地追踪问题。

设置 `RUST_BACKTRACE=1` 或 `RUST_BACKTRACE=full` 可以`在开发和调试阶段`帮助你快速定位和修复程序中的问题，特别是在处理 panic 或错误时，这些堆栈跟踪信息对于找出问题的原因非常有帮助。

但`在生产环境中`，通常应将其设置为默认值 `RUST_BACKTRACE=0`，以避免泄漏敏感信息，并提高程序的性能。

#### 设置 RUST_BACKTRACE 环境变量
1. `命令行参数：`你可以在运行 Rust 程序的命令行中直接设置 RUST_BACKTRACE 环境变量，例如：
   ```bash
   RUST_BACKTRACE=1 ./your_rust_program
   ```
2. `Unix/Linux 的shell环境变量：`你可以在终端中设置 RUST_BACKTRACE 环境变量，然后运行程序，例如：
    ```bash
    export RUST_BACKTRACE=1
    ./your_rust_program
    ```
3. `.env 文件(recommended)：`你可以在项目目录中创建一个名为 .env 的文件，然后在其中设置 RUST_BACKTRACE 环境变量。这对于项目特定的配置非常有用。
在 .env 文件中添加以下内容：
    ```makefile
    RUST_BACKTRACE=1
    ```
    然后在运行 Rust 程序之前，可以使用工具（如 dotenv）加载 .env 文件以设置环境变量。
4. 系统环境变量：你还可以在操作系统级别设置 RUST_BACKTRACE 环境变量，这将影响整个系统上的 Rust 程序。
   例如，在Unix/Linux系统中，你可以编辑 ~/.bashrc 或 ~/.bash_profile 文件，并添加以下行：
   ```bash
   export RUST_BACKTRACE=1
   ```

## 9.2 用 Result 处理可恢复的错误

Result 枚举，它定义有如下两个成员，Ok 和 Err：
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` 和 `E` 是泛型类型参数.  `T` 代表成功时返回的 Ok 成员中的数据的类型，而 `E` 代表失败时返回的 Err 成员中的错误的类型。


如示例所示打开一个文件:
```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        // 成功时 greeting_file_result 变量将会是一个包含文件句柄的 Ok 实例
        Ok(file) => file,
        // 失败时，greeting_file_result 变量将会是一个包含了更多关于发生了何种错误的信息的 Err 实例。
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

> Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::。

### 匹配不同的错误
上述代码不管 File::open 是因为什么原因失败都会 panic!。

我们真正希望的是对不同的错误原因采取不同的行为：
- 如果 File::open 因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。
- 如果 File::open 因为任何其他原因失败，例如没有打开文件的权限，我们仍然希望像示例 9-4 那样 panic!

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            // 尝试通过 File::create 创建文件。
            // 然而因为 File::create 也可能会失败，还需要增加一个内层 match 语句。
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

#### 使用闭包代替match和Result<T, E>
上述代码可以被改写为:

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```
`unwrap_or_else` 用于处理可能的错误情况或Option中的None值, 允许你从Option或Result中获取值: 
- 如果值存在，就返回它；
- 如果值不存在（Option为None或Result为Err），则可以提供一个闭包（closure）作为参数，以生成或计算一个替代值来代替错误值或None。

```rust
fn unwrap_or_else<F>(self, op: F) -> T
```
- self 表示一个Option或Result类型的实例，即要操作的值。
- op 是一个闭包，用于生成替代值的逻辑。这个闭包不接受任何参数，返回类型必须与Option中的值类型或Result中的Ok值类型匹配。如果操作成功，它会返回替代值。

示例1 - 处理Option：
```rust
let maybe_value: Option<i32> = Some(42);
let default_value = 0;
let result = maybe_value.unwrap_or_else(|| default_value * 2);
// 如果maybe_value包含Some(42)，则result为42，否则为0 * 2 = 0
```

示例2 - 处理Result：
```rust
fn potentially_fallible_operation() -> Result<i32, &'static str> {
    // 模拟可能失败的操作
    Err("Something went wrong")
}

let result = potentially_fallible_operation();
let default_result = 100;
let final_result = result.unwrap_or_else(|err| {
    println!("Error: {}", err);
    default_result
});
// 如果potentially_fallible_operation()返回Err("Something went wrong")，final_result为100，并打印错误信息。

```

> 上述代码中的||, |err|的 ||是用来干什么的

`||` 用于包裹闭包的参数：
- `||`：这是一个空参数列表的闭包。在这种情况下，它表示不接受任何参数。闭包内部的逻辑不依赖于外部的参数。
- `|err|`: 这是一个带有参数的闭包，其中err 是闭包的参数名。它表示闭包接受一个参数，该参数用于处理函数内部的逻辑。


### 失败时 panic 的简写：unwrap 和 expect

`unwrap`: 
- 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。
- 如果 Result 是成员 Err，unwrap 会为我们调用 panic!

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

expect:
- 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。
- 如果实际是 Err 分支，它将引发 panic。expect 方法将在标准错误流中输出指定的错误消息，然后终止程序的执行。
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

> expect 在调用 panic! 时使用的错误信息将是我们传递给 expect 的参数，而不像 unwrap 那样使用默认的 panic! 信息。
> 在生产级别的代码中，大多数Rustaceans选择Expect而不是Unrap，并给出了更多关于为什么预期操作总是成功的上下文。

### 传播错误
当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误。
> 类似于java中的抛出异常，作为中间环节的程序员并不需要总是在自己的环节处理所有可能的错误。


```rust
use std::fs::File;
use std::io::{self, Read};

// 展示了一个从文件中读取用户名的函数。
// Note: 返回值类型为Result<String, io::Error>
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        // 如果文件不存在, 将错误返回给调用它的代码
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        // 不能读取, 将错误返回给调用它的代码
        Err(e) => Err(e),
    }
}
```

> 这里选择 io::Error 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：File::open 和 read_to_string 。

### 传播错误的简写：? 运算符

使用 `? `运算符改写上节的`read_username_from_file`代码:
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```
Rust 中的 ? 运算符用于处理 Result 类型，特别是在函数中处理可能引发错误的操作。

? 运算符的主要作用是将 Result 类型的结果解包：
- 如果结果是 Ok 则将 Ok 分支的值返回
- 如果结果是 Err 则将 Err 分支的错误值作为函数的返回值，并用 ? 运算符早期返回（即提前从函数中返回错误）。

我们甚至可以在 ? 之后直接使用`链式方法`调用来进一步缩短代码:
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

## 9.3 要不要 panic!

你可以选择对任何错误场景都调用 panic!，不管是否有可能恢复，不过这样就是你代替调用者决定了这是不可恢复的。

选择返回 Result 值的话，就将选择权交给了调用者，而不是代替他们做出决定。


# 10. Generic Types, Traits, and Lifetimes

每一个编程语言都有`高效处理重复概念`的工具。在 Rust 中其工具之一就是 `泛型（generics）`。

`trait`，这是一个定义泛型行为的方法。`trait` 可以与泛型结合来`将泛型限制为只接受拥有特定行为的类型`，而不是任意类型。

`生命周期（lifetimes）`，它是一类允许我们向编译器提供`引用如何相互关联的泛型`。

### 没有泛型时的处理方式：提取函数

```rust
// 在两个不同的数字列表中寻找最大值
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
```
> number和largest都是引用，为什么不需要解引用就可以比较大小?
> Rust 具有一些内建的功能，允许直接在引用上执行比较操作，而无需显式解引用。
> 这是因为 Rust 提供了实现 PartialOrd 和 Ord trait 的类型的引用比较的功能。

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = find_largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = find_largest(&number_list);
    println!("The largest number is {}", result);
}

fn find_largest(list: &[i32]) -> &i32{
    let mut largest = &list[0];

    for number in &list {
        if number > largest {
            largest = number;
        }
    }

    largest
}
```

## 9.2 泛型数据类型

### 在函数定义中使用泛型

当使用泛型定义函数时，本来在`函数签名`中`指定参数和返回值的类型`的地方，会改用泛型来表示。

```rust
// 两个函数，不同点只是名称和签名类型
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```
使用泛型改写：
```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```
> 为了定义泛型版本的 largest 函数，类型参数声明位于函数名称与参数列表中间的尖括号 `<>` 中

可以这样理解这个定义：`函数 largest 有泛型类型 T`。
它有个参数 list，其类型是元素为 T 的 slice。largest 函数会返回一个与 T 相同类型的引用。

> 目前直接编译会报错：error[E0369]: binary operation `>` cannot be applied to type `&T`
> 这个错误表明 largest 的函数体不能适用于 T 的所有可能的类型。因为在函数体需要比较 T 类型的值 （binary operation `>`）
> 为了开启比较功能，标准库中定义的` std::cmp::PartialOrd trait` 可以实现类型的比较功能
> 依照帮助说明中的建议，我们限制 T 只对实现了 `PartialOrd` 的类型有效后代码就可以编译了，因为标准库为 i32 和 char 实现了 PartialOrd。

```rust
fn largest<T>(list: &[T]) -> &T
// 限制 T 只对实现了 `PartialOrd` 的类型有效
where
    T: PartialOrd, 
{
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

### 结构体定义中的泛型
```rust
// 定义了一个可以存放任何类型的 x 和 y 坐标值的结构体 Point
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

注意 Point<T> 的定义中只使用了一个泛型类型，这个定义表明结构体 Point<T> 对于一些类型 T 是泛型的，而且`字段 x 和 y 都是 相同类型`的，无论它具体是何类型。

> `let wont_work = Point { x: 5, y: 4.0 };` 会报错：`error[E0308]: mismatched types`

想要定义一个 x 和 y 可以有不同类型且仍然是泛型的 Point 结构体，我们可以使用多个泛型类型参数:
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

> 你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。
> 当你发现代码中需要很多泛型时，这可能表明`你的代码需要重构分解成更小的结构`。

### 枚举定义中的泛型
```rust
// 和结构体类似，枚举也可以在成员中存放泛型数据类型。
enum Option<T> {
    Some(T),
    None,
}

// 枚举也可以拥有多个泛型类型。
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

> 当你意识到代码中定义了多个结构体或枚举，它们`不一样的地方只是其中的值的类型`的时候，不妨通过泛型类型来避免重复。

### 方法定义中的泛型
```rust
struct Point<T> {
    x: T,
    y: T,
}


// 在Point上实现的名为 x 的方法
impl<T> Point<T> {
    // x 方法
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
注意必须在 impl 后面声明 T，这样就可以在 Point<T> 上实现的方法中使用 T 了。
通过在 impl 之后声明泛型 T，Rust 就知道 Point 的尖括号中的类型是泛型而不是具体类型。
impl 中编写的方法声明了泛型类型可以定位为任何类型的实例，不管最终替换泛型类型的是何具体类型。

定义方法时也可以为 `泛型指定限制（constraint）`。例如，可以选择为 Point<f32> 实例实现方法，而不是为泛型 Point 实例。
```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```
这段代码意味着 Point<f32> 类型会有一个方法 `distance_from_origin` ，而`其他 T 不是 f32 类型`的 Point<T> 实例则`没有定义此方法`。

#### 定义中的泛型类型 & 方法签名中使用的泛型

结构体定义中的泛型类型参数`并不总是`与结构体方法签名中使用的泛型`是同一类型`。
```rust
// Point 结构体使用了泛型类型 X1 和 Y1
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    // mixup 方法签名使用了 X2 和 Y2
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            // self的x是X1
            x: self.x,
            // other的y是Y2
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

### 泛型代码的性能

泛型并不会使程序比具体类型运行得慢。

Rust 编译这些代码的时候，它会进行单态化。会将每种情况下的泛型代码编译为具体类型，使用泛型`没有运行时开销`。

当代码运行时，它的执行效率就跟好像手写每个具体定义的重复代码一样。

## 10.2 Trait：定义共同行为

`trait` 定义了某个特定类型拥有可能与其他类型共享的功能。可以通过 `trait` 以一种抽象的方式定义共享的行为。

可以使用 `trait bounds` 指定泛型是任何拥有特定行为的类型。

> 注意：`trait` 类似于其他语言中的常被称为 接口（interfaces）的功能，虽然有一些不同。

在Java中：
- 一个类（class）可以继承一个或多个接口（interface）。
- 如果一个类继承了一个接口，它必须提供该接口中定义的所有方法的具体实现。这是Java的接口的要求。

在Rust中：
- 一个结构体（struct）或枚举（enum）可以实现一个或多个trait。
- 如果一个类型实现了一个trait，它只需要实现trait中的那些方法，没有强制要求实现全部方法。这意味着在Rust中，你可以选择性地实现trait中的方法，而不必提供全部方法的实现。这种方式提供了更大的灵活性。


然而，有一些例外情况：
- 在Rust中，如果一个trait中的某些方法被标记为"`必须实现`"（也就是`没有默认实现`），那么在实现这个trait时，你必须提供这些方法的具体实现。
- 你也可以使用Rust的trait对象，这允许你在不知道具体类型的情况下调用trait中的方法，但对于这种情况，要求方法必须在trait中定义为"必须实现"。

### 定义 trait

例如:
- 结构体 `NewsArticle` 用于存放发生于世界各地的新闻故事
- 而结构体 `Tweet` 最多只能存放 280 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。

我们想要创建一个名为 `aggregator` 的多媒体聚合库用来显示可能储存在 `NewsArticle` 或 `Tweet` 实例中的数据摘要。
为了实现功能，每个结构体都要能够获取摘要，这样的话就可以调用实例的 `summarize` 方法来请求摘要。

```rust
pub trait Summary {
    fn summarize(&self) -> String;
    fn delete(&self); // 无返回值的方法
}
```

> trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。

### 为类型实现 trait

```rs
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

// Tweet 上实现了Summary trait
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
```

在另一个crate中使用aggregator这个lib：
```rs
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```

> 实现 trait 时需要注意的一个限制是，只有当至少一个 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。-> 即这个crate里得用到一个Summary trait的实现

Note: 不能为外部类型实现外部 trait。
例如，不能在 aggregator crate 中为 Vec<T> 实现 Display trait。这是因为 Display 和 Vec<T> 都定义于标准库中，它们并不位于 aggregator crate 本地作用域中。
这个限制是被称为 相干性（coherence）的程序属性的一部分，或者更具体的说是 孤儿规则（orphan rule）, 没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。
> 简单来说，在哪个crate里定义trait, 就在哪个crate里实现这个trait

### 默认实现

```rs
pub trait Summary {
    // 在trait定义里完成默认实现
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

> 默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。

```rs
pub trait Summary {
    // 非默认实现
    fn summarize_author(&self) -> String;
    // 默认实现
    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}

impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```

### trait 作为参数

探索一下如何使用 trait 来接受多种不同类型的参数。
```rs
// trait Summary 作为arg
// 可以调用任何来自 Summary trait 的方法，比如 summarize。
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// 传递任何 NewsArticle 或 Tweet 的实例来调用 notify
fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    // Note： 要传入实例的引用
    notify(&tweet);
    notify(&article);

}
```

### 通过 `+` 指定多个 trait bound

同时实现两个不同的 trait:
如果 notify 需要显示 item 的格式化形式，同时也要使用 summarize 方法，那么 item 就需要同时实现两个不同的 trait：`Display` 和 `Summary`

```rs
pub fn notify(item: &(impl Summary + Display)) {
    println!("Breaking news: {}", item.summarize());
    println!("More details: {}", item);}

```

> `+` 语法也适用于泛型的 trait bound：

```rs
pub fn notify<T: Summary + Display>(item: &T) {
    println!("Summary: {}", item.summarize());
    println!("Display: {}", item);}

```

### 通过 where 简化 trait bound
```rust
// 使用：
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
    // 在这里，T 必须实现 Display 和 Clone 特质
    // U实现 Display 和 Debug 特质
}


// 使用where字句
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    // 在这里，T 必须实现 Display 和 Clone 特质
    // U实现 Display 和 Debug 特质
}


// 使用：
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

// 使用where字句
impl<T> Pair<T>
where
    T: Display + PartialOrd,
{
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

```

### 返回 实现了 trait 的类型
也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：
> 在闭包和迭代器场景十分的有用
>
> 不过这只适用于返回`单一类型`的情况; 例如，这段代码的返回值类型指定为返回 impl Summary，但是返回了 NewsArticle `或` Tweet 就行不通
```rs
// 使用 impl Summary 作为返回值类型
fn returns_summarizable() -> impl Summary {
    // 返回了一个 Tweet，不过调用方并不知情。
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```

### 使用 trait bound 有条件地实现方法
通过使用带有 trait bound 的泛型参数的 impl 块，可以有条件地只为那些实现了特定 trait 的类型实现方法。

```rs
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

// 为任何Pair<T>实现new方法
impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

// 仅为实现了 Display 和 PartialOrd 的 T 的 Pair<T> 实现 cmp_display 方法
impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

> 对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations，它们被广泛的用于 Rust 标准库中。
> 例如，标准库为任何实现了 Display trait 的类型实现了 ToString trait。

## 10.2 使用生命周期来确保引用有效

生命周期是另一类我们已经使用过的`泛型`。不同于确保类型有期望的行为，生命周期`确保引用如预期一直有效`。

### 生命周期避免了悬垂引用
悬垂引用（dangling references）会导致程序引用了非预期引用的数据。
```rs
fn main() {
    // 外部作用域声明了一个没有初值的变量 r
    let r;

    {
        let x = 5;
        // 内部作用域中，我们尝试将 r 的值设置为一个 x 的引用
        r = &x;
    }
    // 在内部作用域结束后，尝试打印出 r 的值
    println!("r: {}", r);
}
```
> 这段代码不能编译因为 r 引用的值在尝试使用之前就离开了作用域。如下是错误信息：`error[E0597]: `x` does not live long enough`
> 原因是 x 在到达第 7 行内部作用域结束时就离开了作用域
> 不过 r 在外部作用域仍是有效的；作用域越大我们就说它 “存在的越久”。

### 借用检查器
Rust 编译器有一个 借用检查器（borrow checker），`它比较作用域`来确保所有的借用都是有效的。

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```
r 和 x 的生命周期注解，分别叫做 'a 和 'b

> 程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：`被引用的对象比它的引用者存在的时间更短。`

### 函数中的泛型生命周期

```rs
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
上述代码不能编译，相应地会出现如下有关生命周期的错误：`missing lifetime specifier`

返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 x 或 y。

当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 if 还是 else 会被执行。也不知道传入的引用的具体生命周期

为了修复这个错误，我们将增加`泛型生命周期参数`来定义引用间的关系以便借用检查器可以进行分析。

### 生命周期注解语法
生命周期注解`并不改变`任何引用的生命周期的长短。

相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期

生命周期注解有着一个不太常见的语法：
- 生命周期参数名称必须以撇号`（'）`开头，其名称通常全是小写，类似于泛型其名称非常短。
- 大多数人使用 'a 作为第一个生命周期注解。
- 生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开。

```rs
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

> 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。
>
> 使用同一个生命周期注解的引用必须这泛型生命周期`存在得一样久`

### 函数签名中的生命周期注解

```rs
// 使用生命周期注解，需要在函数名和参数列表间的尖括号中声明泛型生命周期（lifetime）参数，就像泛型类型（type）参数一样。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
上述代码中 在每个引用中都加上了 'a ， 我们希望函数签名表达如下限制：
- 'a 表示这两个参数 x 和 y 以及返回值的生命周期应该是相同的。
- 当具体的引用被传递给 longest 时，被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相`重叠`的那一部分。换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。

> 记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出`任何不满足这个约束条件的值都将被借用检查器拒绝`。

> 如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。
> 如果不这么做的话，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码。


关于`泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。`， 考虑以下代码：

```rs
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");

        // string1 更长，因此 result 会包含指向 string1 的引用。
        result = longest(string1.as_str(), string2.as_str());
    }
    // 从人的角度，到这里，string1 尚未离开作用域，对于 println! 来说 string1 的引用仍然是有效的。
    // 然而，我们通过生命周期参数告诉 Rust 的是： longest 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致 -> string2
    // 因此，借用检查器不允许，因为它可能会存在无效的引用。
    println!("The longest string is {}", result);
}
```

### 深入理解生命周期

指定生命周期参数的正确方式依赖函数实现的具体功能。

当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。
如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是`它指向一个函数内部创建的值`。然而它将会是一个`悬垂引用`，因为它将会在函数结束时离开作用域。
```rs
// 即便我们为返回值指定了生命周期参数 'a, 却编译失败
// 因为返回值的生命周期与参数完全没有关联。
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```
> 指定生命周期参数并不能来改变是悬垂引用的现实
> 在这种情况，最好的解决方案是`返回一个有所有权的数据类型`(返回会移动所有权)而不是一个引用，这样函数调用者就需要负责清理这个值了。

```rs
fn give_ownership() -> String {
    let s = String::from("Hello");
    s
}

fn main() {
    let owned_string = give_ownership();
    // 此时，owned_string 拥有 "Hello" 字符串的所有权，而 give_ownership 函数不再拥有它
}
```
在上面的示例中，give_ownership 函数返回一个 String 类型，这意味着它将 String 的所有权转移到 main 函数中的 owned_string 变量，而 give_ownership 不再拥有这个 String。


### 结构体定义中的生命周期注解
目前为止，我们定义的结构体全都包含`拥有所有权的类型`

也可以定义`包含引用`的结构体，不过这需要为结构体定义中的`每一个引用添加生命周期注解`。

考虑以下示例，其中定义了一个结构体 MyStruct，包含三个不同生命周期注解的引用：
```rs
struct MyStruct<'a, 'b, 'c> {
    a: &'a str,
    b: &'b str,
    c: &'c str,
}
```

生命周期的具体关系取决于如何创建和使用结构体实例
- 例如，如果你创建一个 MyStruct 实例并使用具有相同生命周期的引用，那么结构体的生命周期将与这些引用的生命周期相同。
- 但是，如果你创建一个 MyStruct 实例，并使用具有不同生命周期的引用，那么结构体的生命周期将成为这些引用生命周期的"最短公共超类型"，或者更简单地说，结构体的生命周期将受到这三个生命周期的约束。
```rs
fn main() {
    let a_str = "a string";
    let b_str = "another string";
    let c_str = "yet another string";

    // my_struct_a 的生命周期受到 'a 的约束，即它不能超过a_str的生命周期。
    let my_struct_a: MyStruct = MyStruct {
        a: a_str,
    };

    // my_struct_a_b 的生命周期受到 'a, 'b, 的约束
    // 即它不能超过a_str, b_str中生命周期更短的那个的的生命周期。
    let my_struct_a_b: MyStruct = MyStruct {
        a: a_str,
        b: b_str,
    };

    // my_struct 的生命周期受到 'a, 'b, 'c 的约束
    // 即它不能超过这三个生命周期的最短公共超类型。
    let my_struct_a_b_c: MyStruct = MyStruct {
        a: a_str,
        b: b_str,
        c: c_str,
    };
}
```

### 生命周期省略（Lifetime Elision）

函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），
而返回值的生命周期被称为 输出生命周期（output lifetimes）。

编译器采用三条规则来判断引用何时不需要明确的注解: 第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。
- 第一条规则是编译器为`每一个引用参数都分配一个生命周期参数`。换句话说就是，函数有一个引用参数的就有一个生命周期参数：fn foo<'a>(x: &'a i32)，有两个引用参数的函数就有两个不同的生命周期参数，fn foo<'a, 'b>(x: &'a i32, y: &'b i32)，依此类推。
- 第二条规则是如果`只有一个输入生命周期参数`，那么`它被赋予所有输出生命周期参数`：fn foo<'a>(x: &'a i32) -> &'a i32。
- 第三条规则是如果方法有`多个输入生命周期参数`并且`其中一个参数是 &self 或 &mut self`，说明是个对象的方法 (method). 那么`所有输出生命周期参数被赋予 self 的生命周期`

审视下列省略了生命周期注解但可以编译的代码：
```rs
// 只有一个输入生命周期参数
// 根据规则1 -> fn first_word<'a>(s: &'a str) -> &str {
// 根据规则2 -> fn first_word<'a>(s: &'a str) -> &'a str {
// 已得到全部引用的生命周期
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

再看看另一个省略了生命周期注解但编译失败的代码：
```rs
// 根据规则1 -> fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
// 不满足规则2
// 不满足规则3
// 编译器使用所有已知的生命周期省略规则，仍不能计算出签名中所有引用(本例中的返回值)的生命周期。
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 方法定义中的生命周期注解

（实现方法时）结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。
```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}

// 'a 生命周期参数主要用于注解结构体 ImportantExcerpt 中的引用 part 的生命周期
impl<'a> ImportantExcerpt<'a> {
    // 唯一的参数是 self 的引用，而且返回值只是一个 i32，并不引用任何值：
    // 根据规则1我们并不必须标注 self 引用的生命周期。
    fn level(&self) -> i32 {
        3
    }

    // 根据规则1 -> 赋予 &self 和 announcement 它们各自的生命周期
    // 根据规则2 -> 因为其中一个参数是 &self，返回值类型被赋予了 &self 的生命周期
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```


### 静态生命周期
这里有一种特殊的生命周期值得讨论：`'static`，其生命周期能够`存活于整个程序期间`。

所有的`字符串字面值`都拥有 `'static` 生命周期，我们也可以选择像下面这样标注出来：

```rs
let s: &'static str = "I have a static lifetime.";
```

将引用指定为 'static 之前，思考一下这个引用`是否真的在整个程序的生命周期里都有效`，以及你是否希望它存在得这么久。

大部分情况中，推荐 'static 生命周期的错误信息都是尝试创建`一个悬垂引用`或者`可用的生命周期不匹配的结果`。

### 结合泛型类型参数、trait bounds 和生命周期
```rs
use std::fmt::Display;

// 返回两个字符串 slice 中较长者
fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    // ann 的类型是泛型 T
    // ann可以是任何实现了 Display trait 的类型
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

# 11. 编写自动化测试


为了将一个函数变成测试函数，需要在 fn 行之前加上 `#[test]`。
当使用 `cargo test` 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 test 属性的函数，并报告每一个测试是通过还是失败。

```rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

# 12. 一个 I/O 项目：构建一个命令行程序
我们的项目将创建一个我们自己版本的经典命令行工具：grep。
grep 是 “Globally search a Regular Expression and Print.” 的首字母缩写。
grep 最简单的使用场景是在特定文件中搜索指定字符串。
为此，grep 获取一个文件名和一个字符串作为参数，接着读取文件并找到其中包含字符串参数的行，然后打印出这些行。

## 11.2 读取文件

> 尝试运行这些代码：
> cargo run the src/poem.txt

加上src/, 不然路径有问题

## 11.3 重构改进模块性和错误处理

### 二进制项目的关注分离
保留在 main 函数中的责任应该被限制为：

- 使用参数值调用命令行解析逻辑
- 设置任何其他的配置
- 调用 lib.rs 中的 run 函数
- 如果 run 返回错误，则处理这个错误

这个模式的一切就是为了关注分离：
- main.rs 处理程序运行，
- 而 lib.rs 处理所有的真正的任务逻辑。


#### 使用 clone 的权衡取舍

```rs
fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
```
main 中的 args 变量是参数值的所有者并只允许 parse_config 函数借用他们，这意味着如果 Config 尝试获取 args 中值的所有权将违反 Rust 的借用规则。

还有许多不同的方式可以处理 String 的数据，而`最简单但有些不太高效`的方式是调用这些值的 clone 方法

> 由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 clone 来解决所有权问题。
> 在关于迭代器的第 13 章中，我们将会学习如何更有效率的处理这种情况，不过现在，复制一些字符串来取得进展是没有问题的，因为只会进行一次这样的拷贝，而且文件名和要搜索的字符串都比较短。在第一轮编写时拥有一个可以工作但有点低效的程序要比尝试过度优化代码更好一些。随着你对 Rust 更加熟练，将能更轻松的直奔合适的方法，不过现在调用 clone 是完全可以接受的。


unwrap_or_else ?

用Result配合process.exit()替代panic的处理：类似于示例 12-8 中使用的基于 panic! 的错误处理，除了不会再得到所有的额外输出了。


Result<(), Box<dyn Error>> ?

## 12.4 采用测试驱动开发完善库的功能

- #[cfg(test)]
- #[test]
- assert_eq!()
- Vec的push和insert
- Vec::new() 和 vec![]

Vec 是 Rust 标准库中的动态数组类型，insert 和 push 是 Vec 上的两个不同的方法，它们有以下区别：

push 方法：
- push 方法用于在 Vec 的末尾添加一个元素。
- 这是一个非常高效的操作，因为它只需要在 Vec 的末尾追加一个元素，并且不会涉及移动或复制其他元素。
- push 只需要一个参数，即要添加的元素。

```rs
let mut v = Vec::new();
v.push(1); // 在 Vec 的末尾添加元素 1
v.push(2); // 在 Vec 的末尾添加元素 2
```

insert 方法：
- insert 方法用于在 Vec 中的指定位置插入一个元素。
- 这可能会导致在插入点之后的元素需要移动以腾出空间，因此插入操作可能会比 push 更昂贵。
- insert 需要两个参数，第一个是要插入的位置的索引，第二个是要插入的元素。

```rs
let mut v = vec![1, 2, 3];
v.insert(1, 4); // 在索引 1 处插入元素 4，Vec 变为 [1, 4, 2, 3]
```

## 12.5 处理环境变量

`CASE_INSENSITIVE=1 cargo run to poem.txt`

## 12.6 将错误信息输出到标准错误而不是标准输出
大部分终端都提供了两种输出：
- 标准输出（standard output，stdout）对应一般信息，
- 标准错误（standard error，stderr）则用于错误信息。

这种区别允许用户选择将程序正常输出定向到一个文件中并仍将错误信息打印到屏幕上。
但是 println! 函数`只能够打印到标准输出`，所以我们必须使用其他方法来打印到标准错误。

### 检查错误应该写入何处
> cargo run > output.txt

语法告诉 shell 将标准输出的内容写入到 output.txt 文件中而不是屏幕上。

### 将错误打印到标准错误
使用 eprintln! 将错误信息写入标准错误而不是标准输出
配合`cargo run > output.txt`， 正常输出会被写入output.txt，而错误信息会打印在终端

# 13. Rust 中的函数式语言功能：迭代器与闭包

## 13.1 闭包：可以捕获环境的匿名函数

Rust 的 闭包（closures）是匿名函数, 可以保存进变量或作为参数传递给其他函数。

可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算

闭包允许捕获`调用者作用域中的值`

### 使用闭包创建行为的抽象

考虑一下这个假定的场景：
- 我们需要一个可以生成自定义健身计划的 app
- 生成健身计划的算法需要考虑很多不同的因素，比如用户的年龄、身体质量指数（Body Mass Index）、用户喜好、最近的健身活动和用户指定的强度系数
- 本例中实际的算法并不重要，重要的是`这个计算将会花费几秒钟`。我们只希望在需要时调用算法，并且只希望调用一次，这样就不会让用户等得太久。
- 通过调用 `simulated_expensive_calculation` 函数来模拟调用假定的算法: 它会打印出 calculating slowly...，等待两秒，并接着返回传递给它的数字。


`thread::sleep(Duration::from_secs(2))`


main 函数中将会包含本例的健身 app 中的重要部分。
这代表当用户请求健身计划时 app 会调用的代码。
因为与 app 前端的交互与闭包的使用并不相关，所以我们将硬编码代表程序输入的值并打印输出。

所需的输入有这些：
- 一个来自用户的 intensity 数字，请求健身计划时指定，它代表用户喜好低强度还是高强度健身。
- 一个随机数，其会在健身计划中生成变化。

程序的输出将会是建议的锻炼计划

- {}：这是默认的占位符，用于格式化实现了 Display trait 的类型。
- {:?}：这个占位符用于格式化实现了 Debug trait 的类型，通常用于调试目的。
- {:#?}：类似于 {:?}，但生成更漂亮的格式化输出，通常用于结构体和其他复杂类型。


### 闭包类型推断和标注
闭包不要求像 fn 函数那样在参数和返回值上注明类型。
函数中需要类型标注是因为他们是暴露给用户的显式接口的一部分。严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的。
`但是闭包并不用于这样暴露在外的接口`：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。

闭包通常很短，并只关联于小范围的上下文而非任意情境。
在这些有限制的上下文中，编译器能可靠的推断参数和返回值的类型，类似于它是如何能够推断大部分变量的类型一样。

### 使用带有泛型和 Fn trait 的闭包
在示例 13-6 中的代码仍然把慢计算闭包调用了比所需更多的次数。
解决这个问题的一个方法:
- 可以创建一个存放闭包和调用闭包结果的结构体。
- 该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。
- 你可能见过这种模式被称 `memoization` 或 `lazy evaluation （惰性求值）。`

`所有的闭包都实现了 trait Fn、FnMut 或 FnOnce 中的一个`

`结构体 Cacher` 有一个泛型 T 的字段 calculation。
T 的 trait bound 指定了 T 是一个使用 Fn 的闭包。
任何我们希望储存到 Cacher 实例的 calculation 字段的闭包必须有一个 u32 参数（由 Fn 之后的括号的内容指定）并必须返回一个 u32（由 -> 之后的内容）。

### Cacher 实现的限制
值缓存是一种更加广泛的实用行为，我们可能希望在代码中的其他闭包中也使用他们。

然而，目前 Cacher 的实现存在两个小问题，这使得在不同上下文中复用变得很困难:
- 第一个问题是 Cacher 实例假设对于 value 方法的任何 arg 参数值总是会返回相同的值。
- 第二个问题是它的应用被限制为只接受获取一个 u32 值并返回一个 u32 值的闭包。比如说，我们可能需要能够缓存一个获取字符串 slice 并返回 usize 值的闭包的结果。请尝试引入更多泛型参数来增加 Cacher 功能的灵活性。

### 闭包会捕获其环境
在健身计划生成器的例子中，我们只将闭包作为`内联匿名函数`来使用。
不过闭包还有另一个函数所没有的功能：`他们可以捕获其环境并访问其被定义的作用域的变量。`

```rs
fn main() {
    let x = 4;

    // closure从环境捕获了x， 闭包会在闭包体中储存这个值以供使用
    let equal_to_x = |z| z == x;

    let y = 4;
    // 即便 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域。
    assert!(equal_to_x(y));
}
```

当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用。这会使用内存并产生额外的开销，在更一般的场景中，当我们不需要闭包来捕获环境时，我们不希望产生这些开销。

闭包可以`通过三种方式捕获其环境`，他们直接对应函数的三种获取参数的方式：
- 获取所有权，
- 可变借用
- 不可变借用。

这三种捕获值的方式被编码为如下三个 Fn trait：
- FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。
- FnMut 获取可变的借用值所以可以改变其环境
- Fn 从其环境获取不可变的借用值


当创建一个闭包时，`Rust 根据其如何使用环境中变量来推断`我们希望如何引用环境。
- 由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce 。
- 没有移动被捕获变量的所有权到闭包内的闭包也实现了 FnMut
- 不需要对被捕获的变量进行可变访问的闭包则也实现了 Fn

#### move
如果你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 move 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。
```rs
fn main() {
    let x = vec![1, 2, 3];

    // x 被移动进了闭包
    let equal_to_x = move |z| z == x;

    // 闭包获取了 x 的所有权，同时 main 就不再允许在 println! 语句中使用 x 了
    // 去掉 println! 即可修复问题。
    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```

## 13.2 使用迭代器处理元素序列

### 创建

iter 方法生成一个`不可变引用的迭代器`
如果我们需要一个获取 v1 所有权并返回拥有所有权的迭代器，则可以调用 `into_iter` 而不是 iter
如果我们希望迭代可变引用，则可以调用 `iter_mut` 而不是 iter。

`iter()`: 返回一个不可变的迭代器，用于对集合进行只读遍历。这意味着你可以访问集合的元素，但不能修改它们。这是一种安全的方式，因为它不允许修改集合中的内容。
```rs
let vec = vec![1, 2, 3];
for item in vec.iter() {
    println!("{}", item);
}
```

`into_iter()`: 是一个`消耗性`的迭代器，它将集合的所有权转移给迭代器。这意味着一旦你使用了into_iter()，集合将不再可用，因为它的所有权已经被转移。这对于你需要在迭代期间获取集合中的每个元素并不再需要集合本身时非常有用。
```rs
let vec = vec![1, 2, 3];
for item in vec.into_iter() {
    println!("{}", item);
}
// 这里 vec 不再可用
```

`iter_mut()`: 返回一个可变的迭代器，允许你以可变的方式访问集合的元素。这允许你修改集合中的元素。这对于需要在迭代期间修改集合内容的情况非常有用。
```rs
let mut vec = vec![1, 2, 3];
for item in vec.iter_mut() {
    *item += 1;
}
```


### Iterator trait 和 next 方法
迭代器都实现了一个叫做 `Iterator` 的定义于标准库的 trait。·
```rs
pub trait Iterator {
    // Item 类型将是迭代器返回元素的类型。
    type Item;

    // next 一次返回迭代器中的一个项，封装在 Some 中，
    // 当迭代器结束时，它返回 None。
    fn next(&mut self) -> Option<Self::Item>;

    // 此处省略了方法的默认实现
}
```

next 调用中得到的值是 vector 的`不可变引用`, 

### 消费迭代器的方法
`Iterator trait` 有一系列不同的由标准库提供默认实现的方法, 一些方法在其定义中调用了 next 方法，这就是为什么在实现 Iterator trait 时要求实现 next 方法。

这些调用 next 方法的方法被称为 `消费适配器（consuming adaptors`,因为调用他们会消耗迭代器。

### 产生其他迭代器的方法
允许我们将当前迭代器变为不同类型的迭代器
可以`链式调用`多个迭代器适配器
不过因为所有的迭代器都是`惰性`的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。

### 使用闭包获取环境
让我们展示一个通过使用 `filter` 迭代器适配器和捕获环境的闭包的常规用例。

迭代器的 filter 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。
- 如果闭包返回 true，其值将会包含在 filter 提供的新迭代器中。
- 如果闭包返回 false，其值不会包含在结果迭代器中

### 实现 Iterator trait 来创建自定义迭代器
我们已经展示了可以通过在 vector 上调用 iter、into_iter 或 iter_mut 来创建一个迭代器。
也可以用标准库中其他的集合类型创建迭代器，比如哈希 map。

另外，可以实现 Iterator trait 来创建任何我们希望的迭代器： 定义中唯一要求提供的方法就是 next 方法。一旦定义了它，就可以使用所有其他由 Iterator trait 提供的拥有默认实现的方法来创建自定义迭代器了！

`zip()`:
将两个或多个可迭代对象（如数组、列表、迭代器等）合并成一个元组的操作，其中每个元组包含来自各个可迭代对象的相同索引位置的元素。
```rs
fn main() {
    let numbers = vec![1, 2, 3];
    let words = vec!["one", "two", "three"];

    let zipped: Vec<(&i32, &&str)> = numbers.iter()
                                            .zip(words.iter())
                                            .collect();

    for (num, word) in zipped {
        println!("Number: {}, Word: {}", num, word);
    }
}

// Output
Number: 1, Word: "one"
Number: 2, Word: "two"
Number: 3, Word: "three"
```

## 13.3 改进 I/O 项目

### 使用迭代器并去掉 new 中的 clone

> rust不支持函数重载

`env::args` 函数返回一个迭代器

### 使用迭代器适配器来使代码更简明
优化search函数中的中间vec：results

函数式编程风格倾向于`最小化可变状态的数量`来使代码更简洁。
去掉可变状态可能会使得将来进行并行搜索的增强变得更容易，因为我们不必管理 results vector 的并发访问。

### 性能对比：循环 VS 迭代器
这里所要表达的是：迭代器，作为一个高级的抽象，被编译成了与手写的底层代码大体一致性能代码。

迭代器是 Rust 的 零成本抽象（zero-cost abstractions）之一，它意味着抽象并不会引入运行时开销，它与本贾尼·斯特劳斯特卢普（C++ 的设计和实现者）在 “Foundations of C++”（2012） 中所定义的 零开销（zero-overhead）如出一辙：
> In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.


# 14. 进一步认识 Cargo 和 Crates.io -todo

# 15. 智能指针

指针 （pointer）是一个包含内存地址的变量的通用概念。这个地址引用，或 “指向”（points at）一些其他数据。引用以 & 符号为标志并借用了它们所指向的值。

另一方面，`智能指针（smart pointers）是一类数据结构`，它们的表现类似指针，但是也拥有额外的元数据和功能。

在 Rust 中，普通引用和智能指针的一个额外的区别是:
- `引用`是一类`只借用数据`的指针；
- 相反，在大部分情况下，`智能指针` `拥有 它们指向的数据`。

String 和 Vec<T> ... 这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们

智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 `Deref` 和 `Drop` trait:
- `Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码。
- `Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。

本章将会讲到的是来自标准库中最常用的一些智能指针：
- `Box<T>`，用于在堆上分配值
- `Rc<T>`，一个引用计数类型，其数据可以有多个所有者
- `Ref<T>` 和 `RefMut<T>`，通过 RefCell<T> 访问（ RefCell<T> 是一个在运行时而不是在编译时执行借用规则的类型）


另外我们会涉及 `内部可变性（interior mutability）`模式，这是`不可变类型暴露出改变其内部值`的 API。

我们也会讨论 `引用循环（reference cycles）`会如何泄漏内存，以及如何避免。


## 15.1 使用 Box<T> 指向堆上的数据
box 允许你将一个值放在`堆上`而不是栈上。留在栈上的则是指向堆数据的指针。

多用于如下场景：
- 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
- 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
- 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候

```rs
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

我们可以像数据是储存在栈上的那样访问 box 中的数据。
正如任何拥有数据所有权的值那样，当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。

### Box 允许创建递归类型
将一个单独的值存放在堆上并不是很有意义. 让我们看看一个不使用 box 时无法定义的类型的例子:

Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 `递归类型（recursive type）`，其值的一部分可以是相同类型的另一个值。-> 这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。

让我们探索一下 cons list，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念:
> cons list 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，cons 函数（“construct function" 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。

cons 函数的概念涉及到更常见的函数式编程术语；
“将 x 与 y 连接” 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。

cons list 的每一项都包含两个元素：`当前项的值和下一项`。其最后一项值包含一个叫做 Nil 的值且没有下一项。
cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止

> 在栈上分配空间时我们总是需要告诉编译器准确的空间需求，如果做不到那就应该在堆上分配，再把对应的地址存在栈上，因为指针的大小总是已知的

Box<T> 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box<T> 值被当作引用对待。
当 Box<T> 值离开作用域时，由于 Box<T> 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。

## 15.2 通过 Deref trait 将智能指针当作常规引用处理

实现 Deref trait 允许我们重载 `解引用运算符（dereference operator）*`。
通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。

### 通过解引用运算符追踪指针的值
```rs
// Same with Cpp
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```


### 像引用一样使用 Box<T>

```rs
// Deref box instance as normal ref
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, *y);
}
```

### 自定义智能指针
```rs
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```
如此定义的智能指针无法实现`解引用`: `error[E0614]: type `MyBox<{integer}>` cannot be dereferenced`


### 通过实现 Deref trait 将某类型像引用一样处理
Deref trait由标准库提供，要求实现名为 deref 的方法，其`借用 self` 并返回一个`内部数据的引用`。

```rs
// MyBox 结构体的目的是实现 Deref 特质，以使其可以被解引用成 T 类型。
impl<T> Deref for MyBox<T> {
    // 关联类型， 见c19
    type Target = T;
    // deref 方法返回一个引用，它通过 &self.0 返回了 MyBox 结构体内部的 T 类型字段。
    fn deref(&self) -> &T {
        // .0 是 Rust 中的索引操作符，用于获取结构体内部的字段。索引从0开始，所以.0表示获取结构体的第一个字段。
        &self.0
    }
}
```

> *y 时，Rust 事实上在底层运行了如下代码：: `*(y.deref())`

Rust 将 * 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了

#### 关联类型"（Associated Types）
是一种用于定义 trait 中的类型占位符的机制。它允许在 trait 中指定与 trait 方法相关联的类型，而不需要具体指定这些类型是什么，这增加了 trait 的灵活性和通用性。

关联类型通常在定义 trait 时使用，允许实现该 trait 的类型定义具体的关联类型，而无需在 trait 中提供确切的类型信息。

> 即为trait的不同实现预留 灵活 出参和入参类型

```rs
trait MyTrait {
    type AssociatedType; // 定义关联类型

    fn get_associated_value(&self) -> Self::AssociatedType;
}

struct MyStruct;

impl MyTrait for MyStruct {
    type AssociatedType = i32; // 为关联类型提供具体的类型

    fn get_associated_value(&self) -> Self::AssociatedType {
        42
    }
}

fn main() {
    let my_instance = MyStruct;
    let value: i32 = my_instance.get_associated_value();
    println!("Associated value: {}", value);
}
```

### 函数和方法的隐式解引用强制转换
解引用强制转换（deref coercions）是 Rust 在函数或方法传参上的一种便利。
解引用强制转换`只能工作在实现了 Deref trait 的类型上`。

解引用强制转换将一种类型（A）隐式转换为另外一种类型（B）的引用，因为 A 类型实现了 Deref trait，并且其关联类型是 B 类型。
比如，解引用强制转换可以将 &String 转换为 &str，因为类型 String 实现了 Deref trait 并且其关联类型是 str。

> 当我们将特定类型的值的引用作为参数传递给函数或方法，但是被传递的值的引用与函数或方法中定义的参数类型不匹配时，会发生解引用强制转换。

```rs
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    // m: &MyBox<String>
    let m = MyBox::new(String::from("Rust"));
    // 通过 deref 调用将 &MyBox<String> 变为 &String
    // 再次调用 deref 将 &String 变为 &str
    hello(&m);
}
```

如果 Rust 没有实现解引用强制转换, 为了使用 &MyBox<String> 类型的值调用 hello，则不得不编写:

```rs
fn main() {
    let m = MyBox::new(String::from("Rust"));
    // (*m) 将 MyBox<String> 解引用为 String
    // & -> &String
    // [..] 使用切片语法将 &String 转换为 &str -> &str
    hello(&(*m)[..]);
}
```

### 解引用强制转换如何与可变性交互
使用 `Deref` trait 重载`不可变引用`的 * 运算符。
对应地，Rust 提供了 `DerefMut` trait 用于重载`可变引用`的 * 运算符。

Rust 在发现类型和 trait 的实现满足以下三种情况时会进行解引用强制转换：
- 当 T: Deref<Target=U> ：从 &T 到 &U。
- 当 T: DerefMut<Target=U> ：从 &mut T 到 &mut U。
- 当 T: Deref<Target=U> ：从 &mut T 到 &U。

> 第三种情况有些微妙：Rust 也会将可变引用强转为不可变引用，但是反之是 不可能 的，因为不可变引用永远也不能强转为可变引用。

### 15.3 使用 Drop Trait 运行清理代码

第二个重要的 trait 是 `Drop` ，其允许我们`在值要离开作用域时`执行一些代码。
可以为任何类型提供 Drop trait 的实现，同时所指定的代码被`用于释放类似于文件或网络连接的资源`。

> 析构函数（destructor），这是一个清理实例的函数的通用编程概念.
> Rust 中的 `drop` 函数就是这么一个析构函数。

> 例如，Box<T> 自定义了 Drop 用来释放 box 所指向的堆空间。


`Drop trait` 要求实现一个叫做 `drop` 的方法，它获取一个 `self` 的可变引用: 

```rs
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    // 无返回值，入参为一个实例的可变引用
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers created.");
}

// OutPut: 
// CustomSmartPointers created.
// Dropping CustomSmartPointer with data `other stuff`!
// Dropping CustomSmartPointer with data `my stuff`!

// 变量以被创建时相反的顺序被丢弃，所以 d 在 c 之前被丢弃。
```

### 通过 std::mem::drop 提早丢弃值

有时你可能需要提早清理某个值而不是等到自然离开作用域调用drop：
一个例子是当使用智能指针管理锁时；你可能希望强制运行 drop 方法来释放锁以便作用域中的其他代码可以获取锁

> Rust 并不允许我们主动调用 Drop trait 的 drop 方法；
> 当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 `std::mem::drop`。

## 15.4 Rc<T> 引用计数智能指针
大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，`有些情况单个值可能会有多个所有者`

为了启用多所有权，Rust 有一个叫做 Rc<T> 的类型。其名称为 引用计数（reference counting）的缩写 `Rc` : 引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果`某个值有零个引用`，就代表没有任何有效引用并可以被清理。

### 使用 Rc<T> 共享数据
```rs
fn main() {
    let a = Cons(5, Box::new(
        Cons(10, Box::new(Nil))
        )
    );

    // 会报错：Cons 成员拥有其储存的数据，所以当创建 b 列表时，a 被移动进了 b 这样 b 就拥有了 a。
    // 接着当再次尝试使用 a 创建 c 时，这不被允许，因为 a 的所有权已经被移动。

    // let b = Cons(3, Box::new(a));
    // let c = Cons(4, Box::new(a));


    // 用Rc<T>改写Box<T>
    let a_rc = Rc::new( // 最外层多了一个Rc包裹， 也是b_rc和c_rc clone时用引用的原因
        List_rc::Cons(5, Rc::new(List_rc::Cons(10, Rc::new(List_rc::Nil))))
    );

    // 创建 b 和 c 时，调用 Rc::clone 函数并传递 a 中 Rc<List> 的引用作为参数。
    // Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。Rc::clone 只会增加引用计数，这并不会花费多少时间。
    let b_rc = List_rc::Cons(4, Rc::clone(&a_rc)); // Note: clone的是引用
    let c_rc = List_rc::Cons(3, Rc::clone(&a_rc));

}

enum List_rc {
    Cons(i32, Rc<List_rc>),
    Nil,
}
```


### 克隆 Rc<T> 会增加引用计数

Rc::clone 只会增加引用计数，这并不会花费多少时间
每次调用 clone，计数会增加1。当 引用变量 离开作用域时，计数减1

Rc::strong_count(&ref) 会打印出引用 &ref 的计数

使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。当引用计数为0，Rc<List> 被完全清理

> 通过不可变引用， Rc<T> 允许在程序的多个部分之间`只读地`共享数据。如果 Rc<T> 也允许多个可变引用，则会违反第 4 章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。