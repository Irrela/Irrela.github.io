---
title: Road Map
categories: Leetcode
tags:
- Leetcode
---

- [Coding Pattern: Two Pointers](#coding-pattern-two-pointers)
- [Coding Pattern: Sliding Window](#coding-pattern-sliding-window)
- [Coding Pattern: Intervals](#coding-pattern-intervals)
- [Coding Pattern: Linked List Manipulation](#coding-pattern-linked-list-manipulation)
- [Coding Pattern: Hash Maps](#coding-pattern-hash-maps)
- [Coding Pattern: Modified Binary Search](#coding-pattern-modified-binary-search)
- [Coding Pattern: Top K Elements](#coding-pattern-top-k-elements)
- [Coding Pattern: Heaps (Priority Queue)](#coding-pattern-heaps-priority-queue)
- [Coding Pattern: Two Heaps](#coding-pattern-two-heaps)
- [Coding Pattern: K-way Merge](#coding-pattern-k-way-merge)
- [Coding Pattern: Subsets](#coding-pattern-subsets)
- [Coding Pattern: Greedy](#coding-pattern-greedy)
- [Coding Pattern: Backtracking](#coding-pattern-backtracking)
- [Coding Pattern: DP](#coding-pattern-dp)
- [Coding Pattern: Cyclic Sort](#coding-pattern-cyclic-sort)
- [Coding Pattern: Topological Sort](#coding-pattern-topological-sort)
- [Coding Pattern: Stacks](#coding-pattern-stacks)
- [Coding Pattern: Breadth-First Search](#coding-pattern-breadth-first-search)
- [Coding Pattern: Depth-First Search](#coding-pattern-depth-first-search)
- [Coding Pattern: Recursion (-TODO)](#coding-pattern-recursion--todo)
- [Coding Pattern: Trie](#coding-pattern-trie)
- [Coding Pattern: Union Find](#coding-pattern-union-find)
- [Coding Pattern: Design](#coding-pattern-design)
- [Bonus: Data Structure + System Design](#bonus-data-structure--system-design)
- [Solution](#solution)
  - [Two Pointers](#two-pointers)
    - [Valid Palindrome](#valid-palindrome)
    - [680. Valid Palindrome II](#680-valid-palindrome-ii)
      - [Naive one based on Valid Palindrome I](#naive-one-based-on-valid-palindrome-i)
    - [Closest Sum](#closest-sum)
    - [3Sum](#3sum)
    - [Best Time to Buy and Sell Stock](#best-time-to-buy-and-sell-stock)
    - [209. Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
    - [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
    - [904. Fruit Into Baskets](#904-fruit-into-baskets)
      - [基于最长连续水果类型的解法](#基于最长连续水果类型的解法)
      - [基于sliding windows的解法（Recommended）](#基于sliding-windows的解法recommended)
    - [567. Permutation in String](#567-permutation-in-string)
    - [1493. Longest Subarray of 1's After Deleting One Element](#1493-longest-subarray-of-1s-after-deleting-one-element)
      - [手动记录zero\_idx](#手动记录zero_idx)
      - [不记录zero\_idx, 让left递增直到zero\_idx](#不记录zero_idx-让left递增直到zero_idx)


# Coding Pattern: Two Pointers

- [Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/)
- [Valid Palindrome II(Medium)](https://leetcode.com/problems/valid-palindrome-ii/)
- [Closest Sum(Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

- [3Sum(Medium)](https://leetcode.com/problems/3sum/)
- [Best Time to Buy and Sell Stock(Medium)(todo-no two pointer type)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

- [Trapping Rain Water(Hard)](https://leetcode.com/problems/trapping-rain-water/)

# Coding Pattern: Sliding Window

- [Longest Substring without Repeats(Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [Minimum Size Subarray Sum(Medium)](https://leetcode.com/problems/minimum-size-subarray-sum/)
- [Fruit into Baskets(Medium)](https://leetcode.com/problems/fruit-into-baskets/description/)
- [Permutation in String(Medium)](https://leetcode.com/problems/permutation-in-string/)
- [Longest Subarray with Ones after Replacement(Medium)](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

- Minimum Window Substring(Hard)

# Coding Pattern: Intervals
- Meeting Rooms I
- Interval List Intersections

- Insert Interval
- Merge Intervals

# Coding Pattern: Linked List Manipulation
- Swap Nodes in Pairs
- Palindrome Linked List

- Reverse Linked List II
- Rotate List
- Odd Even Linked List

- Reorder List

# Coding Pattern: Hash Maps
- Isomorphic Strings
- Word Pattern

- Group Anagrams
- Find All Anagrams in a String
- Longest Subarray with Sum Divisible by K

- Rate Limiter

# Coding Pattern: Modified Binary Search
- First Bad Version
- Maximum Count of Positives or Negatives 

- Search in Rotated Sorted Array
- Find Minimum in Rotated Sorted Array
- Find Peak Element

- Median of Two Sorted Arrays

# Coding Pattern: Top K Elements
- Kth Largest Element in a Stream
- Kth Largest Element in a Stream

- K Closest Points to Origin
- Top K Frequent Elements in a Stream
- Sliding Window Maximum

- Rearrange String k Distance Apart

# Coding Pattern: Heaps (Priority Queue)

- Meeting Rooms II (Hard)

# Coding Pattern: Two Heaps
- Find Kth Largest Element in a Stream
- Find Median of Two Sorted Arrays

- Kth Smallest Element in a Sorted Matrix
- Find Kth Smallest Pair Distance
- Find K Pairs with Smallest Sums

- Sliding Window Median

# Coding Pattern: K-way Merge 
- Top K Frequent Elements
- Merge Intervals

- Kth Smallest Number in Sorted Matrix
- Merge k Sorted Lists
- Smallest Number Range

- Super Ugly Number

# Coding Pattern: Subsets
- Subsets
- Letter Combinations of a Phone Number

- Subsets II
- Combination Sum
- Palindrome Partitioning

- Combination Sum II

# Coding Pattern: Greedy
- Assign Cookies
- Jump Game

- Queue Reconstruction by Height
- Jump Game II
- Non-overlapping Intervals (Intervals problem)

- Gas Station
- Meeting Rooms II

# Coding Pattern: Backtracking
- Generate Parentheses
- Letter Tile Possibilities

- Combination Sum
- Combination Sum II
- Word Search

- N-Queens

# Coding Pattern: DP
- Climbing Stairs
- Longest Increasing Subsequence

- Unique Paths
- Coin Change
- House Robber

- Edit Distance

# Coding Pattern: Cyclic Sort
- Find the Missing Number
- Set Mismatch

- Find All Numbers Disappeared in an Array
- First Missing Positive
- Find the Duplicate Number

- Find All Duplicates in an Array

# Coding Pattern: Topological Sort
- Course Schedule
- Alien Dictionary

- Course Schedule II
- Sequence Reconstruction
- Minimum Height Trees

- Course Schedule III

# Coding Pattern: Stacks
- Valid Parentheses
- Min Stack

- Evaluate Reverse Polish Notation
- Simplify Path
- Binary Tree Inorder Traversal

- Largest Rectangle in Histogram

# Coding Pattern: Breadth-First Search 
- Binary Tree Level Order Traversal  [Tree]
- Cousins in Binary Tree  [Tree]
- Number of Islands [Graph]
- Find if Path Exists in Graph [Graph]

- Binary Tree Zigzag Level Order Traversal  [Tree]
- Populating Next Right Pointers in Each Node [Tree]
- Word Ladder [Graph]
- Pacific Atlantic Water Flow [Graph]
- Number of Connected Components in an Undirected Graph [Graph]

- Serialize and Deserialize Binary Tree

# Coding Pattern: Depth-First Search 
- Maximum Depth of Binary Tree [Tree]
- Binary Tree Inorder Traversal [Tree]
- Course Schedule [Graph]

- Path Sum II [Tree]
- Symmetric Tree [Tree] 
- Binary Tree Right Side View [Tree]
- Invert Binary Tree [Tree]
- Clone Graph [Graph]

- Lowest Common Ancestor of a Binary Tree [Tree]

# Coding Pattern: Recursion (-TODO)

# Coding Pattern: Trie
- Design Add and Search Words Data Structure
- Word Search II

- Add and Search Words Data Structure
- Palindrome Pairs
- Design Search Autocomplete System

- Word Break II

# Coding Pattern: Union Find
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Coding Pattern: Design
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Bonus: Data Structure + System Design
- Design HashSet
- Min Stack

- Design LRU Cache
- Design Twitter
- Design a Parking Lot

- Design an Online Shopping System
- Design a Social Network


# Solution
## Two Pointers

### Valid Palindrome
```java
// Use built-in replaceAll
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase().replaceAll("[^a-zA-Z0-9]", "");

        int forward = 0;
        int backward = s.length() - 1;

        while (backward > forward) {
            if (s.charAt(forward) != s.charAt(backward)) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }
}
```

```java
// Self implemented support fns
class Solution {
    public boolean isPalindrome(String s) {
        char[] charArray = s.toCharArray();
        int forward = 0;
        int backward = charArray.length - 1;

        while (backward > forward) {
            // Skip non-alphanumeric characters from the beginning
            while (forward < charArray.length && !isAlphanumeric(charArray[forward])) {
                forward++;
            }
            
            // Skip non-alphanumeric characters from the end
            while (backward >= 0 && !isAlphanumeric(charArray[backward])) {
                backward--;
            }

            // Compare characters (case-insensitive)
            if (forward < charArray.length && backward >= 0 && toLowerCase(charArray[forward]) != toLowerCase(charArray[backward])) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }

    private boolean isAlphanumeric(char c) {
        return (c >= 'a' && c <= 'z') 
            || (c >= 'A' && c <= 'Z') 
            || (c >= '0' && c <= '9');
    }

    private char toLowerCase(char c) {
        if (c >= 'A' && c <= 'Z') {
            // Convert uppercase to lowercase by adding the ASCII offset
            return (char) (c + 'a' - 'A');
        }
        return c;
    }
}
```

### 680. Valid Palindrome II
#### Naive one based on Valid Palindrome I
```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            // Allow skip once.
            if (s.charAt(left) != s.charAt(right)) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }

        return true;
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

### Closest Sum
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int begin = 0;
        int end = numbers.length - 1;

        while (begin < end) {
            int sum = numbers[begin] + numbers[end];
            if (sum == target) {
                return new int[] {begin + 1, end + 1};
            }

            if (sum > target) {
                end--;
            } else {
                begin++;
            }
        }

        return null;
    }
}
```

```java
// BF
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=1;i<nums.length;i++)
        {
            for(int j=i;j<nums.length;j++)
            {
                if(nums[j-i]+nums[j]==target)
                {
                    return new int[]{j-i,j};
                }
            }
        }
        return null;
        
    
    }
}
```

```java
// HashMap
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];

            if (map.containsKey(complement)) {
                return new int[] {i, map.get(complement)};
            }

            map.put(nums[i], i);
        }

        return null;
    }
}
```

### 3Sum
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // Note: B-I sort 
        Arrays.sort(nums);
        List<List<Integer>> ret = new ArrayList<>();

        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            // Skip duplicates
            if (i > 0 && nums[i] == nums[i - 1]) { continue;}

            int begin = i + 1;
            int end = n - 1;
            // 如果是要求sum为value，这里可以做修改适配
            int target = -nums[i];

            while (begin < end) {
                int sum = nums[begin] + nums[end];
                if (sum == target) {
                    ret.add(Arrays.asList(nums[i], nums[begin], nums[end]));
                    // Skip duplicates
                    while (begin < end && nums[begin] == nums[begin + 1]) {
                        begin++;
                    }
                    while (begin < end && nums[end] == nums[end - 1]) {
                        end--;
                    }

                    begin++;
                    end--;
                } else if (sum < target) {
                    begin++;
                } else {
                    end--;
                }
            }
            
        }

        return ret;
    }
}

```

### Best Time to Buy and Sell Stock
> 用双指针 O(n^2) 太高。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        // 可以代表在i天卖出时可能得最大收益
        int curProfit = 0;

        for (int i = 1; i < prices.length; i++) {
            int interval = prices[i] - prices[i - 1];
            // 如果为负，说明i是一个低价，低到在其之前任何一天买入在i卖出都是亏的
            // 所以it's better to start over at i
            curProfit = Math.max(0, interval + curProfit);
            maxProfit = Math.max(curProfit, maxProfit);
        }

        return maxProfit;
    }
}
```


### 209. Minimum Size Subarray Sum
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int sum = 0;
        int minLength = Integer.MAX_VALUE;

        for (; right < nums.length; right++) {
            sum += nums[right];
            // 只有在sum大于等于过target时才记录minLength
            // 如果全程都没有大于等于过，需要最后将minLength处理为0
            boolean needUpdate = false;

            while (sum >= target) {
                sum -= nums[left];
                left++;
                needUpdate = true;
            }

            if (needUpdate) {
                minLength = Math.min(minLength, right - left + 2);
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```

### 3. Longest Substring Without Repeating Characters
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        int maxLength = 0;
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;

        for (int right = 0; right < len; right++) {
            char currentChar = s.charAt(right);
            
            // 如果当前子字符串中没有看到当前字符
            // 或者它出现在当前左指针之前，它是当前子字符串的一部分。
            if (map.getOrDefault(currentChar, -1) < left) {
                maxLength = Math.max(maxLength, right - left + 1);
            } else {
                // 如果该字符已被看到并且在当前子字符串中，
                // 将左指针更新到该字符最后一次出现后的位置。
                left = map.get(currentChar) + 1;
            }
            
            map.put(currentChar, right);
        }

        return maxLength;
    }
}
```


### 904. Fruit Into Baskets
> 内核: 找一个最长的仅有两种元素组成的子串

#### 基于最长连续水果类型的解法
```java
class Solution {
    public int totalFruit(int[] fruits) {
        int maxFruits = 0;           // Initialize the maximum number of fruits to be collected.
        int lastFruit = -1;          // Type of the last fruit in the second basket.
        int secondLastFruit = -1;    // Type of the last fruit in the first basket.
        int lastFruitCount = 0;      // Number of contiguous fruits of the last type.
        int currentMax = 0;          // Current maximum number of fruits.

        for (int fruit : fruits) {
            if (fruit == secondLastFruit || fruit == lastFruit) {
                // If the current fruit is the same as one of the fruits in the baskets, 
                // add it to the currentMax because it can be collected.
                currentMax++;
            } else {
                // If the current fruit is different from the fruits in the baskets,
                // we need to start collecting a new type of fruit. In this case, 
                // we consider the last fruit count plus the current fruit as the new 
                // maximum, and reset the currentMax.
                currentMax = lastFruitCount + 1;
            }

            if (fruit == lastFruit) {
                // If the current fruit is the same as the last fruit, increment the 
                // count of contiguous fruits of this type.
                lastFruitCount++;
            } else {
                // If the current fruit is different from the last fruit, it becomes 
                // the new last fruit, and we reset the last fruit count to 1.
                lastFruitCount = 1;
                secondLastFruit = lastFruit;
                lastFruit = fruit;
            }

            // Update the maximum number of fruits that can be collected.
            maxFruits = Math.max(maxFruits, currentMax);
        }

        return maxFruits;  // Return the maximum number of fruits that can be collected.
    }
}
```

#### 基于sliding windows的解法（Recommended）
```java
class Solution {
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> map = new HashMap<>();  // Create a HashMap to store fruit counts.
        int left = 0;  // Initialize the left pointer for the sliding window.
        int right = 0;  // Initialize the right pointer for the sliding window.
        int len = fruits.length;  // Get the length of the input array.
        int ret = 0;

        for (; right < len; right++) {
            map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1);

            // 从left端逐个移除fruit
            while (map.size() > 2) {
                // map中减少该水果数量
                map.put(fruits[left], map.get(fruits[left]) - 1);
                // 如果减少到0了，剔除该键值对
                // 说明当前篮子可以装入新的水果种类
                if (map.get(fruits[left]) == 0) {
                    map.remove(fruits[left]);
                }

                left++;
            }

            ret = Math.max(ret, right - left + 1);
        }

        return ret;
    }
}
```

### 567. Permutation in String
> 1. 用toCharArray代替charAt，提高速度
> 2. 只构建一次count_s2，然后每次循环用滑动窗口更新改数组


```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len_s1 = s1.length();
        int len_s2 = s2.length();

        char[] char_s1 = s1.toCharArray();
        char[] char_s2 = s2.toCharArray();
        
        if (len_s1 > len_s2) {
            return false;
        }

        int[] count_s1 = new int[26];
        int[] count_s2 = new int[26];
        
        // Initialize the count_s1 and the first window in s2
        for (int i = 0; i < len_s1; i++) {
            count_s1[char_s1[i] - 'a']++;
            count_s2[char_s2[i] - 'a']++;
        }
        
        // 优化后方案： 只构建一次count_s2，然后每次循环用滑动窗口更新改数组
        for (int i = 0; i < len_s2 - len_s1; i++) {
            if (isSameArr(count_s1, count_s2)) {
                return true;
            }

            // Key!!!
            // 滑动一格后将滑出的char数量--，滑进的char数量++即可
            count_s2[char_s2[i] - 'a']--;
            count_s2[char_s2[i + len_s1] - 'a']++;
        }
        
        // 被优化前的：每次循环都重新构建count_s2数组
        // for (int i = 0; i <= len_s2 - len_s1; i++) {
        //     int[] count_s2 = new int[26];
        //     for (int j = 0; j < len_s1; j++) {
        //         count_s2[char_s2[i+j] - 'a']++;
        //     }

        //     if (isSameArr(count_s1, count_s2)) {
        //         return true;
        //     }
        // }

        // Check the last window
        return isSameArr(count_s1, count_s2);
    }

    private boolean isSameArr(int[] arrA, int[] arrB) {
        for (int i = 0; i < arrA.length; i++) {
            if (arrA[i] != arrB[i]) {
                return false;
            }
        }

        return true;
    }
}
```

### 1493. Longest Subarray of 1's After Deleting One Element
#### 手动记录zero_idx
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        int left = 0;
        int right = 0;
        int zero_idx = 0;
        int zero_count = 0;
        int ret = 0;

        for (; right < len; right++) {
            if (nums[right] == 0) {
                if (zero_count > 0) {
                    left = zero_idx + 1;
                    zero_idx = right;
                } else {
                    zero_idx = right;
                    zero_count++;
                }
            }

            ret = Math.max(ret, right - left);
        }

        return ret;
    }
}
```
#### 不记录zero_idx, 让left递增直到zero_idx
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        int left = 0;
        int right = 0;
        int zero_count = 0;
        int ret = 0;

        for (; right < len; right++) {
            if (nums[right] == 0) {
                zero_count++;

                while (zero_count > 1) {
                    if (nums[left] == 0) {
                        zero_count--;
                    }
                    left++;
                }
            }

            ret = Math.max(ret, right - left);
        }

        return ret;

    }
}
```