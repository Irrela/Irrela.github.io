---
title: Rust Book
categories: Rust
tags:
- Rust
---

- [Warning and Error](#warning-and-error)
- [ShortCut](#shortcut)
- [1. Getting Started](#1-getting-started)
  - [1.1 First Program](#11-first-program)
  - [1.2 Cargo](#12-cargo)
    - [！！！Cargo 操作慢](#cargo-操作慢)
    - [使用 Cargo 创建项目](#使用-cargo-创建项目)
    - [Cargo.toml结构](#cargotoml结构)
    - [为没有使用Cargo的项目引入Cargo](#为没有使用cargo的项目引入cargo)
    - [Cargo构建与运行](#cargo构建与运行)
    - [发布（release）构建](#发布release构建)
  - [2. Guessing Game](#2-guessing-game)
    - [使用变量储存值](#使用变量储存值)
    - [静态方法](#静态方法)
    - [输入输出(std::io)](#输入输出stdio)
    - [使用 Result 类型来处理潜在的错误](#使用-result-类型来处理潜在的错误)
    - [使用 println! 占位符打印值](#使用-println-占位符打印值)
    - [使用crate](#使用crate)
    - [Cargo.lock 文件确保构建是可重现的](#cargolock-文件确保构建是可重现的)
    - [更新 crate 到一个新版本](#更新-crate-到一个新版本)
    - [使用rand生成一个随机数](#使用rand生成一个随机数)
    - [比较猜测的数字和秘密数字](#比较猜测的数字和秘密数字)
    - [静态强类型 \& 类型推断](#静态强类型--类型推断)
    - [使用循环来允许多次猜测](#使用循环来允许多次猜测)
    - [处理无效输入](#处理无效输入)
- [3. Common Programming Concepts](#3-common-programming-concepts)
  - [3.1 Variables and Mutability](#31-variables-and-mutability)
    - [可变性](#可变性)
    - [常量](#常量)
    - [隐藏](#隐藏)
  - [3.2 数据类型](#32-数据类型)
    - [标量类型](#标量类型)
      - [数值运算](#数值运算)
      - [字符类型](#字符类型)
    - [复合类型](#复合类型)
      - [元组类型](#元组类型)
      - [数组类型](#数组类型)
      - [访问数组元素](#访问数组元素)
  - [3.2 函数](#32-函数)
    - [](#)
    - [具有返回值的函数](#具有返回值的函数)
  - [3.4 注释](#34-注释)
  - [3.5 控制流](#35-控制流)
    - [if](#if)
    - [else if](#else-if)
    - [loop、while 和 for](#loopwhile-和-for)
      - [loop](#loop)
      - [循环标签：在多个循环之间消除歧义](#循环标签在多个循环之间消除歧义)
      - [while](#while)
      - [for](#for)
- [4. Understanding Ownership](#4-understanding-ownership)
  - [4.1 什么是所有权？](#41-什么是所有权)
    - [所有权规则](#所有权规则)
    - [变量作用域](#变量作用域)
    - [演示所有权的规则 - String 类型](#演示所有权的规则---string-类型)
    - [变量与数据交互的方式（一）：移动](#变量与数据交互的方式一移动)
    - [变量与数据交互的方式（二）：克隆](#变量与数据交互的方式二克隆)
      - [只在栈上的数据：拷贝](#只在栈上的数据拷贝)
      - [Trait: Copy](#trait-copy)
      - [所有权与函数](#所有权与函数)
      - [返回值与作用域](#返回值与作用域)
  - [4.2 引用与借用](#42-引用与借用)
      - [尝试修改借用的变量](#尝试修改借用的变量)
    - [可变引用](#可变引用)
    - [悬垂引用（Dangling References）](#悬垂引用dangling-references)
  - [4.3 Slice 类型](#43-slice-类型)
      - ['' 和 b''](#-和-b)
      - [\&str 和 String](#str-和-string)
    - [其他类型的 slice](#其他类型的-slice)
- [5. `Structs` to Structure Related Data](#5-structs-to-structure-related-data)
  - [5.1 结构体的定义和实例化](#51-结构体的定义和实例化)
      - [访问和修改属性](#访问和修改属性)
      - [Builder](#builder)
    - [使用`结构体更新`语法从其他实例创建实例](#使用结构体更新语法从其他实例创建实例)
    - [元组结构体（tuple structs）](#元组结构体tuple-structs)
    - [类单元结构体（unit-like structs）](#类单元结构体unit-like-structs)
  - [5.2 结构体示例程序](#52-结构体示例程序)
    - [通过派生 trait 增加实用功能](#通过派生-trait-增加实用功能)
    - [使用 dbg!](#使用-dbg)
  - [5.3 方法语法](#53-方法语法)
      - [getter](#getter)
      - [-\> 运算符到哪去了？](#--运算符到哪去了)
    - [带有更多参数的方法](#带有更多参数的方法)
    - [关联函数](#关联函数)
- [6. Enums and Pattern Matching](#6-enums-and-pattern-matching)
    - [Option 枚举和其相对于空值的优势](#option-枚举和其相对于空值的优势)
  - [6.2 match 控制流结构](#62-match-控制流结构)
    - [绑定值的模式](#绑定值的模式)
    - [匹配 Option](#匹配-option)


# Warning and Error

- Cargo更新下载慢
    换源, `/Users/<your user name>/.cargo` 下新建config文件：
    ```xml
    [source.crates-io]
    registry = "https://github.com/rust-lang/crates.io-index"

    replace-with = 'ustc'

    [source.ustc]
    registry = "git://mirrors.ustc.edu.cn/crates.io-index"
    ```

- `No Cargo projects are found`
    
    这个错误通常意味着CLion无法找到任何Cargo项目，因此它无法在您的Rust代码上运行Cargo命令。
    
    检错：
    1. 确保您位于正确的目录中：导航到Rust项目的根目录。这是包含Cargo.toml文件的目录。您应该从此目录运行货物命令。
    2. 初始化Rust项目：如果您不在包含Cargo.toml文件的目录中，则可以通过运行以下命令来初始化新的Rust项目：
    > `cargo new your_project_name`

    extra:
    使用rust rover新建项目之后第一次cargo check完成以前会报这个错。等初始化完成就好了



- `module declaration missing`

- 检查模块声明(Check Module Declarations)：验证您已经在Rust代码中声明了模块。在Rust中，使用mod关键字声明模块。例如：
    ```rust
    // In your main.rs or lib.rs file
    mod my_module;
    ```


# ShortCut

- `cmd + option + t`: 包裹代码块

# 1. Getting Started
## 1.1 First Program

编译：`rustc main.rs`

编译完成会生成可执行文件`main.exe`, 包含调试信息文件`main.pdb`

## 1.2 Cargo
`cargo --version` 查看版本

### ！！！Cargo 操作慢


### 使用 Cargo 创建项目

`cargo new hello_cargo` 默认会在 hello_cargo 目录初始化一个 git 仓库, 以及一个.gitignore 文件

如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 `cargo new --vcs=git` 来覆盖这些行为。

### Cargo.toml结构
```rust
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

`[dependencies]`，是罗列项目依赖的片段的开始。在 Rust 中，代码包被称为 `crates`。

Cargo 期望源文件存放在 src 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。

### 为没有使用Cargo的项目引入Cargo
要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建：

```rust
$ git clone example.org/some_project
$ cd some_project
$ cargo build
```

### Cargo构建与运行
1. `build`: 在根目录下运行 `cargo build`, 会创建一个可执行文件 `target/debug/hello_cargo`。
   - 由于默认的构建方法是`调试构建（debug build）`，Cargo 会将可执行文件放在名为 `debug` 的目录中。
   - 首次运行 `cargo build` 时，也会使 Cargo 在项目根目录创建一个新文件：`Cargo.lock`。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你自己永远也不需要碰这个文件，让 Cargo 处理它就行了。
2. `run`: 同时编译并运行生成的可执行文件。
   - Cargo 会检查源文件是否有修改，如果没有它就不用重新编译，而是直接运行了可执行文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目
3. `check`: 快速检查代码确保其可以编译，但并`不产生可执行文件`。
   - 通常 `cargo check` 要比 `cargo build` 快得多，因为它省略了生成可执行文件的步骤。
   - 如果你在编写代码时持续的进行检查，`cargo check` 可以让你快速了解现在的代码能不能正常通过编译！当准备好使用可执行文件时才运行 `cargo build`

### 发布（release）构建
当项目最终准备好发布时，可以使用 `cargo build --release` 来`优化`编译项目。这会在 `target/release` 而不是 `target/debug` 下生成可执行文件。

这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。

如果你在测试代码的运行时间，请确保运行 `cargo build --release` 并使用 target/release 下的可执行文件进行测试。


## 2. Guessing Game

默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 `预导入（preclude）` 内容。

如果你需要的类型不在预导入内容中，就必须使用 `use` 语句显式地将其引入作用域。

`std::io` 库提供很多有用的功能，包括接收用户输入的功能。

### 使用变量储存值
在 Rust 中，`变量默认是不可变的`，这意味着一旦我们给变量赋值，这个值就不再可以修改了。

在变量名前使用 `mut` 来使一个变量可变:
```rust
let apples = 5; // 不可变
let mut bananas = 5; // 可变
```

### 静态方法
```rust
let mut guess = String::new();
```
`:: `语法表明 `new` 是 `String` 类型的一个 `关联函数（associated function）`。

关联函数是针对类型实现的，在这个例子中是 String，而不是 String 的某个特定实例。一些语言中把它称为 `静态方法（static method）`。

### 输入输出(std::io)
```rust
    io::stdin()
        .read_line(&mut guess)
        .`expect`("Failed to read line");
```
- 如果程序的开头没有使用 use std::io; 引入 io 库，我们仍可以通过把函数调用写成 std::io::stdin 来使用函数。
- 调用 `read_line` 方法从标准输入句柄获取用户输入。将 `&mut guess` 作为参数传递给 `read_line()` 函数，让其将用户输入储存到这个字符串中。
- `read_line` 的工作是，无论用户在标准输入中键入什么内容，都将其`追加（不会覆盖其原有内容）`到一个字符串中，因此它需要字符串作为参数。
- `&` 表示这个参数是一个 `引用（reference）`，它允许多处代码访问同一处数据，而无需在内存中多次拷贝。


### 使用 Result 类型来处理潜在的错误

```rust
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
```
- `read_line` 会将用户输入附加到传递给它的字符串中，返回一个类型为 `Result` 的值
- `Result` 是一种枚举类型，通常也写作 `enum` 。枚举类型变量的值可以是`多种可能状态`中的一个。我们把每种可能的状态称为一种 `枚举成员（variant）`。
- `Result` 的成员是 `Ok` 和 `Err`:
  - `Ok` 成员表示操作成功，内部包含成功时产生的值。 
  - `Err` 成员则意味着操作失败，并且包含失败的前因后果。
- `Result` 的实例拥有 `expect` 方法。
  - 如果 `io::Result` 实例的值是 `Err` ， `expect` 会导致程序崩溃，并显示当做参数传递给 `expect` 的信息。
  - 如果 `Result` 实例的值是 `Ok`, `expect` 会获取 `Ok` 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。

### 使用 println! 占位符打印值

`{} `是预留在特定位置的占位符.

当打印变量的值时，`变量名可以写进大括号中`。当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。

```rust
let x = 5;
let y = 10;
println!("x = {x} and y + 2 = {}", y + 2);
```
这行代码会打印出` x = 5` and `y + 2 = 12`。

### 使用crate
`crate` 分为`库crate`和`二进制crate`：
  - 库crate 可以包含任意能被其他程序使用的代码，但是不能自执行
  - 二进制crate，如我们正在构建的项目，它生成一个可执行文件

Cargo 对外部 crate 的运用是其真正的亮点所在。在我们使用 rand 编写代码之前，需要修改 Cargo.toml 文件，引入一个 rand 依赖。
```toml
[dependencies]
rand = "0.8.5"
```
> 0.8.5 事实上是 `^0.8.5 `的简写，它表示任何至少是 0.8.5 但小于 0.9.0 的版本。


### Cargo.lock 文件确保构建是可重现的

Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。

Rust 在你第一次运行 `cargo build` 时建立了 Cargo.lock 文件, 当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本. 例如，如果下周 rand crate 的 0.8.6 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷, 多亏有了 Cargo.lock 文件, 项目会持续使用 0.8.5 直到你显式升级。


### 更新 crate 到一个新版本
`cargo update` 会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本. Cargo 接下来会把这些版本写入 Cargo.lock 文件。

不过，Cargo 默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果想要使用 0.9.0 版本的 rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.toml 文件：
```toml
[dependencies]

rand = "0.9.0"
```
下一次运行 `cargo build` 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。


### 使用rand生成一个随机数
```rust
use rand::Rng;
// ...
    let secret_number =
        rand::thread_rng()
            .gen_range(1..=100);
```
- `Rng` 是一个 `trait` ，它定义了随机数生成器应实现的方法
- `rand::thread_rng` 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed
- 接着调用随机数生成器的 `gen_range` 方法: 获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数:
  - 这里使用的这类范围表达式使用了 `start..=end` 这样的形式，也就是说包含了上下端点，所以需要指定 `1..=100` 来请求一个 1 和 100 之间的数。

> 你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法，因此每个 crate 有使用说明文档。
> Cargo 有一个很棒的功能是：运行 `cargo doc --open` 命令来构建所有本地依赖提供的文档，并在浏览器中打开。
> 例如，假设你对 rand crate 中的其他功能感兴趣，你可以运行 `cargo doc --open` 并点击左侧导航栏中的 rand。


### 比较猜测的数字和秘密数字
```rust
use std::cmp::Ordering;

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }

```
- `Ordering` 也是一个枚举，不过它的成员是 `Less` `、Greater` 和 `Equal` 。这是比较两个值时可能出现的三种结果。
- `cmp` 方法用来比较两个值, 并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 guess 与 secret_number 做比较。然后它会返回一个 `Ordering` 枚举的成员。
- `match` 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。


### 静态强类型 & 类型推断
Rust 有一个`静态强类型`系统，同时也有`类型推断`。

当我们写出 `let guess = String::new()` 时，Rust 推断出 `guess` 应该是 `String` 类型，并不需要我们写出类型。

另一方面，`secret_number`，是数字类型。Rust 默认使用 `i32` ，所以它是 secret_number 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。
> Rust的一些数字类型的值可以介于1和100之间：i32为 32位数字；u32为 无符号32位数字；i64为64位数字；以及其他

所以我们必须把从输入中读取到的 `String` 转换为一个真正的数字类型，才好与 `secret_number` 进行比较。

```rust
    let guess: u32 =
        guess.trim()
            .parse()
            .expect("Please type a number!");
```
这里创建了一个叫做 guess 的变量。不过等等，不是已经有了一个叫做 guess 的变量了吗？确实如此，不过 Rust 允许用一个新值来 `隐藏 （Shadowing）` guess 之前的值。这个功能常用在需要`转换值类型`之类的场景。它允许我们`复用 guess` 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。

- String 实例的 `trim` 方法会去除字符串开头和结尾的空白字符. 
  - 用户必须输入 `enter` 键才能让 read_line 返回并输入他们的猜想，这将会在字符串中增加一个`换行（newline）符`。
  - 例如，用户输入 5 并按下 enter（在 Windows 上，按下 enter 键会得到一个回车符和一个换行符，`\r\n`），guess 看起来像这样：5\n 或者 5\r\n。
  - \n 代表 “换行”; \r 代表 “回车”
  - trim 方法会消除 \n 或者 \r\n，只留下 5。


String 实例的 `parse` 方法 将字符串转换成其他类型。
  - 这里用它来把字符串转换为数值。
  - 我们需要告诉 Rust 具体的数字类型，guess 后面的冒号 `:` 指定了变量的类型 `u32`
  - `parse` 方法只有在 String 逻辑上可以转换为数字的时候才能工作, 所以非常容易出错。因此，`parse` 方法返回一个 `Result` 类型。如果 `parse` 不能从字符串生成一个数字，返回一个 `Err` 成员


### 使用循环来允许多次猜测

`loop` 关键字创建了一个无限循环。我们会增加循环来给用户更多机会猜数字：

```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
```

我们想要当猜测正确的数字时游戏停止, 增加一个 `break` 语句:
```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
```

退出循环也意味着退出程序，因为循环是 main 的最后一部分。

### 处理无效输入
```rust
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
```
- 我们将 `expect` 调用换成 `match` 语句，以从遇到错误就崩溃转换为处理错误.
- `Err(_)` 模式：`_` 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息
- break, continue必须处于loop中


# 3. Common Programming Concepts
## 3.1 Variables and Mutability
### 可变性
Rust变量默认是不可改变的（immutable）: 当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。 否则就会报错
Error: `cannot assign twice to immutable variable`

不过`可变性`也是非常有用的，尽管变量默认是不可变的，你仍然可以在变量名前添加 `mut` 来使其可变

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
通过 `mut` ，允许把绑定到 x 的值从 5 改成 6。

### 常量
类似于不可变变量，`常量 (constants)` 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别：
- 不允许对常量使用 `mut`, 常量不光默认不可变，它总是不可变。
- 声明常量使用 `const` 关键字而不是 let，并且 `必须 注明值的类型`。
- 常量可以在任何作用域中声明，包括`全局作用域`，这在一个值需要被很多部分的代码用到时很有用。
- 常量只能被设置为`常量表达式`，而`不可以是`其他任何`只能在运行时计算出的值`。
- Rust 对常量的`命名约定`是在单词之间使用全大写加下划线
  
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

> 在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。
>
> 将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。

### 隐藏
我们可以定义一个与之前变量同名的新变量。实际上，第二个变量“遮蔽”了第一个变量， 此时任何使用该变量名的行为，编译器将其视为是在使用第二个变量，直到第二个变量自己也被隐藏或第二个变量的作用域结束。

可以用相同变量名称来隐藏一个变量，以及`重复使用 let 关键字来多次隐藏`，如下所示：
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

// The value of x in the inner scope is: 12
// The value of x is: 6
```

`隐藏`与将变量标记为 `mut` 是有区别的: 
- 当不小心尝试对变量重新赋值时，如果没有使用 `let` 关键字，就会导致编译时错误。
- 通过使用 `let` ，我们可以用这个值进行一些计算，不过计算完之后变量仍然是`不可变`的。
- 当再次使用 `let` 时，实际上创建了一个`新变量`，我们可以改变值的`类型`，并且复用这个名字。
    ```rust
        let spaces = "   "; // 字符串类型
        let spaces = spaces.len(); // 数字类型
    ```


## 3.2 数据类型

Rust 是 `静态类型（statically typed）`语言，也就是说在`编译时`就必须知道所有变量的类型。

根据值及其使用方式，编译器通常可以`推断`出我们想要用的类型。
当多种类型均有可能时，必须增加`类型注解`:
```rust
let guess: u32 = "42".parse().expect("Not a number!"); // 类型注解 : u32
```
> 缺乏类型注解报错
> error[E0282]: type annotations needed 


### 标量类型

`标量（scalar）`类型代表一个单独的值。Rust 有四种基本的标量类型：
- 整型
- 浮点型
- 布尔类型
- 字符类型

#### 数值运算
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 结果为 -1

    // remainder
    let remainder = 43 % 5;
}
```
> `整数除法`会向`零舍入到最接近的整数`。


#### 字符类型
Rust 的 `char` 类型是语言中最原生的字母类型
```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```
- 用单引号声明 `char` 字面量. `char` 类型的大小为四个字节 (four bytes)
- 使用双引号声明 `字符串字面量(String Literals)`， 其数据类型为`&str`

### 复合类型
`复合类型（Compound types）`可以将多个值组合成一个类型。Rust 有`两个原生的复合类型`：
- 元组（tuple）
- 数组（array）

#### 元组类型

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组`长度固定`：一旦声明，其长度不会增大或缩小。

```rust
fn main() {
    let tup = (500, 6.4, 1);
    // let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (x, y, z) = tup; // 模式匹配（pattern matching）来解构（destructure）元组值

    println!("The value of y is: {y}");

    // 我们也可以使用点号（.）后跟值的索引来直接访问它们。
    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
访问元组元素：
- 模式匹配（pattern matching）来解构（destructure）元组值
- 使用`点号（.）`后跟值的索引来直接访问它们。

#### 数组类型

另一个包含多个值的方式是 数组（array）: 
- 数组中的`每个元素的类型必须相同`。
- 数组`长度是固定`的。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // 在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组
    // let a = [3, 3, 3, 3, 3]; 效果相同
    let a = [3; 5];

}

```

#### 访问数组元素
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 索引访问
    let first = a[0];
    let second = a[1];
}
```
> 访问越界: 如果我们访问数组结尾之后的元素时，导致 `运行时 错误(panic)`。程序带着错误信息退出


## 3.2 函数

函数拥有 `参数（parameters）（形参）`的函数，参数是特殊变量，是函数签名的一部分
为这些参数提供具体的`值（实参）`。技术上讲，这些具体值被称为参数（arguments），


在函数签名中，`必须声明每个参数的类型`。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。

### 

`语句（Statements）`是执行一些操作但不返回值的指令:
- `let y = 6;` 是一个语句。
- `语句`不返回值。因此，不能把 let 语句赋值给另一个变量

`表达式（Expressions）`计算并产生一个值:
- 语句 `let y = 6; `中的 `6` 是一个表达式
- 用大括号创建的一个新的块作用域也是一个表达式，例如：
   ```rust
   let y = {
        let x = 3;

        // 注意 x+1 这一行在结尾没有分号，与你见过的大部分代码行不同。
        // 如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值
        x + 1 
    };
   ```
   y的值是 4



### 具有返回值的函数

在 Rust 中，函数的返回值等同于函数体`最后一个表达式`的值。
```rust
fn five() -> i32 {
    5
}
```

使用 `return` 关键字和指定值，可从函数中提前返回

> 用最后一个表达式返回值时不要加`分号`


## 3.4 注释

用双斜杠` // `注释 Rust 代码

文档注释使用三斜杠 `///` 而以支持 Markdown 注解来格式化文本。
```rust 
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```


## 3.5 控制流

### if

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
> 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是`显式地使用布尔值`作为 if 的条件。


### else if
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }

    // 在 let 语句中使用 if
    let number = if condition { 5 } else { 6 };
}
```
> 使用过多的 else if 表达式会使代码显得杂乱无章，所以如果有多于一个 else if 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 `match`。


### loop、while 和 for
#### loop
```rust
// loop
fn main() {
    let mut counter = 0;
    
    // 赋值给 result 
    let result = loop {
        counter += 1;

        if counter == 10 {
            // 使用 break 关键字返回值 counter * 2
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
#### 循环标签：在多个循环之间消除歧义
如果存在嵌套循环，break 和 continue 应用于此时`最内层的循环`。
你可以选择在一个循环上指定一个 `循环标签（loop label）`，然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。

```rust
// loop
fn main() {
    let mut count = 0;

    // 标签 counting_up
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```


#### while
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```


#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }

    // 使用 for 循环来倒计时
    // rev，用来反转 range
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

# 4. Understanding Ownership
所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全.

## 4.1 什么是所有权？
> Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

在像 Rust 这样的系统编程语言中，`值是位于栈上还是堆上`在更大程度上影响了语言的行为以及为何必须做出这样的抉择。

栈中的所有数据都必须占用已知且固定的大小。

大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。

入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间. 其位置总是在栈顶

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。

> 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。


### 所有权规则
- Rust 中的每一个值都有一个 所有者（owner）。
- 值在任一时刻有且只有一个所有者。
- 当所有者（变量）离开作用域，这个值将被丢弃。


### 变量作用域
```rust
    {                      // s 在这里无效，它尚未声明
        let s = "hello";   // 从此处起，s 是有效的

        // 使用 s
    }                      // 此作用域已结束，s 不再有效
```


### 演示所有权的规则 - String 类型

我们已经见过`字符串字面值(String literals)`，即被硬编码进程序里的字符串值。 字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。
- 原因之一就是`它们是不可变的`。
- 另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？

> 为此，Rust 有第二个字符串类型，`String`。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。

```rust
    // 使用 from 函数基于字符串字面值来创建 String
    let mut s = String::from("hello");

    // String 可以修改
    s.push_str(", world!"); // push_str() 在字符串后追加字面值

    println!("{}", s); // 将打印 `hello, world!`
```

对于 `String` 类型，为了支持一个`可变，可增长`的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
- 必须在`运行时`向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将不再使用的内存返还给分配器的方法。

> Rust 采取了一个不同的策略：内存在`拥有它的变量离开作用域后`就被自动释放。

当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop` ，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的` } `处自动调用 `drop` 。


### 变量与数据交互的方式（一）：移动

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```
指针s1和s2同时指向同一块内存，是 `浅拷贝`。
这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 `二次释放（double free）`的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

为了确保内存安全，在 let s2 = s1; 之后，Rust `认为 s1 不再有效`，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

因而在 s2 被创建之后尝试使用 s1 会发生：`error[E0382]: borrow of moved value: s1`

> 如果你在其他语言中听说过术语 `浅拷贝（shallow copy）`和 `深拷贝（deep copy）`，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。`不过因为 Rust 同时使第一个变量无效了`，这个操作被称为 `移动（move）`，而不是叫做浅拷贝。

> 这里还隐含了一个设计选择：`Rust 永远也不会自动创建数据的 “深拷贝”`。因此，可以假定任何自动复制在运行时性能方面都是廉价的。


### 变量与数据交互的方式（二）：克隆
如果我们确实需要 `深度复制` String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。
```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

#### 只在栈上的数据：拷贝
```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

像`整型`这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。


#### Trait: Copy
Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的`存储在栈上的类型`上.
如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait。

作为一个通用的规则，任何一组`简单标量值的组合`都可以实现 `Copy` ，
任何`不需要分配内存或某种形式资源的类型`都可以实现 `Copy` 。


#### 所有权与函数

将值传递给函数与给变量赋值的原理相似。
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```

当尝试在调用 `takes_ownership` 后使用 `s` 时，Rust 会抛出一个编译时错误。


#### 返回值与作用域

> 返回值也可以转移所有权。变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到takes_and_gives_back 中, 它也将返回值移给 s3                                 
    // takes_and_gives_back返回后s2即被drop


} // 这里，s3，s1移出作用域并被丢弃。

fn gives_ownership() -> String {

    let some_string = String::from("yours");
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

在每一个函数中都获取所有权并接着返回所有权有些啰嗦。
如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了.
-> Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 `引用（references）`

除此之外，我们也可能想返回函数体中产生的一些数据。
-> 我们可以使用`元组`来返回多个值


## 4.2 引用与借用
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // calculate_length完成后并不会drop s1
    println!("The length of '{}' is {}.", s1, len);
}

// s 是 String 的引用
fn calculate_length(s: &String) -> usize {
    s.len()
}
// 当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权。
```

`&s1 `语法让我们创建一个 `指向 值 s1 `的引用，但是并不拥有它。
因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。

#### 尝试修改借用的变量
```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
> 试图修改引用的参数会报错：error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference

### 可变引用
通过一个小调整就能允许我们修改一个借用的值,`可变引用（mutable reference）`：
- 我们必须将 `s` 改为 `mut`。
- 然后在调用 change 函数的地方创建一个可变引用 `&mut s`
- 并更新函数签名以接受一个可变引用 `some_string: &mut String`

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
可变引用有一个很大的限制：
- 如果你有一个对该变量的可变引用，在这个可变引用不再使用前，你不能再创建另一个可变引用。
- 我们 也 不能在拥有不可变引用的同时拥有可变引用。
> 尝试创建两个 s 的可变引用的代码会失败: error[E0499]: cannot borrow `s` as mutable more than once at a time

这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。
这个限制的好处是 Rust 可以在编译时就避免`数据竞争`。

> 注意一个引用的作用域从声明的地方开始一直`持续到最后一次使用为止`。



### 悬垂引用（Dangling References）
在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 `悬垂指针（dangling pointer）`，所谓悬垂指针是`其指向的内存可能已经被分配给其它持有者`。

> 下述代码会报错：error[E0106]: missing lifetime specifier

```rust
fn main() {
    let reference_to_nothing = dangle();
}


// 返回一个String的引用
fn dangle() -> &String {
    let s = String::from("hello");

    &s
    // 预期返回s的引用，但注意此函数完成后s本身会被drop，因而返回的引用指向null
}
```


## 4.3 Slice 类型

`slice` 允许你引用集合中一段连续的元素序列，而不用引用整个集合。
`slice` 是引用，所以它没有所有权。

> usize 是 Rust 编程语言中的一种整数类型，它代表无符号整数。
> 它的大小取决于运行 Rust 代码的计算机架构，通常是与计算机的指针大小相同。在 32 位计算机上，usize 是 32 位无符号整数，而在 64 位计算机上，usize 是 64 位无符号整数。


#### '' 和 b''
注意：' ' 是 Rust 中的 char 字面值，它可以包含单个字符，
而 b' ' 是字节字面值，只包含一个字节。
在 Rust 中，字符字面值通常用于表示文本字符，而字节字面值用于处理二进制数据。


#### &str 和 String 
`&str：` 是一个字符串切片，它是一个`不可变引用（immutable reference）`，通常用于引用字符串文本的一部分，例如从一个 String 或字符串字面值中提取的子串。由于 str 是不可变的，你不能对其进行修改。str 类型通常用于参数传递和字符串处理的引用形式。

`String：`是 Rust 的标准库中提供的可变的、拥有（owned）的字符串类型。它是一个堆分配的字符串，可以随时进行增加、删除和修改操作。String 通常用于需要动态分配和修改字符串内容的情况。

> 当编写函数的入参为字符串时，最好让其类型为`&str`，如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。
> 定义一个获取 `&str` 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：


### 其他类型的 slice
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // data type of slice: &[i32]

assert_eq!(slice, &[2, 3]);
```


# 5. `Structs` to Structure Related Data
struct或structure是一种自定义数据类型，允许您将多个相关的值打包在一起并命名，这些值组成一个有意义的组。
如果您熟悉面向对象的语言， `struct` 就像对象的数据属性。在本章中，我们将比较和对比 `tuple` 和 `struct` ，以建立在您已经知道的基础上，并演示 `struct` 是分组数据的更好方法。

我们将演示如何定义和实例化 `struct` 。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与 `struct` 类型关联的行为。 `Structs` 和 `Enum` (在第6章中讨论)是在程序域中创建新类型以充分利用Rust的编译时类型检查的构建块。

## 5.1 结构体的定义和实例化

```rust
// Def
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
> 结构体数据的所有权: 我们使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型。
> 这是一个有意而为之的选择，因为我们想要这个结构体`拥有它所有的数据`，为此只要整个结构体是有效的话其数据也是有效的。
> 要使结构体存储`被其他对象拥有的数据的引用`, 需要用上 `生命周期（lifetimes）`

#### 访问和修改属性
注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变

```rust
fn main() {
    // Initialize an instance
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    // Access attribute with `.`
    // Modify attribute requires struct to be mutable
    user1.email = String::from("anotheremail@example.com");
}
```

#### Builder
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}

// 为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 email 和 username 字段名称与变量有些啰嗦。
// 如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！
fn build_user_compact(email: String, username: String) -> User {
    User {
        active: true,
        // 使用了字段初始化简写语法，因为 username 和 email 参数与结构体字段同名
        username,
        email,
        sign_in_count: 1,
    }
}
```

### 使用`结构体更新`语法从其他实例创建实例

`使用旧实例的大部分值`但`改变其部分值`来创建一个新的结构体实例通常是很有用的。这可以通过 `结构体更新语法（struct update syntax）`实现。

通过 `..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。

```rust
fn main() {
    let user2 = User {
        // 使用user1实例的属性
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,    
    };
}

// `..` 语法进一步减省
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
        // ..user1 必须放在最后
    };

```
> 请注意，`结构更新语法`就像带有 = 的赋值，因为它`移动`了数据
> 总体上说我们在创建 user2 后不能就再使用 user1 了，因为 user1 的 username 字段中的 String 被移到 user2 中.
> 但如果`更新的字段都是基础类型`如bool和i32，是`实现 Copy trait 的类型`。那么 user1 在创建 user2 后仍然有效


### 元组结构体（tuple structs）

元组结构体`有着结构体名称`提供的含义，但`没有具体的字段名`，只有字段的类型。

虽然Color，Point两个类型都由三个 i32 值组成，但black，origin是不同的元组结构体的实例

元组结构体实例类似于元组，你可以将它们`解构为单独的部分`，也`可以使用 . 后跟索引来访问单独的值`，等等。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
### 类单元结构体（unit-like structs）

我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）

类单元结构体常常在你想要`在某个类型上实现 trait 但不需要在类型中存储数据的时候`发挥作用

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```


## 5.2 结构体示例程序
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn area(rectangle: Rectangle) -> u32 {
    rectangle.height * rectangle.width
}

pub(crate) fn main() {

    let rectangle = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rectangle)
    );
}
```

### 通过派生 trait 增加实用功能
`println! `宏能处理很多类型的格式，不过，`{}` 默认告诉 `println! `使用被称为 Display 的格式：意在提供给直接终端用户查看的输出。

目前为止见过的基本类型都默认实现了 `Display` ，因为它就是向用户展示 1 或其他任何基本类型的唯一方式。

对于结构体，`println!` 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，所以`结构体并没有提供一个 Display 实现`来使用 `println!` 与 `{}` 占位符。

打印结构体时:
- 在 `{} `中加入 `:? `指示符告诉 `println!` 我们想要使用叫做 `Debug` 的输出格式。
- 结构体定义之前加上外部属性 #[derive(Debug)]

> 当我们有一个更大的结构体时，能有更易读一点的输出就好了，为此可以使用` {:#?}` 替换 println! 字符串中的 `{:?}`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    // Use {:?}
    println!("rect1 is {:?}", rect1);
}
```

### 使用 dbg!
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        // dbg! 返回表达式的值的所有权，所以 width 字段将获得相同的值，就像我们在那里没有 dbg! 调用一样
        width: dbg!(30 * scale),
        height: 50,
    };
    // 我们不希望 dbg! 拥有 rect1 的所有权，所以我们在下一次调用 dbg! 时传递一个引用
    dbg!(&rect1);
}
```

## 5.3 方法语法

`方法（method）`与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。

与函数是不同的，因为它们在结构体的上下文`impl`中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 `self` ，它代表调用该方法的结构体实例。

> `method` 是 结构体 `实现impl` 中定义的

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

#### getter
```rust
impl Rectangle {

    fn width(&self) -> u32 {
        self.width
    }
}

pub(crate) fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!(
        "The width of the rectangle is {} square pixels.",
        rect1.width()
    );
}
```

在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle，`&self 实际上是 self: &Self 的缩写。`, 有4种缩写：
- self 获取所有权
- &self 仅仅读取
- mut self 获取所有权
- &mut self 做出修改

这里选择 `&self `的理由跟在函数版本中使用 &Rectangle 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。

如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self`

> 使用方法替代函数的目的：
> 不需要在每个函数签名中重复 self 的类型之外，
> 其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 impl 块中，而不是让将来的用户在我们的库中到处寻找 Rectangle 的功能。


Getters 很有用，因为你`可以把字段变成私有的，但方法是公共的`，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。

#### -> 运算符到哪去了？
在 C/C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法, 这时需要先`解引用（dereference）指针`。换句话说，如果 object 是一个指针，那么 `object->something()` 就像 `(*object).something()` 一样。

Rust 并没有一个与 -> 等效的运算符；相反，Rust 有一个叫 `自动引用和解引用（automatic referencing and dereferencing）`的功能。`方法调用`是 Rust 中少数几个拥有这种行为的地方。


### 带有更多参数的方法
```rust
impl Rectangle {
    fn can_hold(&self, another_rectangle: &Rectangle) -> bool {
        self.width >= another_rectangle.width
            && self.height >= another_rectangle.height
    }
}
```

### 关联函数
所有在 `impl` 块中定义的函数被称为 `关联函数（associated functions）`，因为它们与 `impl` 后面命名的类型相关。

可以定义`不以 self 为第一参数的关联函数（因此不是方法）`，因为它们并`不作用于一个结构体的实例`。我们已经使用了一个这样的函数：在 String 类型上定义的 `String::from` 函数。

不是方法的关联函数`经常被用作返回一个结构体新实例的构造函数`。

> 使用结构体名和 `::` 语法来调用这个关联函数

```rust
impl Rectangle {
    fn square(size: u32) -> Self { // Self 即是 Rectangle
        Self {
            width: size,
            height: size,
        }
    }
}
```

# 6. Enums and Pattern Matching

enums 提供了一种说明一个 value 是一组可能的 value 之一的方法

假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4（version four）和 IPv6（version six）。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以 `枚举` 出所有可能的值. 

任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个成员。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// 类似于定义多个不同类型的结构体，如下
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
```

枚举还有另一个相似点：就像可以使用 `impl` 来为结构体定义方法那样
```rust
    impl Message {
        fn call(&self) {
            // 在这里定义方法体
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```

### Option 枚举和其相对于空值的优势

`Option` 是标准库定义的一个枚举. `Option` 类型应用广泛因为它编码了一个非常普遍的场景，`即一个值要么有值要么没值。`

Rust 并`没有`很多其他语言中有的`空值功能`。空值（Null ）是一个值，它代表没有值。空值是一个因为某种原因目前无效或缺失的值。
在有空值的语言中，变量总是这两种状态之一：空值和非空值。

`Rust 并没有空值`，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`, 它定义于标准库中:
```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T> `枚举是如此有用以至于它甚至被包含在了 `prelude` 之中, 可以不需要 Option:: 前缀来`直接使用 Some 和 None`

> <T> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。

我们在 Some 成员中指定了值，`Rust 可以推断其类型。`
```rust
    // some_number 的类型是 Option<i32>
    let some_number = Some(5);
    // some_char 的类型是 Option<char>
    let some_char = Some('e');
    // 需要指定 Option 整体的类型，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型
    // 我们告诉 Rust 希望 absent_number 是 Option<i32> 类型的。
    let absent_number: Option<i32> = None;
```

`Option<T>` 为什么就比空值要好呢？
-> 因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个`肯定有效的值`那样使用 `Option<T>`
```rust
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```
上述代码会报错：error[E0277]: cannot add `Option<i8>` to `i8`。因为它尝试将 `Option<i8>` 与 `i8` 相加.
换句话说，在对 `Option<T>` 进行运算之前必须将其转换为` T`.

如何从 `Some` 成员中取出 `T` 的值来使用它呢?
-> 为了使用` Option<T>` 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 `Some(T)` 值时运行，允许这些代码使用其中的 `T`。也希望一些代码只在值为 `None` 时运行，这些代码并没有一个可用的 `T` `值。match` 表达式就是这么一个处理枚举的控制流结构


## 6.2 match 控制流结构
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }, // 分支后的逗号是可选的
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 绑定值的模式
```rust
#[derive(Debug)] // 这样可以立刻看到州的名称
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```
调用 `value_in_cents(Coin::Quarter(UsState::Alaska))` 会打印 `State quarter from Alaska`, 且返回值为`25`

### 匹配 Option<T>
