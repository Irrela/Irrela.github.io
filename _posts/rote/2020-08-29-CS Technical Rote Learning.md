---
title: Computer Science Technical Rote Learning
categories: Rote Learning
tags:
- Rote Learning
---

- [概念](#概念)
    - [强，弱，动静态](#强弱动静态)
      - [强类型，弱类型](#强类型弱类型)
      - [动态，静态类型](#动态静态类型)
    - [值传递，引用传递](#值传递引用传递)
    - [四种引用（JVM概念）](#四种引用jvm概念)
- [数据结构](#数据结构)
    - [八大排序](#八大排序)
    - [Tree](#tree)
      - [满二叉树和完全二叉树](#满二叉树和完全二叉树)
      - [BST 和 AVL](#bst-和-avl)
      - [红黑树](#红黑树)
      - [HashSet、LinkedHashSet和TreeSet三者区别与联系](#hashsetlinkedhashset和treeset三者区别与联系)
- [操作系统](#操作系统)
    - [死锁](#死锁)
      - [预防](#预防)
      - [避免](#避免)
    - [线程安全](#线程安全)
    - [线程与进程](#线程与进程)
    - [线程切换的开销](#线程切换的开销)
    - [线程的生命周期](#线程的生命周期)
    - [线程池](#线程池)
      - [参数](#参数)
      - [线程池五种状态](#线程池五种状态)
      - [线程池执行流程](#线程池执行流程)
    - [java的线程状态](#java的线程状态)
    - [sleep](#sleep)
    - [守护进程](#守护进程)
    - [进程间通信](#进程间通信)
    - [线程间通信](#线程间通信)
    - [进程切换和线程切换](#进程切换和线程切换)
    - [线程切换上下文](#线程切换上下文)
    - [进程调度算法](#进程调度算法)
    - [僵尸，孤儿进程](#僵尸孤儿进程)
      - [僵尸进程](#僵尸进程)
      - [孤儿进程](#孤儿进程)
    - [虚拟内存](#虚拟内存)
      - [局部性原理](#局部性原理)
      - [OS的内存管理机制](#os的内存管理机制)
      - [内，外部碎片](#内外部碎片)
      - [页式，段式，段页式](#页式段式段页式)
      - [页面置换算法](#页面置换算法)
    - [用户态和内核态](#用户态和内核态)
    - [I/O 模型](#io-模型)
      - [同步与非同步](#同步与非同步)
      - [阻塞与非阻塞](#阻塞与非阻塞)
      - [文件描述符fd](#文件描述符fd)
      - [Redis 缓存雪崩、击穿、穿透](#redis-缓存雪崩击穿穿透)
      - [IO多路复用 （事件驱动） reactor模式](#io多路复用-事件驱动-reactor模式)
        - [select](#select)
        - [poll](#poll)
        - [epoll](#epoll)
      - [AIO （异步非阻塞I/O模型）](#aio-异步非阻塞io模型)
      - [accept（）](#accept)
      - [service Thread](#service-thread)
    - [并发](#并发)
      - [同步和互斥](#同步和互斥)
        - [synchronized的三种应用方式](#synchronized的三种应用方式)
      - [volatile](#volatile)
    - [volatile和synchronized的区别](#volatile和synchronized的区别)
      - [原子性，可见性，有序性](#原子性可见性有序性)
    - [原子类](#原子类)
    - [悲观锁](#悲观锁)
    - [乐观锁和悲观锁](#乐观锁和悲观锁)
    - [公平锁和非公平锁](#公平锁和非公平锁)
    - [自旋锁](#自旋锁)
    - [锁升级](#锁升级)
    - [AQS](#aqs)
    - [ConcurrentHashMap](#concurrenthashmap)
    - [HashMap](#hashmap)
    - [ThreadLocal](#threadlocal)
    - [秒杀系统](#秒杀系统)
    - [消息队列](#消息队列)
    - [Unix cmd](#unix-cmd)
- [计算机网络](#计算机网络)
    - [浏览器输入域名到出现网页的过程](#浏览器输入域名到出现网页的过程)
    - [Get和Post请求的区别](#get和post请求的区别)
    - [DNS](#dns)
    - [TCP协议详细](#tcp协议详细)
    - [三次握手，四次挥手](#三次握手四次挥手)
    - [无差错传输](#无差错传输)
    - [拥塞避免算法](#拥塞避免算法)
    - [ICMP](#icmp)
      - [ping](#ping)
      - [TTL](#ttl)
    - [OSPF和RIP](#ospf和rip)
    - [Cookie 和 session](#cookie-和-session)
    - [TCP keepAlive](#tcp-keepalive)
    - [HTTP](#http)
      - [HTTP](#http-1)
    - [Http缓存机制](#http缓存机制)
      - [请求304](#请求304)
    - [TCP流量控制和拥塞控制](#tcp流量控制和拥塞控制)
    - [https](#https)
      - [TLS/SSL握手](#tlsssl握手)
      - [流程](#流程)
      - [HTTPS的缺点](#https的缺点)
      - [Web安全](#web安全)
        - [同源策略](#同源策略)
        - [CORS](#cors)
        - [XSS](#xss)
        - [CSRF](#csrf)
    - [正则](#正则)
- [Database](#database)
    - [MyISAM与InnoDB区别](#myisam与innodb区别)
      - [ACID](#acid)
      - [MySQL事务的实现](#mysql事务的实现)
      - [多版本并发控制(MVCC)](#多版本并发控制mvcc)
      - [隔离级别](#隔离级别)
      - [索引](#索引)
        - [B+索引和hash索引](#b索引和hash索引)
        - [聚簇索引](#聚簇索引)
        - [B+ tree](#b-tree)
        - [B+ tree 与 红黑树](#b-tree-与-红黑树)
        - [索引优化](#索引优化)
        - [索引的优点](#索引的优点)
      - [索引优化](#索引优化-1)
      - [高并发的数据库设计](#高并发的数据库设计)
  - [编译原理](#编译原理)
      - [编译流程](#编译流程)
      - [](#)
  - [设计模式](#设计模式)
    - [依赖，聚合，组合](#依赖聚合组合)
      - [依赖](#依赖)
      - [聚合](#聚合)
      - [组合](#组合)
    - [单例](#单例)
      - [单例模式实现](#单例模式实现)
        - [lazy，线程不安全](#lazy线程不安全)
        - [hunger，线程安全](#hunger线程安全)
        - [lazy，线程安全](#lazy线程安全)
        - [lazy，双重校验锁](#lazy双重校验锁)
    - [工厂](#工厂)
    - [抽象工厂](#抽象工厂)
- [JVM](#jvm)
    - [堆内存和堆内存](#堆内存和堆内存)
    - [数据结构的堆](#数据结构的堆)
    - [内存模型](#内存模型)
      - [程序计数器（private）](#程序计数器private)
      - [虚拟机栈（private）](#虚拟机栈private)
      - [本地方法栈（private）](#本地方法栈private)
      - [Java堆（shared）](#java堆shared)
      - [方法区（shared）](#方法区shared)
        - [运行时常量池](#运行时常量池)
      - [OutOfMemoryError 和 StackOverflowError](#outofmemoryerror-和-stackoverflowerror)
    - [GC机制](#gc机制)
      - [判断对象死亡](#判断对象死亡)
        - [可达性算法](#可达性算法)
      - [finalize()方法](#finalize方法)
    - [GC算法](#gc算法)
      - [标记-清除算法](#标记-清除算法)
      - [复制算法](#复制算法)
        - [Eden and Survivor](#eden-and-survivor)
      - [标记-整理算法](#标记-整理算法)
      - [分代收集](#分代收集)
      - [垃圾收集器分类](#垃圾收集器分类)
    - [内存分配与回收策略](#内存分配与回收策略)
      - [对象优先在Eden分配](#对象优先在eden分配)
      - [Minor GC and Full GC](#minor-gc-and-full-gc)
      - [大对象直接进入老年代](#大对象直接进入老年代)
      - [晋升到老年代](#晋升到老年代)
      - [动态年龄判断](#动态年龄判断)
      - [空间分配担保](#空间分配担保)
    - [类加载](#类加载)
      - [JAVA创建一个对象的过程](#java创建一个对象的过程)
      - [流程](#流程-1)
        - [加载](#加载)
        - [验证](#验证)
        - [准备](#准备)
        - [解析](#解析)
          - [符号引用](#符号引用)
          - [直接引用](#直接引用)
        - [初始化](#初始化)
      - [类加载器](#类加载器)
      - [双亲委派模型](#双亲委派模型)
- [Spring](#spring)
    - [AOP](#aop)
- [Pending](#pending)
  - [本地缓存](#本地缓存)
    - [Java技术栈实践](#java技术栈实践)
      - [Caffeine](#caffeine)
  - [分布式缓存](#分布式缓存)
    - [为什么需要分布式缓存](#为什么需要分布式缓存)
      - [关于 Redis 的事务](#关于-redis-的事务)
  - [缓存优化](#缓存优化)
    - [缓存穿透和雪崩处理](#缓存穿透和雪崩处理)
      - [二级缓存（Secondary Cache）](#二级缓存secondary-cache)
    - [使用适当的缓存策略](#使用适当的缓存策略)
    - [使用适当的过期策略](#使用适当的过期策略)
    - [使用分布式锁](#使用分布式锁)
    - [分层缓存：](#分层缓存)
    - [数据预热](#数据预热)


# 概念
### 强，弱，动静态

#### 强类型，弱类型
强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就死该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。

Haskell 的强类型系统会拒绝执行任何无意义的表达式，保证程序不会因为这些表达式而引起错误。

不会自动地将值从一个类型转换到另一个类型（转换有时又称为强制或变换

#### 动态，静态类型
动态类型语言是指在运行期间才去做数据类型检查的语言。

编译器可以在编译期（而不是执行期）知道每个值和表达式的类型。Haskell 编译器或解释器会察觉出类型不正确的表达式，并拒绝这些表达式的执行：

### 值传递，引用传递
值传递：当参数按值传递时，调用者和被调用者有两个具有相同值的独立变量。如果被调用者修改参数变量，则调用者看不到效果。

引用传递：当参数通过引用传递时，调用者和被调用者对参数使用相同的变量。如果被调用者修改参数变量，则调用者的变量可以看到效果。

Java 总是值传递，但我们可以用sort（int[] arr,...） 的方式来改变数组arr，这看上去像是传引用但并不是。

这是一个数组，当传递给方法时，是一个地址，即是我们给了一份地址的副本，我们可以修改地址的副本，而原数组的地址并不会变化，这确实是值传递。

但地址副本和地址本身都指向同样的内存位置，所以我们通过副本仍然可以访问到数组，并对其内容进行修改。

对象同理， 我们可以通过这种方式修改对象的attributes。

当面对基础类型时，我们写一个方法，add(int a) { a += 10 }, 这个方法并不会让参数增加10， 这也是值传递的一个反映。
（String虽是对象，但好像也不能修改，怀疑是常量池的原因）

### 四种引用（JVM概念）
1. 强引用：普遍存在的`Object obj = new Object()`这类引用，强引用的对象永远不会被GC。
2. 软引用：还有用但非必需对象，在 系统将要发生`OutOfMemoryError`异常前，会将这些对象列入回收范围进行二次回收，如果回收了它们仍然没有足够内存，才会抛出`OutOfMemoryError`。
3. 弱引用： 描述非必需对象，比软引用更弱， 其引用对象只能生存到 下一次GC 发生之前。当GC发生的时候，无论内存情况如何，都会进行回收。
4. 虚引用： 最弱的引用关系，完全不对对象的生存时间产生影响，唯一目的是 能在对象被回收时收到一个系统通知。

# 数据结构

### 八大排序

### Tree
#### 满二叉树和完全二叉树

#### BST 和 AVL
平衡二叉树（Balanced BinaryTree）又被称为AVL树。 
它具有以下性质：
- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
- 并且左右两个子树都是一棵平衡二叉树。 

平衡二叉树一般是一个有序树，它具有二叉树的所有性质，其遍历操作和二叉树的遍历操作相同。

#### 红黑树
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：
- Root是黑色。
- Node是红色 or 黑色。
- 所有叶子都是黑色（叶子是NIL节点）。
- 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

这些约束确保了红黑树的关键特性：`从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。`


#### HashSet、LinkedHashSet和TreeSet三者区别与联系
- HashSet无序， 可以有一个Null元素
- LinkedHashSet按照放入的顺序排列，可以有一个Null元素， 底层哈希表和链表组成， 添加、删除操作时间复杂度都是O(1)。
- TreeSet元素的自然顺序进行排序，不允许Null元素， 底层红黑树， 添加、删除操作时间复杂度都是O(log(n))

# 操作系统
<https://www.cnblogs.com/cxuanBlog/p/13297199.html>
### 死锁
多个进程在执行时，互相请求对方正占用的资源，导致都无法执行完毕并释放出占有资源，形成阻塞。

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

<https://blog.csdn.net/hj605635529/article/details/69214903#:~:text=%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%EF%BC%9A%E7%A0%B4%E5%9D%8F,%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E4%BD%8E%E6%95%88%E3%80%82>

#### 预防
破坏死锁的四个条件中的一个或几个， 但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。

#### 避免
通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。

- 进程启动拒绝：如果一个进程的请求会导致死锁，则不启动该进程。
- 资源分配拒绝：如果一个进程增加的资源请求会导致死锁，则不允许此分配(银行家算法)。 

假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁。

如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。

不存在一个安全序列。不安全状态不一定导致死锁。

### 线程安全

當多個線程訪問某個方法時，不管你通過怎樣的調用方式、或者說這些線程如何交替地執行，我們在主程序中不需要去做任何的同步，這個類的結果行為都是我們設想的正確行為，那麼我們就可以說這個類是線程安全的

一般是针对于类来讲的，也就是说当一个类在多线程访问时能正常地工作（结果和行为符合我们在设计该类的初衷，与在单线程时的表现一致），他就是一个线程安全的类， 线程安全的类无需在主程序中再做任何同步。

### 线程与进程
线程是系统独立调度和分派CPU的基本单位， 进程是资源分配的最小单位
<https://blog.csdn.net/mxsgoden/article/details/8821936#:~:text=%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%93%8D%E4%BD%9C,%EF%BC%88%E9%80%9A%E8%BF%87CPU%E8%B0%83...>

### 线程切换的开销
CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次`上下文切换`。

上下文：CPU 寄存器和程序计数器

CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。
程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。


### 线程的生命周期
- 新建
- 就绪 ： 线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- 运行 ： 就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。
- 阻塞 ： 一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态
- 死亡状态 : 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

三种阻塞：
- 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。

- 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。

- 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

### 线程池
#### 参数
corePoolSize，核心线程数量，决定是否创建新的线程来处理到来的任务
maximumPoolSize，最大线程数量，线程池中允许创建线程地最大数量
keepAliveTime，线程空闲时存活的时间
unit，空闲存活时间单位
workQueue，任务队列，用于存放已提交的任务
threadFactory，线程工厂，用于创建线程执行任务
handler，拒绝策略，当线程池处于饱和时，使用某种策略来拒绝任务提交

#### 线程池五种状态
- Running : 能够接受新的任务以及处理阻塞队列中的任务
- ShutDown : 不再接受新到来的任务，但可以处理阻塞队列中的任务
- Stop : 不再接受新到来的任务，试图停止所有正在执行的线程，不再处理阻塞队列中等待的任务，当然，它会返回那些未执行的任务。 
- Tidying : 所有任务终止，有效线程数为0，运行terminated()钩子方法
- Terminated : terminated()运行完成后进入该状态

1. shutDown() 
当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。 

2. shutdownNow() 
执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 

#### 线程池执行流程


### java的线程状态
1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

> 一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：
> 
### sleep
Thread.sleep(long) 可以让当前进程休眠， 必须搭配中断异常。



<https://blog.csdn.net/pange1991/article/details/53860651#:~:text=Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81,%E5%AF%B9%E8%B1%A1%E7%9A%84start()%E6%96%B9%E6%B3%95%E3%80%82>



### 守护进程
守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。 

执行thread.start() 方法前, 设置thread.setDemon(true);

理解一 :  守护线程就是main同生共死，当main退出，它将终止，而普通线程是在任务执行结束才停止。

理解二： 用户线程：`Java虚拟机在它所有非守护线程已经离开后自动离开`。守护线程则是用来服务用户线程的，如果没有其他用户线程在运行，那么就没有可服务对象，也就没有理由继续下去。

例如：我们所熟悉的Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。

### 进程间通信
<https://www.jianshu.com/p/c1015f5ffa74>

### 线程间通信
a) 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

b) 信号量(Semphares)：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

c) 事件(Event):Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 进程切换和线程切换
<https://segmentfault.com/a/1190000019750164#:~:text=%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%80%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB,%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E3%80%82>

### 线程切换上下文

### 进程调度算法
a）先来先去服务

b）时间片轮转法

c）短作业优先

d）多级反馈队列调度算法

e）优先级调度


### 僵尸，孤儿进程
#### 僵尸进程
僵尸进程是指它的父进程没有等待(调用 wait/waitpid)。如果子进程先结束而父进程后结束，即子进程结束后，父进程还在继续运行但是并未调用 wait/waitpid 那子进程就会成为僵尸进程。但如果子进程后结束，即父进程先结束了，但没有调用 wait/waitpid 来等待子进程的结束， 此时子进程还在运行，父进程已经结束。那么并不会产生僵尸进程。应为每个进程结束时， 系统都会扫描当前系统中运行的所有进程，看看有没有哪个进程时刚刚结束的这个进程的子 进程，如果有就有 init 来接管它，成为它的父进程。

进程设置僵尸状态的目的是维护子进程的信息，以便父进程在以后某个时间获取。要在当前 进程中生成一个子进程，一般需要调用 fork 这个系统调用，fork 这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，可以通过返回值来判断其 返回点。如果子进程先于父进程退出， 同时父进程又没有调用 wait/waitpid，则该子进程将成为僵尸进程。

在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存。但是 仍然保留了一些信息（如进程号 pid 退出状态 运行时间等）。这些保留的信息直到进程通过调用 wait/waitpid 时才会释放。这样就导致了一个问题，如果没有调用 wait/waitpid 的话，那 么保留的信息就不会释放。比如进程号就会被一直占用了。但系统所能使用的进程号的有限 的，如果产生大量的僵尸进程，将导致系统没有可用的进程号而导致系统不能创建进程。所 以我们应该避免僵尸进程。

如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用 的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免

#### 孤儿进程
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤 儿进程。孤儿进程将被 init 进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。孤儿进程是没有父进程的进程，管理孤儿进程这个重任就落到了 init 进程身上，因此孤儿进程并 不会有什么危害。

### 虚拟内存

虚拟内存使得应用程序认为它拥有一个连续的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。虚拟内存让每个进程拥有一片连续完整的内存空间。

#### 局部性原理
局部性原理表现在以下两个方面：

1)时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。

2)空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。

#### OS的内存管理机制
1. 块式管理 ： 将内存分为几个固定大小的块，每个块中只包含一个进程。

2. 页式管理 ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址 和物理地址。

3. 段式管理 ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，最重要的是段是有实际意义的，每个段定义了一组逻辑信息。 段式管理通过段表对应逻辑地址和物理地址。例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

4. 段页式管理：段页式管理机制结合了段式管理和页式管理的优点。段页式管理机制就是 `把主存先分成若干段，每个段又分成若干页`。

#### 内，外部碎片

`内部碎片`： 内部碎片是已经被分配出去（能明确指出属于哪个进程）的内存空间大于请求所需的内存空间，不能被利用的内存空间就是内部碎片。


`外部碎片`： 外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。

<https://blog.csdn.net/qq_22238021/article/details/80209062#:~:text=%E7%9B%B4%E5%88%B0%E8%BF%9B%E7%A8%8B%E9%87%8A%E6%94%BE%E5%AE%83%EF%BC%8C%E6%88%96,%E7%A7%8D%E7%8E%B0%E8%B1%A1%E6%88%90%E4%B8%BA%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E3%80%82>

#### 页式，段式，段页式
`页式`：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

`段式`：段式虚拟存储器中的`段是按程序的逻辑结构划分的`，各个段的长度因程序而异。把虚拟地址 分为两部分：段号和段内地址。

优点： 段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享。

缺点： 因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。

`段页式`： 把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。
在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。-》 两次查表

#### 页面置换算法
- OPT（最佳页面置换算法）：所选择的被换出的页面将是最长时间内不再被访问， 通常可以保证获得最低的缺页率。

- FIFO（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。

- LRU（最近最久未使用页面置换算法）：将最近最久未使用的页面换出。需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到 链表表头。这样就能保证链表表尾的页面是最近最久未访问的。力扣-实现LRU

- LFU（最少使用页面置换算法）：该置换算法选择在之前时期使用最少的页面作为淘汰页。力扣-实现LFU


### 用户态和内核态

操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序。根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。
运行的程序基本都是运行在用户态。如果我们调用操作系统提供的内核态级别的子功能那就需要系统调用了。

系统调用：与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都 必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。补充：

用户态切换到内核态的几种方式

系统调用: 系统调用是用户态主动要求切换到内核态的一种方式， 用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。

异常：当 cpu 在执行用户态的应用程序时，发生了某些不可知的异常。 于是当前用户态的应用进程切换到处理此异常的内核的程序中去。

硬件设备的中断: 当硬件设备完成用户请求后，会向 cpu 发出相应的中断信号，这时 cpu 会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序， 如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核态的转换。

### I/O 模型
在UNIX可以归纳成5种I/O模型:
1. 阻塞I/O
2. 非阻塞I/O
3. I/O多路复用
4. 信号驱动I/O
5. 异步I/O

#### 同步与非同步
同步
发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生。

异步
发送一个请求，不等待返回，随时可以再发送下一个请求，可以提高效率，保证并发。

#### 阻塞与非阻塞
阻塞
传统的IO流都是阻塞式的。也就是说，当一个线程调用read()或者write()方法时，该线程将被阻塞，直到有一些数据读读取或者被写入，在此期间，该线程不能执行其他任何任务。在完成网络通信进行IO操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量的客户端时，性能急剧下降。

> 线程会被未完成的IO阻塞
非阻塞
JavaNIO是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。

#### 文件描述符fd
Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，返回一个file descriptor（fd，文件描述符）。而对一个socket的读写也会有响应的描述符，称为socket fd（socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。

所以说：在Linux下对文件的操作是利用文件描述符(file descriptor)来实现的。

#### Redis 缓存雪崩、击穿、穿透
- 缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。（1. 布隆过滤器（Bloom Filter）布隆过滤器可以用于检索一个元素是否在一个集合中， 2. 给不存在的也作个null缓存）
  
- 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
  
- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。


#### IO多路复用 （事件驱动） reactor模式
Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流。

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字.

即非阻塞的socket文件描述符号加上监控这些描述符的I/O多路复用机制（在Linux下可以使用select/poll/epoll）， select比较早期，要遍历已注册的所有fd， 后来的epoll性能好得多，其性能不太受连接数影响，很好的并发性。

多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时

##### select
1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
3. select支持的文件描述符数量太小了，默认是1024

##### poll
poll的实现和select非常相似，只是描述fd集合的方式不同

##### epoll

epoll_create, epoll_ctl, epoll_wait

epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。

1. 在epoll_ctl时拷贝所有fd进内核态，而非每次调用时
2. 在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表
3. epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd.


<https://www.zhihu.com/question/28594409>


#### AIO （异步非阻塞I/O模型）
异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。

#### accept（）
```java
while (true) {
    System.out.println("\nListening to port: " + Integer.parseInt(args[0]));

    clientSocket = server.getServerSocket().accept();
    Thread thread = new Thread(new ServiceThread(server.getDictionary(), clientSocket));
    thread.start();
}
```
#### service Thread
```java
@Override
public void run() {

    try {
        BufferedReader input = new BufferedReader(new InputStreamReader(this.getClientSocket().getInputStream(), "UTF-8"));
        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(this.getClientSocket().getOutputStream(), "UTF-8"));

        System.out.println("A client has connected to Server, assign to thread \'" + Thread.currentThread().getName() + "\', start providing service.");
        System.out.println("Currently connected user number: " + (Thread.activeCount() - 1));

        //Handle client's requests until client side closes
        //ClientMsg will be parted into operation command and word inputs to be easily processed
        while((clientMsg = input.readLine()) != null){

            String[] operation = clientMsg.split("@split@");

            if(operation[0].equals("query")){
                output.write(query(operation[1]) + "\n");
                output.flush();
            }

            if(operation[0].equals("add")){
                output.write(add(operation[1], operation[2]) + "\n");
                output.flush();
            }

            if(operation[0].equals("remove")){
                output.write(remove(operation[1])  + "\n");
                output.flush();
            }
        }

        getClientSocket().close();
    }
}
```
在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。

### 并发
#### 同步和互斥
互斥，是指三部在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。

同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。　　

显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！　

> 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　
> 
> 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。


##### synchronized的三种应用方式
synchronized关键字最主要有以下3种应用方式，下面分别介绍

修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。

修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。

修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

#### volatile
> 保证被 volatile 修饰的共享变量的 可见性 & 有序性，但不保证原子性

volatile关键字的作用大致是，对该变量的每个单独读或写操作都是原子的。

然而，值得注意的是，一个需要不止一次读/写的操作（比如i++，相当于i=i+1，它进行一次读和一次写）不是原子的，因为另一个线程可能在读和写之间对i进行写。

原子类，如AtomicInteger和AtomicReference，提供了更广泛的原子操作，特别是包括AtomicInteger的increment。

### volatile和synchronized的区别
<https://blog.csdn.net/suifeng3051/article/details/52611233#:~:text=volatile%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%9C%A8%E5%91%8A%E8%AF%89,%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E8%A2%AB%E9%98%BB%E5%A1%9E%E4%BD%8F%E3%80%82>

#### 原子性，可见性，有序性
- 原子性： 要么全部执行，要么全部不执行
- 可见性： 当一个线程修改了共享属性的value后， 其他线程能立刻看到此修改的结果（表现为修改后立马从 工作内存 同步到主存，并刷新主存）
- 有序性： 为了提高性能，编译一般会进行指令重排序，volatile包含`禁止指令重排序`的语义

happens-before 原则

### 原子类
原子变量类 比锁的粒度更细，更轻量级，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。

原子变量将发生竞争的范围缩小到单个变量上。

原子变量类 比锁的粒度更细，更轻量级，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上。

底层基于CAS和volatile实现， 如果并发量不大，相比 Lock 更为安全，性能也能接受，因其得益于 JVM 底层机制来保障，自动释放锁，无需硬编码方式释放锁。而使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。

主要包括：
AtomicBoolean - 布尔类型原子类
AtomicInteger - 整型原子类
AtomicLong - 长整型原子类

AtomicReference - 引用类型原子类

AtomicIntegerArray - 整形数组原子类
AtomicLongArray - 长整型数组原子类
AtomicReferenceArray - 引用类型数组原子类



```java
atomicData.incrementAndGet(); // data++这并非是原子性操作
```
### 悲观锁
mysql中的共享锁和排它锁
lock for share mode
for update

### 乐观锁和悲观锁
悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。

乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
如果不同则根据实际值重新计算预期值，再次compare直到成功。

> CAS一般配合volatile变量以保证可见性。

<https://zhuanlan.zhihu.com/p/94762520>


### 公平锁和非公平锁
> 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

优点：所有的线程都能得到资源，不会饿死在队列中。
缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

> 非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

### 自旋锁
某线程尝试获得同步资源的锁失败：
- 非自旋锁：放弃CPU时间片， 操作系统切换CPU状态，当前线程休眠
- 自旋锁： 不放弃CPU时间片，通过自旋等待其他线程释放锁。

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。



### 锁升级
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

### AQS
AQS（AbstractQueuedSynchronizer）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量来表示状态，通过内置的FIFO（first in，first out）队列来完成资源获取线程的排队工作。

AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。

AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。

### ConcurrentHashMap
在多线程环境下，使用HashMap进行put操作时存在丢失数据的情况。-》 HashMap不是线程安全的类

HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占，相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。

ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，允许多个修改操作并发进行，其关键在于使用了`锁分段`技术。它使用了多个锁来控制对hash表的不同部分进行的修改。

jdk8之后，采用对位桶的头结点sychronized，cas操作进行复制

ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。

为什么不用ReentrantLock而用synchronized ?
减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。
内部优化:synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。

### HashMap
1. 树化标志：8位
2. get(key)方法时获取key的hash值，计算hash&(n-1)得到在链表数组中的位置first=tab[hash&(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可

> 使用尾插法，防止在扩容时出现环。


### ThreadLocal
ThreadLocal是一个关于创建线程局部变量的类。

这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为`上下文（Context）`，它是一种状态，可以是用户身份、任务信息等。

给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，User对象就传不进去了。

Java标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。

ThreadLocal实例通常总是以静态字段初始化如下：

> static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();

它的典型使用方式如下：

```java
void processUser(user) {
    try {
        threadLocalUser.set(user);
        step1();
        step2();
    } finally {
        threadLocalUser.remove();
    }
}
```

通过设置一个User实例关联到ThreadLocal中，在移除之前，所有方法都可以随时获取到该User实例：

```java
void step1() {
    User u = threadLocalUser.get();
    log();
    printUser();
}

void log() {
    User u = threadLocalUser.get();
    println(u.name);
}

void step2() {
    User u = threadLocalUser.get();
    checkUser(u.id);
}
```

最后，`特别注意ThreadLocal一定要在finally中清除,` 这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。
```java
try {
    threadLocalUser.set(user);
    ...
} finally {
    threadLocalUser.remove();
}
```
### 秒杀系统
<https://www.zhihu.com/question/54895548>

### 消息队列
<https://cloud.tencent.com/developer/article/1006035#:~:text=%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97(MQ),%E6%B5%81%E9%87%8F%E5%89%8A%E9%94%8B%E7%AD%89%E9%97%AE%E9%A2%98%E3%80%82>

### Unix cmd
- tar
- pwd 显示当前所在位置
- kill 
- top 常用来监控Linux的系统状况，比如CPU、内存的使用，显示系统上正在运行的进程。


# 计算机网络
<https://www.jianshu.com/p/45d27f3e1196>
<https://zhuanlan.zhihu.com/p/72616216>

### 浏览器输入域名到出现网页的过程
把待请求URL放入队列，判断URL是否已在请求队列，否的话就结束, 是的话就判断请求域名是否DNS缓存中，没有的话就解析域名，有的话就到指定域名的TCP连接是否开启，没有的话就开启TCP连接，进行HTTPS请求，初始化并完成TLS协议握手，向页面对应的URL发送请求。

URL是否在请求队列 -> 判断域名是否在DNS缓存中（无则解析域名） -> 检查TCP连接是否开启（无则3次握手） -> 进行https请求，初始化并完成TLS协议握手，想对应URL发送请求。

[浏览器中url过程](https://github.com/skyline75489/what-happens-when-zh_CN#g)

[http请求的细节](https://juejin.cn/post/6899005188955176974#heading-17)

ARP协议：IP地址 -> MAC地址。它解决的是同一局域网内部的主机或路由器的IP 地址和其对应的硬件地址的映射问题。
DNS: 域名 -> IP地址


### Get和Post请求的区别
get 参数直接添加到url中，post封装在http请求中， 浏览器无缓存

请求报文结构： 
- 请求行request line（方法， 请求路径，版本号）
- 请求header 
- 请求body（get请求无body）

响应报文结构： 
- 状态行（版本号， 状态码， 状态码解释信息）
- 响应header 
- 响应body


[GET与POST](https://www.jianshu.com/p/226195ec62ef)

### DNS
[DNS 原理入门](http://www.ruanyifeng.com/blog/2016/06/dns.html)

递归查询 (Recursive query)
递归查询是这么一种查询方式，一般发生在 Client 请求 DNS Server。Client 发出一个域名解析的请求，DNS Server 必须返回对应的 IP 地址，或者返回找不到的错误。

迭代查询 (Iterative query)
迭代查询一般发生在 DNS Server 之间，当 Client 发出域名解析的请求后，DNS Server 需要给予最佳答案，这个最佳答案可能是"距离最近"的顶级域名服务器，也能是权威域名服务器。无论如何，Client 需要对返回结果再次发起请求，知道获得最终结果。


### TCP协议详细 
TCP 面向连接，可靠传输， 字节流， 要求通信数据可靠
UDP 数据报文段，要求通信速度高

<img src="/images/posts/pli/tcpformat.png" width="75%"/>


### 三次握手，四次挥手
三握
<img src="/images/posts/pli/tcp3.png" width="75%"/>

> 理论上第二次握手就完成了连接建立，为什么服务器端需要第三次握手才进入连接已创建的状态？
- 第一次握手请求有可能是早已失效的连接请求报文，因为服务器需要再确认，即服务器对所有的第一次握手进行回复第二次握手，并对能回复第三次握手的client建立连接，防止浪费资源 

四挥(双方都可发起，发起的一方需要负担最后的2MSL time-wait)
<img src="/images/posts/pli/tcp4.png" width="75%"/>

> 为什么需要time-wait阶段？
- 发起的一方在接到另一方完成单向传输的最后一个包后（以FIN为标志），进行最后的第四次握手确认，并进入time-wait阶段。 
- 原因1：防止对方未接到第四次握手（如未接到则2MSL内会受到对方的第三次握手重传），直到原本的第四次握手确认到达对方，确保对方完成连接释放。
- 原因2：客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。即 在下1个新的连接中就不会出现早已失效的连接请求报文




### 无差错传输
1. 自动重传ARQ(针对出错重传)
2. 流量控制 & 拥塞控制（针对速度匹配）

流量控制: 接收方根据自己接受缓存的大小，动态调整发送方的发送窗口大小
拥塞控制: 防止过多的数据注入到网络中，使得网络中的路由器 & 链路不致于过载


### 拥塞避免算法
发送方维持一个状态变量：拥塞窗口（cwnd)

- 慢开始: 一开始发送报文段时拥塞窗口（cwnd）设置得为1 （指数上升）
- 拥塞避免: 每经过一个往返时间RTT，发送方的拥塞窗口（cwnd）加1， （线性上升）

快重传： 
- 接收方 每收到一个失序的报文段后 就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认
- 发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期

快恢复：当发送方连续收到3个重复确认后，就：
- 执行 乘法减小 算法：把 慢开始门限（ssthresh）设置为 出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半
- 将拥塞窗口（cwnd）值设置为 慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半
- 执行 加法增大 算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。
> 快恢复下不重新执行慢开始，直接到1/2ssthresh开始线性增加




<img src="/images/posts/pli/yongse1.png" width="75%"/>





### ICMP 
#### ping
ping是一种计算机网络工具，用来测试数据包能否透过IP协议到达特定主机。
ping的运作原理是向目标主机传出一个ICMP的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间

#### TTL 
TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。


### OSPF和RIP
RIP: 距离向量协议
OSPF: 链路状态协议

OSPF 具有以下特点：

向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
只有当链路状态发生变化时，路由器才会发送信息。
所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

<https://www.jianshu.com/p/63093df8064c>

### Cookie 和 session
cookie是网站用来标识用户身份而存储在用户本地终端上的数据

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上

1. 存储大小
cookie的数据大小不能超过4k；sessionStorage比cookie大得多，可以达到5M或者更大
2. 有限期时间
sessionStorage数据在当前浏览器窗口关闭后自动删除
设置得cookie过期时间之前都有效，就算窗口或者是浏览器关闭


利用 session，我们可以管理用户状态，比如控制会话存在时间，在会话中保存属性等。其作用方式通常如下：

服务器接收到第一个请求时，生成 session 对象，并通过响应头告诉客户端在 cookie 中放入 sessionId
客户端之后发送请求时，会带上包含 sessionId 的 cookie
服务器通过 sessionId 获取 session ，进而得到当前用户的状态（是否登录）等信息
也就是说，客户端只需要在登录的时候发送一次用户名密码，此后只需要在发送请求时带上 sessionId，服务器就可以验证用户是否登录了。

> 服务器生成session对象，并把sessionID传输给用户端，但不一定要用cookie，比如写在url中

### TCP keepAlive
<https://www.jianshu.com/p/9fe2c140fa52>
 当tcp连接被破坏后， 如果是死连接了， 服务端和客户端怎样才能知道信息能不能到达对方呢？ 很自然的想法是， 不断地给对方发探测信号， 看有没有回应， 这就是心跳机制的直白原理。 所谓的心跳即是数据包， 发心跳就是一方向另一方发送的数据包， 不断地发送， 如果收不到回应， 那么就有理由认为是tcp连接出了问题。 

但其实这个包的报文段是不含有任何数据的， 因此， 即使你用recv函数， 也不会接收到什么值。

[长连接与短连接](https://www.cnblogs.com/0201zcr/p/4694945.html)


### HTTP
- http header: HTTP 消息头用于描述资源或服务器或客户端的行为。
- http 请求方式
- http 状态码: HTTP 状态码用来表示特定的 HTTP 请求是否已成功完成。响应分为五类：消息响应，成功响应，重定向，客户端错误和服务器错误。

#### HTTP
<https://juejin.cn/post/6844903516738338829>


### Http缓存机制
<https://juejin.im/post/6844903801778864136>

#### 请求304
304状态码或许不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。

当你发出一个条件GET请求的时候服务器会从缓存中调用你要访问的内容，这个时候服务器就可以判断这个页面是不是更新过了，如果未更新过那么他会给你返回一个304状态码。

### TCP流量控制和拥塞控制
<https://www.jianshu.com/p/65605622234b>

### https
<https://segmentfault.com/a/1190000019976390>

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。

http和https都是应用层协议，但后者用到的加密SSL和TLS加密是传输层协议

#### TLS/SSL握手
<img src="/images/blog/TLS_hands.png" width="75%"/>

加密过程：
1. 客户端请求服务器，发送client random及其他信息，获得证书，server random
2. 客户端从证书获取公钥，加密另一个随机字符串premaster secret，发送给服务器
3. 服务器用私钥解密获得premaster secret，随后CS双方用以client random，server random，premaster secret生成的对称密钥进行内容传输

**混合加密：**结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。


**数字摘要：**通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。


**数字签名技术：**数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。



#### 流程
- 首先客户端通过URL访问服务器建立SSL连接。
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
- 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
- 服务器利用自己的私钥解密出会话密钥。
- 服务器利用会话密钥加密与客户端之间的通信。

#### HTTPS的缺点
- HTTPS协议多次握手，导致页面的加载时间延长近50%；
- HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
- 申请SSL证书需要钱，功能越强大的证书费用越高。
- SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

#### Web安全
<https://developer.mozilla.org/zh-CN/docs/Web/Security>[web安全]
##### 同源策略
同源策略是指在Web浏览器中，允许某个网页脚本访问另一个网页的数据，但前提是这两个网页必须有相同的URI、主机名和端口号，一旦两个网站满足上述条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一网页上的敏感数据。

同源策略对Web应用程序具有特殊意义，因为Web应用程序广泛依赖于HTTP cookie[1]来维持用户会话，所以必须将不相关网站严格分隔，以防止丢失数据泄露。

> 可以使用 CORS 来允许跨源访问。CORS 是 HTTP 的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。

##### CORS
Cross-Origin Resource Sharing（CORS）是一种基于HTTP-header的机制，
> 服务器上的 CORS 配置可以精细地指定允许跨域访问的条件
允许服务器指示浏览器应该允许从中加载资源的任何其他源（域、方案或端口）。CORS还依赖于一种机制，通过这种机制，浏览器向承载跨源资源的服务器发出“飞行前”请求，以检查服务器是否允许实际请求。在该预飞行中，浏览器发送指示HTTP方法的标头和将在实际请求中使用的标头。



##### XSS
跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。

防御：
- 过滤特殊字符
- 使用HTTP头指定类型， 使得输出的内容避免被作为HTML解析


##### CSRF
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。[1] 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：`简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。`

防御：
- 令牌同步模式
- 检查Referer字段
- 添加校验token

### 正则


# Database
https://www.pdai.tech/md/db/sql/sql-db-theory.html#3-%e9%9a%94%e7%a6%bb%e6%80%a7isolation

### MyISAM与InnoDB区别

#### ACID
1. 原子性(Atomicity) 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 
2. 一致性(Consistency) 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 
3. 隔离性(Isolation) 一个事务所做的修改在最终提交以前，对其它事务是不可见的。 
4. 持久性(Durability) 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。 可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。

#### MySQL事务的实现
MySQL的事务的四个特性（ACID），是通过InnoDB日志和锁来保证的。

事务的隔离性是通过数据库锁的机制实现。
事务的持久性是通过Redo Log来实现。
事务的原子性和一致性是通过Undo Log实现的。

实现过程：

- 在操作任务数据之前，首先将数据备份到Undo Log中，然后再进行数据的修改操作；
- 出现错误时执行Roll Back，系统可以利用Undo Log恢复到事务开始之前的状态。
- Redo Log是记录新数据的备份，事务提交之前，只将Redo Log持久化即可。
- 系统崩溃时，数据库未持久化，但Redo Log已经持久化，系统可以根据Redo Log将数据恢复并提交。

#### 多版本并发控制(MVCC)
事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作

在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会`访问版本链中的记录`的过程。
这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

说完了undo log我们再来看看ReadView。已提交读和可重复读的区别就在于它们生成ReadView的策略不同

也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

> redo log叫做重做日志，是用来实现事务的持久性。

该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。

> undo log 叫做回滚日志，用于记录数据被修改前的信息。

他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。

#### 隔离级别
未提交读: 脏读，不可重复读，幻读 
已提交读: 不可重复读， 幻读 （Oracle级别）
可重复读: 幻读 （InnoDB级别）
可串行: 无 

- 脏读： T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

- 不可重复读：事物T1多次读同一数据，期间其他事务修改该数据并提交，导致多次读取结果不一样

- 幻读: T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

#### 索引
> 设置了索引会加大增删改成本，因为对应的树也要进行调整，但在仅查询的情况下并没有成本。

##### B+索引和hash索引
hash等值查询快但无法进行范围查询，不稳定，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

hash不能模糊查询，无法避免回表查询。


##### 聚簇索引
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据

非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

##### B+ tree
B+树其实和B树是非常相似的，我们首先看看相同点。
- 根节点至少一个元素
- 非根节点元素范围：m/2 <= k <= m-1

不同点：

B+树有两种类型的节点：
内部结点（也称索引结点）和叶子结点。

- B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加。
- B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
- B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。（顺序查询—）

##### B+ tree 与 红黑树
红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因: 

1. 更少的查找次数 平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。 

2. 利用计算机预读特性 为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。 操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。 

##### 索引优化
##### 索引的优点
- 索引的使用场景 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。 

- 对于中到大型的表，索引就非常有效。 

- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

#### 索引优化

#### 高并发的数据库设计
1. 单库
2. 分库 -》 1. 流量分摊算法 2. 数据库同步
3. 读写分离 -》 slave库做查询，主库做写入，主库写入后同步到slave库


## 编译原理

#### 编译流程
<https://juejin.im/post/6844903857084956680>
#### 


## 设计模式
### 依赖，聚合，组合
#### 依赖
```java
public class Pen {
    public void write(){
        System.out.println("use pen to write");
    }
}

public class Me {
    public void write(Pen pen){//这里，pen作为Me类方法的参数
        pen.write();
    }
}
```
#### 聚合

聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。

聚合关系中
```java
public class Family {
    private List<Child> children; //一个家庭里有许多孩子

    // ...
}

```


#### 组合
组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时间共享同一个部件。
```java
public class Nose {
    private Eye eye = new Eye();  //一个人有鼻子有眼睛
    private Nose nose = new Nose();

    // .... 
}
```


### 单例
[设计模式](https://www.pdai.tech/md/dev-spec/pattern/2_singleton.html)

1、单例类只能有一个实例。
2、单例类必须自己创建自己的唯一实例。
3、单例类必须给所有其他对象提供这一实例。

#### 单例模式实现
##### lazy，线程不安全
```java
public class Singleton{
    private static Singleton instance;

    private Singleton(){}

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }
}
```
##### hunger，线程安全
```java
public class Singleton{
    private static Singleton instance = new Singleton();

    private Singleton(){}

    public static Singleton getInstance(){

        return instance;
    }
}
```
##### lazy，线程安全
```java
public class Singleton{
    private static Singleton instance;

    private Singleton(){}
    // note， 这是一个类锁，所以所有创建线程都共享这把锁
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }
}
```
##### lazy，双重校验锁
第一个if判断避免了其他无用线程竞争锁来造成性能浪费，第二个if判断能拦截除第一个获得对象锁线程以外的线程。

```java
public class Singleton{
    private static volatile Singleton instance;

    private volatile Singleton(){}

    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }

        return instance;
    }
}


public Class Singleton {
  private static volatile Singleton instance;

  public Singleton() {}

  public static Singleton getInstance() {
    if(instance == null) {
      synchronized(Singleton.class) {
        if(instance == null) {
          instance = new Singleton();
        }
      }
    }
  }
}
```

### 工厂
```java
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

### 抽象工厂
```java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape) ;
}
```
```java
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
```

```java
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}
```

# JVM
### 堆内存和堆内存
堆栈是线性数据结构，而堆是层次结构的数据结构。堆栈内存永远不会变得碎片化，而堆内存可能会随着内存块的首次分配和释放而变得碎片化。堆栈只访问局部变量，而堆允许全局访问变量。

### 数据结构的堆
<https://juejin.cn/post/6844903508555071496>

### 内存模型
#### 程序计数器（private）
字节码解释器通过改变这个计数器的值来选择下一条需要执行的字节码指令

唯一没有规定任何`OutOfMemoryError`的内存区域

#### 虚拟机栈（private）
虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，生命周期与线程相同。

一个栈帧对应一个Java（字节码）方法，存储局部变量表，操作数栈，动态链接，方法出口。

局部变量表存放 编译期可知的：
- 基本数据类型
- 对象引用

会抛出`OutOfMemoryError`和`StackOverflowError`异常。

#### 本地方法栈（private）
与虚拟机栈类似，本地方法栈为虚拟机使用Native方法服务。

会抛出`OutOfMemoryError`和`StackOverflowError`异常。


#### Java堆（shared）
最大的内存区域，唯一作用：存放对象实例（所有的对象实例和数组）

是GC的主要区域，故也叫做GC堆， 根据`分代算法`， 也可细分为：
- 新生代
- 老年代

或者更细分：
- Eden （新生代）
- From Survivor （新生代）
- To Survivor （老年代）

会抛出`OutOfMemoryError`异常， 在 当前堆没有内存进行实例分配 且 堆也无法再扩展 时。 

#### 方法区（shared）
存储 虚拟机 加载的：
- 类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

如果视作Java堆的一部分，可以叫做`永久代`，因为一般不考虑回收该区域。

抛出`OutOfMemoryError`异常。

##### 运行时常量池
是方法区的一部分，存在于Class文件中，存放编译期生成的各种 字面量 和 符号引用。


#### OutOfMemoryError 和 StackOverflowError
StackOverflowError： 如果线程请求的栈深度大于虚拟机允许的深度，将抛出该异常。
OutOfMemoryError：大部分虚拟机允许动态扩展，当扩展时无法申请到足够内存，抛出该异常。

这两种异常存在重叠：当栈空间无法继续分配时，是因为内存太小，还是已使用的栈空间太大。



### GC机制

#### 判断对象死亡
1. 引用计数法： 给对象添加引用计数，每当有地方引用，计数器加一，当引用失效，计数器减一，计数器为0的对象判定不可能再使用。
2. 可达性算法（JVM采用）

##### 可达性算法
通过一系列称为“GC roots”的对象作为起点，从这些起点向下搜索，搜索所走过的路径称为引用链。

可作为“GC roots”的对象：
1. 虚拟机栈中引用的对象。
2. 本地方法栈中引用的对象。
3. 方法区中 类静态属性引用的 对象。
4. 方法区中常量引用的对象。

> 当一个对象到“GC roots”没有任何引用链相连时，证明对象不可用

#### finalize()方法
当一个对象被判定 不可达，并非代表它已经死亡。

首先进行第一次标记，然后进行筛选（是否有必要执行finalize()方法）

如果认为有必要， 将对象放置进 `F-Queue`，并在稍后由一个虚拟机创建的低优先级的Finalizer线程来执行finalize()方法。

finalize()是对象逃脱死亡命运的最后一次机会，在GC进行第二次标记前对象只要能和引用链上任何一个对象建立关联，那么在第二次标记时他会被移出 待回收 的集合，否则便进行回收，对象正式死亡。

### GC算法
#### 标记-清除算法
标记所有要回收的对象，在标记完成后统一回收所有被标记的对象。

不足：
1. 效率低下。
2. 清除后剩下大量不连续的内存碎片，会影响以后需要分配大对象时无法找到足够连续内存而 频繁出发GC。

#### 复制算法
将可用内存等分为两块，每次只使用一块，当一块内存快用完了，将存活的所有对象复制到另一块（在原内存无序，新内存上有序，这是优点），然后清理所有原内存。

因为在新内存分配时是顺序分配，解决了碎片问题，但相应可使用内存空间变小了。

##### Eden and Survivor
取代等分，以8:1:1进行分配， 每次使用一块Eden和一块Survivor， 另一块Survivor作为To Survivor来存放存活对象。

#### 标记-整理算法
针对存活率高的老年代，先标记要清理的对象，然后让存活对象向一端移动，然后清理边界以外内存。

#### 分代收集
新生代： 复制算法（只有少部分存活需要复制）
老年代：标记-清除或者标记-整理

#### 垃圾收集器分类
<https://cloud.tencent.com/developer/article/1592943>

### 内存分配与回收策略
#### 对象优先在Eden分配
#### Minor GC and Full GC
1. Minor GC: 发生在新生代的GC，频繁而高速， Eden区不够时发生。
2. Full GC: 发生在老年代的GC， 

#### 大对象直接进入老年代
大对象： 需要大量连续内存的对象，例如： 长字符串，大数组

#### 晋升到老年代
虚拟机给每个对象维持一个年龄计数器，当对象在Eden出生并成功活过一个Minor GC进入From Survivor，年龄记为1，
之后每熬过一个Minor GC，年龄+1，当年龄超过设定值（default=15）将其晋升到老年代。

#### 动态年龄判断
当From Survivor中 相同年龄 对象的总和 达到From Survivor的一半时，即是没有到晋升年龄，年龄大于等于该年龄的所有对象也可全部进入老年代。

#### 空间分配担保

### 类加载

#### JAVA创建一个对象的过程
1. JVM去方法区寻找Test类的代码信息，如果有直接调用，没有的话使用类的加载机制把类加载进来.
2. 加载类，静态变量、静态方法、常量
3. person，person在main方法内部，因而是局部变量，存放在栈空间中。
4. new Person()。new出的对象（实例），存放在堆空间中。
5. jvm接下来看到了“=”，把new Person的地址告诉person变量，person通过四字节的地址（十六进制），引用该实例
   
> 类初始化： 类构造器完成类初始化（分配内存、赋予默认值）
> 类实例化：

#### 流程
加载 -> 验证 -> 准备 -> 解析 -> 初始化

其中：验证， 准备， 解析 也叫连接

##### 加载
虚拟机完成：
1. 通过一个类的全限定名来获取 定义此类 的二进制字节流。
2. 将这个字节流所代表的的 静态存储结构 转化为 方法区的 运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

##### 验证
确保Class文件中的字节流中 包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

##### 准备
正式为 类变量（被static修饰的变量） 分配内存并设置类变量初始值的阶段，这些变量使用所使用的内存都将在方法区中进行分配。

该阶段仅分配类变量，实例变量将会在对象实例化的时候随对象一起分配在Java堆中。

##### 解析
虚拟机将常量池内的符号引用替换为直接引用的过程。

###### 符号引用
以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标。

###### 直接引用
直接指向目标的指针，相对偏移量或者一个能间接定位的句柄。

##### 初始化
开始执行 类中 定义的Java程序代码（字节码）

#### 类加载器
类加载器虽然只用于实现类的加载动作，但其作用还包含：
> 任意一个类，需要由 其本身 和 其类加载器来 确定 唯一性。

每一个类加载器都拥有一个独立的 类名称空间， 即比较两个类是否相等，只有在他们都由同一个类加载器加载的前提下 才有讨论意义。

#### 双亲委派模型
> 当一个类加载器收到了类加载请求，他首先把请求委派给父类加载器，对每一个层次的类加载器都如是，因此所有加载请求最终都应该 传递到 顶层的启动类加载器。只有当父类加载器反馈自己无法完成加载请求（在其搜索范围内没有找到所需类），子加载器才会尝试自己加载。 

> 好处在于Java类随其加载器一起具备了一种带有优先级的层次关系。

JVM中只存在两种类加载器：
1. 启动类加载器： 是JVM的一部分。
2. 其他类加载器：独立于JVM外部。

更加细分：
1. 启动类加载器
2. 扩展类加载器
3. 应用程序加载器

在双亲委派模型要求，除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。

这里类加载器间的父子关系一般是以`组合`的关系来复用父加载器的代码，而非`继承`。

# Spring
### AOP
Java在面向对象的世界里无限风光，oop成就了无数经典的软件，它让我们的软件更健壮，更易于维护。

但是程序猿对软件的质量追求是永无止境的，oop对于业务的抽象和封装完美的无懈可击然而对于系统层面的一些需求比如系统日志，性能统计等，分散在软件的各个角落，维护起来很是不爽，这种问题的解决确是oop力所不能及的，于是AOP横空出世。

先来看一个简单的小例子，体会一下AOP能解决什么问题：如果我们要在A,B,C三个类的do方法中都加入日志功能定义一个日志类Record，加日志的方法：

```java
Public class A{
    Public void do(){
        …
        Record.addRecord();//添加日志
    }
}

Public class B{
    Public void do(){
        …
        Record.addRecord();//添加日志
    }
}
Public class C{
    Public void do(){
        …
        Record.addRecord();//添加日志
    }
}
```


这样做可以解决问题，但是总感觉有些别扭，每个类的do方法中都调用了添加日志的方法，添加日志的方法不是我们的核心业务，我们却要去处理它随着系统越来越完善，类似这样的非核心业务也会越来越多，比如`权限，异常处理，性能监控`等这样的功能出现在很多类的很多方法中干扰了我们的核心业务代码，怎么解决呢？AOP就是为此而生.


对于日志记录，性能监控，异常处理这样的非核心功能，单独被抽取出来，与业务代码分离，横切在核心业务代码之上这就是我们通常所说的面向切面编程(AOP),通过一个例子看看他是如何实现的创建一个UserDao类：

```java
@Repository
public class UserDao {
     public void addUser(){
        System.out.println("添加用户");
    }
    public void updateUser(){
        System.out.println("修改用户");
    }
    public void deleteUser(){
        System.out.println("删除用户");
    }
}
```

创建一个切面类
```java
@Aspect
public class MyAspectLog {
    /**
     * 方法执行完后执行的方法
     */

@After(value="execution(* cn.xh.dao.UserDao.addUser(..))")
    public void log(){
        System.out.println("记录日志");
    }
}
在spring配置文件中加入：
<!-- 启动@aspectj的自动代理支持-->
    <aop:aspectj-autoproxy />
 
    <!-- 定义aspect类 -->
    <bean name="myAspect" class="cn.xh.dao. MyAspectLog "/>
```

当我们创建UserDao的对象userDao调用addUser方法的时候会打印“添加用户”，“记录日志”很神奇吧,究竟发生了什么？明明addUser方法里面只有打印”添加用户”啊这就是Spring AOP的强大之处，在运行时通过动态代理技术对UserDao的addUser方法进行了增强，添加了记录日志的功能。动态代理其实就是在运行时动态的生成目标对象的代理对象，在代理对象中对目标对象的方法进行增强，关于动态代理技术我会在另一篇文章中详细介绍，现在先来看一下AOP中几个重要的概念：


# Pending

## 本地缓存
在后端开发中，本地缓存指的是将数据 ***暂时存储在应用程序运行的服务器或服务的内存*** 中，以便在后续请求中更快地获取这些数据，而无需再次访问数据库或其他远程数据源。
本地缓存通常是一种提高系统性能和减少响应时间的有效手段。

常见场景：
- 数据库查询结果缓存
- 第三方 API 调用结果缓存
- 昂贵计算结果缓存
- 用户会话期间， 用户特定的数据，如用户权限、配置等缓存在本地

挑战：
- 缓存一致性
- 缓存过期策略
- 缓存失效

### Java技术栈实践
一般来说，`Guava Cache` 和 `Caffeine` 是本地缓存的两个流行选择。

#### Caffeine
Caffeine 是一个基于 Java 8 的高性能本地缓存库。它在性能上优于 Guava Cache，并提供了一些额外的功能。
Caffeine 支持:
- 过期时间
- 定时刷新
- 异步加载等特性。

```java
Caffeine<Object, Object> caffeineCache = Caffeine.newBuilder()
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .maximumSize(1000)
    .build();
```

## 分布式缓存
将缓存数据存储在多个节点上的缓存系统，以提供更大容量和更高性能。

`Redis` 、 `Memcached` 等，它们支持在多个服务器之间分布数据，以满足大规模应用程序的缓存需求

### 为什么需要分布式缓存

当我们讨论分布式时，最多讨论的场景是多个缓存节点和多个服务实例。

多个服务实例访问外部缓存是为了：
- ***数据共享***：确保不同应用实例可以访问相同的缓存数据。而 `Redis` 这样的外部缓存存在机制来管理全局的缓存，确保`缓存的一致性和有效性`


本身多节点的外部缓存结构提供了：
- ***水平扩展***：分布式缓存可以随着系统需求的增长而水平扩展，允许添加新的缓存节点以处理更多的请求负载。这种能力使得系统更容易扩展以适应不断增长的用户和数据量。
- ***高可用性***：在分布式系统中，如果某个节点出现故障，分布式缓存可以提供高可用性，确保系统仍然能够访问可用的缓存数据。通过数据的复制和分散存储在多个节点，可以提高系统的鲁棒性。
- ***支持事务和一致性***：一些分布式缓存系统提供了支持事务的特性，确保多个操作的原子性和一致性。这对于需要对缓存数据进行复杂操作或者保持数据一致性的场景非常有用。

#### 关于 Redis 的事务

Redis 提供了一种轻量级的事务支持，称为 `MULTI/EXEC` 事务模型。

Redis 的事务是 ***基于乐观锁*** 的，它不提供`隔离性`和`回滚`功能。

在 Redis 中，事务使用以下命令实现：
- ***MULTI*** ： 开启事务。之后的命令都会被放入一个队列中，但不会立即执行。

- ***EXEC***： 执行事务队列中的所有命令。如果在  EXEC 执行之前发生错误，整个事务将回滚。

- ***DISCARD*** ： 取消事务，清空事务队列中的所有命令。

- ***WATCH*** ： 监视一个或多个键，当这些键被其他客户端修改时，事务将被中断。


## 缓存优化
### 缓存穿透和雪崩处理
实践： 针对缓存穿透（大量请求查询不存在的数据）和雪崩（缓存同时失效导致大量请求直接落到数据库上）问题：
- 可以使用布隆过滤器等机制防止缓存穿透
- 同时设置随机的缓存失效时间或使用二级缓存来防止雪崩效应。

#### 二级缓存（Secondary Cache）
二级缓存（Secondary Cache）通常指的是在应用程序内部的第二层缓存，其主要目的是在一级缓存（通常是本地缓存）未命中时，尝试从这个更大容量的、更慢速的缓存中获取数据。
这个缓存可以是分布式缓存，也可以是其他类型的缓存，例如数据库缓存。

应对 ***雪崩效应*** 时，使用二级缓存的一种常见方式是在缓存失效时间上 ***引入一些随机性***。
这意味着在设置缓存失效时间时，给每个缓存条目添加一个小的随机偏移，以便它们不会同时失效。
这样，即使有大量的缓存同时过期，由于存在随机性，请求并不会在同一时刻落到数据库上，减轻了数据库的负载。

需要注意的是，使用二级缓存时，***需要权衡缓存的一致性和性能***。
在某些场景下，可能 ***需要使用一些缓存同步机制***，以确保数据的一致性。
另外，二级缓存的选择应该考虑到数据更新的频率以及缓存的命中率等因素。

### 使用适当的缓存策略
根据应用场景选择合适的缓存策略，比如先进先出（FIFO）、最近最少使用（LRU）等。
合理选择缓存策略可以提高缓存命中率，减少缓存的不命中。todeep

### 使用适当的过期策略
根据数据的特性和业务需求，设置合理的缓存过期时间。
对于 ***静态数据***，可以设置较长的过期时间。
对于 ***频繁变动的数据***，可以设置较短的过期时间，以确保缓存中的数据始终是有效的。todeep

### 使用分布式锁
在缓存失效时，多个请求同时访问数据库可能导致缓存击穿问题。
使用分布式锁（如 Redis 分布式锁）来确保只有一个请求去更新缓存，其他请求等待。todeep

### 分层缓存：
使用多层缓存，将热点数据放置在快速存储介质（如内存）中，而冷数据可以存储在相对慢一些的介质中。
例如，使用本地缓存、分布式缓存（如 Redis）以及 CDN 等。

### 数据预热
在系统启动时，提前加载一些核心数据到缓存中，避免冷启动时大量请求落到数据库上。
这可以通过定时任务或系统初始化阶段实现。