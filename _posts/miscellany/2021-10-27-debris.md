
---
title: Debris
categories: Miscellany
tags:
- Miscellany
---

- [1](#1)
  - [关于语言和编译](#关于语言和编译)
    - [脚本文件是什么，是.sh类型的文件吗](#脚本文件是什么是sh类型的文件吗)
    - [我能将二进制文件理解成可执行程序吗，就是windows系统中常见的.exe类型文件](#我能将二进制文件理解成可执行程序吗就是windows系统中常见的exe类型文件)
    - [python，c++，rust都可以打包二进制文件，但java我好像很少看到打包二进制文件，多数是jar包和war包，这是为什么?](#pythoncrust都可以打包二进制文件但java我好像很少看到打包二进制文件多数是jar包和war包这是为什么)
    - [打包成二进制文件需要考虑实际运行该文件的环境，这意味着同一份代码由于多平台部署的需求需要打包成多份二进制文件？](#打包成二进制文件需要考虑实际运行该文件的环境这意味着同一份代码由于多平台部署的需求需要打包成多份二进制文件)
    - [在JVM上运行jar文件和在平台上直接运行二进制文件有什么区别呢](#在jvm上运行jar文件和在平台上直接运行二进制文件有什么区别呢)
    - [在静态编译这一部分，Go和Java的区别是什么](#在静态编译这一部分go和java的区别是什么)
    - [Go将所有使用的外部库直接编译到了二进制文件中。而Java是只将自己编写的代码编译成字节码，然后和依赖的外部库一起打包成jar文件？](#go将所有使用的外部库直接编译到了二进制文件中而java是只将自己编写的代码编译成字节码然后和依赖的外部库一起打包成jar文件)
  - [DevOps](#devops)



# 1
## 关于语言和编译

### 脚本文件是什么，是.sh类型的文件吗
->
脚本文件是一种包含可执行代码的文本文件，通常用于自动化任务、执行一系列操作或程序。脚本文件可以使用不同的编程语言编写，而不限于特定的文件扩展名。常见的脚本文件类型包括：

Bash 脚本文件（.sh）：这些文件使用Bash编程语言编写，通常用于在Unix/Linux操作系统中执行命令和自动化任务。它们通常以.sh为文件扩展名。

Python 脚本文件（.py）：Python脚本文件包含Python编程语言的代码，用于执行各种任务，从数据处理到网络编程等。它们通常以.py为文件扩展名。

Perl 脚本文件（.pl）：Perl是另一种常用的脚本语言，用于文本处理和系统管理。Perl脚本文件通常以.pl为文件扩展名。

PowerShell 脚本文件（.ps1）：PowerShell是Windows操作系统中的脚本语言，用于自动化系统管理任务。PowerShell脚本文件通常以.ps1为文件扩展名。

Shell 脚本文件（无特定扩展名）：在Unix/Linux系统中，你也可以创建没有特定扩展名的shell脚本文件，只要文件中的代码以正确的shell语法编写。

### 我能将二进制文件理解成可执行程序吗，就是windows系统中常见的.exe类型文件
->
是的，你可以将二进制文件理解为可执行程序。在计算机术语中，"二进制文件"通常指的是包含机器码的文件，它可以在计算机上直接执行。这些二进制文件通常被称为可执行文件，而在Windows操作系统中，通常具有.exe文件扩展名。

可执行文件包含了计算机可以直接执行的二进制指令，通常用于运行应用程序、脚本或程序。这些文件可以在不需要编译或解释的情况下直接运行。在Windows系统中，.exe文件是最常见的可执行文件类型，但其他操作系统也有自己的可执行文件格式，例如Linux上的 ELF 文件。

因此，当你将代码打包成二进制文件时，你实际上是将代码编译成一种可执行程序，这个程序可以在相应的操作系统上运行，而无需安装额外的解释器或编译器。

- Python作为脚本语言也能用做可执行程序开发吗?
->
是的，Python不仅可以用作脚本语言执行一系列任务，还可以用于开发可执行的独立应用程序。Python提供了多种方法来将Python脚本转换为可执行程序，使其适合分发给其他用户而无需安装Python解释器。

你可以在Python脚本的开头添加一个特殊的注释（称为shebang或hashbang），然后将脚本文件设置为可执行。这使得你可以在终端中直接运行脚本，就像运行可执行程序一样。例如，在Unix/Linux系统中，你可以添加如下注释：
```py
#!/usr/bin/env python
```

然后，通过使用chmod命令将脚本文件设置为可执行：

```bash
chmod +x your_script.py
```
然后，你可以通过./your_script.py来执行它。

打包为独立的二进制文件：你还可以使用工具如Py2App（用于macOS）、py2exe（用于Windows）等，将Python代码打包为本机二进制文件，以便在不需要Python解释器的情况下运行。这些工具将你的应用程序和Python解释器一起打包成一个单独的二进制文件。


### python，c++，rust都可以打包二进制文件，但java我好像很少看到打包二进制文件，多数是jar包和war包，这是为什么?
->
Java通常不直接打包为独立的二进制文件，而更常见的是使用JAR文件或WAR文件进行分发。这是由于Java的执行方式和其他编程语言（如Python、C++、Rust等）有很大的不同。以下是一些原因解释为什么Java通常使用JAR文件和WAR文件：
  - Java虚拟机 (JVM) 的跨平台性: Java是一种编译成字节码的语言，而不是本机机器码。这使得Java程序能够在不同操作系统上运行，只要有适用的Java虚拟机（JVM）。由于字节码是平台无关的，Java程序可以在不同操作系统上执行，而不需要重新编译。这种特性导致了Java应用程序更多地依赖于JVM，而不是本机二进制文件。
  
  - Java类库和依赖: Java应用程序通常依赖于大量的Java类库和第三方依赖。将所有这些依赖项打包到单个独立二进制文件中会使文件变得非常大。因此，Java开发者更倾向于将Java类库和依赖项打包到JAR文件中，以便在不同项目中重复使用。这有助于减小应用程序的体积并简化维护。
  
  - JVM性能和优化: Java应用程序在运行时由JVM执行。JVM可以进行各种性能优化，如即时编译（Just-In-Time Compilation）和垃圾回收等。这些优化在运行时执行，而不是在编译时，这意味着将Java程序打包成本机二进制文件可能无法充分利用JVM的性能优势。
  
  - 模块化系统: Java 9及更高版本引入了Java平台模块系统（JPMS），使Java程序更容易进行模块化开发和管理。这使得Java应用程序更依赖于JAR文件，以支持模块化。

虽然Java本身不常见地打包为独立的二进制文件，但可以使用工具如GraalVM和Excelsior JET来将Java应用程序编译为本机二进制文件。这些工具可以将Java程序转换为本机可执行文件，但在实践中，JAR文件和WAR文件仍然是更常见的分发方式，因为它们更具灵活性，便于跨平台部署和维护。


### 打包成二进制文件需要考虑实际运行该文件的环境，这意味着同一份代码由于多平台部署的需求需要打包成多份二进制文件？
->
是的，将代码打包成二进制文件时需要考虑目标平台的环境，这意味着同一份代码可能需要为不同的平台生成多份二进制文件。这是因为不同的操作系统和硬件架构可能需要不同的二进制格式和依赖项。

下面是一些需要考虑的因素：

  - 操作系统：不同的操作系统（如Windows、Linux、macOS等）使用不同的二进制格式和系统调用。因此，你需要为每个目标操作系统生成相应的二进制文件。

  - 硬件架构：不同的硬件架构（如x86、x86-64、ARM等）也可能需要不同的二进制文件，因为它们使用不同的指令集。

  - 依赖项：你的应用程序可能依赖于特定的库或资源，这些库或资源在不同平台上可能不同。因此，你需要确保生成的二进制文件包含了适当版本的依赖项。

  - 系统配置：不同的操作系统和环境可能具有不同的系统配置和设置，这些配置可能会影响你的应用程序的行为。你需要确保你的二进制文件能够适应这些不同的配置。

为了解决这些问题，通常使用跨平台开发工具和技术，以便更容易地生成适用于多个平台的二进制文件。例如，Java的可移植性部分归功于Java虚拟机（JVM），它提供了跨平台的运行时环境。

对于某些编程语言，还可以使用`交叉编译器`，这些工具可以帮助你在一种平台上生成另一种平台的可执行文件。然而，尽管有这些工具，仍然需要考虑平台差异，确保生成的二进制文件在目标环境中正常运行。

### 在JVM上运行jar文件和在平台上直接运行二进制文件有什么区别呢
- Java虚拟机 (JVM) 抽象层: Java程序在JVM上运行，这意味着它们在一个虚拟的执行环境中执行，而不是在硬件上直接执行。这个抽象层允许Java程序在不同平台上运行，因为JVM会处理底层硬件和操作系统的差异。直接运行二进制文件通常涉及与特定硬件和操作系统的直接交互。

- 字节码执行: `Java源代码被编译成字节码，而不是本机机器码`。这些字节码在JVM上执行。`与本机机器码相比，字节码执行通常更慢`，因为它需要解释字节码并将其转换为本机机器码。相比之下，直接运行的本机二进制文件通常不需要这个解释步骤，因此可能更快。

- 即时编译 (Just-In-Time Compilation): JVM通常使用即时编译器（Just-In-Time Compiler，JIT）来将字节码编译成本机机器码，以提高性能。即时编译可以在程序运行时进行，将热点代码编译为本机机器码，从而提高执行速度。直接运行的本机二进制文件通常不使用`JIT编译`。
  
- 垃圾回收 (Garbage Collection): Java程序通常依赖于垃圾回收来自动管理内存。这会引入一些内存管理开销，并且可能导致不可预测的垃圾回收停顿。直接运行的本机二进制文件通常不需要垃圾回收，因为它们可以手动管理内存。

- 依赖项管理: Java程序通常依赖于JAR文件，这些JAR文件包含了程序的类和依赖项。在运行Java程序之前，需要确保这些依赖项可用。直接运行的本机二进制文件通常不需要这种依赖项管理，因为`它们可能包含了所有必要的依赖项`。

### 在静态编译这一部分，Go和Java的区别是什么
- Go的静态编译：
  Go是一门静态编译语言，这意味着Go程序在编译时将所有依赖项（包括标准库和自定义库）编译到可执行文件中。这包括静态链接所需的所有库，使得可执行文件相对较小，且独立于外部库。

  Go程序不依赖于虚拟机或运行时环境，因此可执行文件可以直接运行在目标计算机上，无需安装额外的依赖项。
  
  Go编译器生成与目标操作系统和硬件架构相关的本机机器码，因此Go可执行文件通常非常紧凑和高效。

- Java的静态编译：

  Java是一门`半静态、半动态`编译的语言。Java代码首先编译成字节码，然后在Java虚拟机（JVM）上运行。字节码是一个中间表示，它与特定操作系统和硬件无关。
  
  Java程序通常打包为JAR文件，其中包含了程序的字节码以及依赖的类库。这使得Java程序在不同平台上运行，但也导致JAR文件相对较大，因为它需要包含字节码和依赖库。
  
  Java程序依赖于JVM运行时环境，因此目标计算机上必须安装Java虚拟机才能运行Java程序。


### Go将所有使用的外部库直接编译到了二进制文件中。而Java是只将自己编写的代码编译成字节码，然后和依赖的外部库一起打包成jar文件？
你的理解是正确的。你描述的区别是准确的：

- Go：Go在编译时将所有使用的外部库（包括标准库和自定义库）直接编译到可执行文件中。这意味着生成的可执行文件是独立的，无需外部依赖，因为所有依赖项都已经包含在可执行文件中。

- Java：Java在编译时将自己编写的代码编译成字节码，而依赖的外部库（包括标准库）通常以JAR文件的形式打包在一起。这些依赖项需要在运行时通过Java虚拟机（JVM）加载。这意味着生成的JAR文件包含了字节码以及依赖库，但不是一个独立的可执行文件，它需要JVM来运行。

## DevOps
