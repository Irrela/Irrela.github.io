---
title: U3D
categories: GameDev
tags:
- GameDev
---

- [DCC](#dcc)
      - [3D 资源获取](#3d-资源获取)
      - [2D 资源](#2d-资源)
      - [音频资源获取](#音频资源获取)
    - [Audio](#audio)
        - [3D 音效](#3d-音效)
  - [2D](#2d)
      - [Layer](#layer)
      - [固定](#固定)
- [Junior Programmer](#junior-programmer)
  - [Mod the Cube (纯脚本设置参数)](#mod-the-cube-纯脚本设置参数)
  - [Personal Project](#personal-project)
      - [primitive](#primitive)
      - [camera视角的常用实践](#camera视角的常用实践)
      - [同时调节scale](#同时调节scale)
      - [保存项目，打包备份](#保存项目打包备份)
      - [GetKey和GetKeyDown](#getkey和getkeydown)
      - [Prefab override](#prefab-override)
      - [InvokeRepeating](#invokerepeating)
  - [UI](#ui)
      - [Render mode](#render-mode)
  - [Collider](#collider)
      - [is Trigger](#is-trigger)
  - [Transform](#transform)
      - [Translate and Rotate](#translate-and-rotate)
      - [Scene操作](#scene操作)
      - [Camera Projection](#camera-projection)
      - [LateUpdate() 和 Update()](#lateupdate-和-update)
      - [InvokeRepeating](#invokerepeating-1)
      - [玩家控制输入](#玩家控制输入)
      - [边界限制](#边界限制)
- [项目 \& 团队](#项目--团队)
  - [流程](#流程)
      - [游戏设计文档](#游戏设计文档)
      - [生产](#生产)
      - [后期制作](#后期制作)
      - [GDD](#gdd)
      - [偏向agile的项目管理Sample](#偏向agile的项目管理sample)
      - [项目章程 Project Charter](#项目章程-project-charter)
      - [管理项目，项目跟踪器](#管理项目项目跟踪器)
    - [测试](#测试)
      - [错误报告的艺术](#错误报告的艺术)
    - [运营](#运营)
      - [项目回顾](#项目回顾)
    - [prefab](#prefab)


# DCC

#### 3D 资源获取

ProBuilder: 在 Unity 编辑器中创建 3D 艺术和环境。与专用 DCC 相比，Probuilder 的功能有限，但对于想要在不打开外部编辑工具的情况下快速建模 3D 对象的艺术家来说，它很有帮助。  

在线资源: CGTrader, Turbosquid 3D，Unity Asset Store也是专为 Unity 设计的宝贵艺术资源。

#### 2D 资源
Unity 具有专门为处理 2D 资源而设计的内置工具。例如，`2D Tilemap Editor` 可帮助快速设计 2D 关卡，
而`Sprite Editor`则可管理进入 2D 动画的各种图像（“Sprite”）。有专门用于2D 物理、2D 灯光等的系统。


#### 音频资源获取
音频数字创作工具 (DCC)，例如Audition、Logic Pro、Reaper和Audacity


### Audio
##### 3D 音效
Audio source => spatial blend
https://learn.unity.com/tutorial/create-real-time-3d-audio-effects?uv=2021.3&pathwayId=5f7bcab4edbc2a0023e9c38f&missionId=5f777d9bedbc2a001f6f5ec7&projectId=5faab859edbc2a00209536ce#


# 教程项目

## Junior Programmer

#### CWC 1 Unit 1 - Player Control

1. asset导入：从Unity的顶部菜单中，选择`Assets > Import Package > Custom Package`, 选择unitypackage
2. Obj聚焦：`press F` to focus on it
3. 按住 `Ctrl/Cmd` 以整单位移动相机
4. 布局：在右上角，选layout 或 自定义layout保存


#### CWC 1 Unit 2 - Basic Gameplay
1. 选择 Material, 拖拽到obj以apply

2. 获取用户的水平输入

```cs
public float horizo​​ntalInput;

void Update() {
    Horizo​​ntalInput = Input.GetAxis(“Horizo​​ntal”) ;
}

```

3. Translate

```cs
    /// <summary>
    ///   <para>Moves the transform in the direction and distance of translation.</para>
    /// </summary>
    /// <param name="translation"></param>
    /// <param name="relativeTo"></param>
    public void Translate(Vector3 translation)
```

4. 保持obj在边界内

```cs
void Update() {
    var currentPosition = transform.position;
    if (currentPosition.x > bound) {
        transform.position = new Vector3(bound, currentPosition.y, currentPosition.z);
    }
}
```


#### Bonus Features 2
[Doc](https://learn.unity.com/tutorial/bonus-features-2-share-your-work#)

#### Challenge 2 - Play Fetch
[Doc](https://learn.unity.com/tutorial/challenge-2-play-fetch-with-random-values-and-arrays#)

1. SpawnManager

2. GameObj destroy

3. Random spawn

4. InvokeRepeating
```cs
    /// <summary>
    ///   <para>Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.</para>
    /// </summary>
    /// <param name="methodName">The name of a method to invoke.</param>
    /// <param name="time">Start invoking after n seconds.</param>
    /// <param name="repeatRate">Repeat every n seconds.</param>
    public void InvokeRepeating(string methodName, float time, float repeatRate)
    {
      if ((double) repeatRate <= 9.999999747378752E-06 && (double) repeatRate != 0.0)
        throw new UnityException("Invoke repeat rate has to be larger than 0.00001F)");
      MonoBehaviour.InvokeDelayed(this, methodName, time, repeatRate);
    }
```

5. CoolDownTime
```cs
using System.Collections;
using UnityEngine;

public class Player : MonoBehaviour
{
    // 冷却时间
    public float cooldownTime = 2f;
    // 上次执行方法的时间
    private float lastExecutionTime = 0f;

    void Update()
    {
        // 在 Update 方法中检查按键输入并调用方法
        if (Input.GetKeyDown(KeyCode.Space))
        {
            // 检查是否已经超过冷却时间
            if (Time.time - lastExecutionTime >= cooldownTime)
            {
                // 调用方法
                MyMethod();

                // 更新上次执行时间为当前时间
                lastExecutionTime = Time.time;
            }
        }
    }

    void MyMethod()
    {
        // 这是你想要添加冷却时间的方法的内容
        Debug.Log("Method executed!");
    }
}
```

#### Bonus Features 2
1. SpawnManager 随机地点随机方向生成

```cs
public class SpawnManager : MonoBehaviour
{
    // 可在Unity编辑器中指定的动物预制体数组
    public GameObject[] animalPrefabs;

    // 饥饿条的Prefab
    public GameObject healthBarPrefab;

    // 场景边界的常量值
    private const float Bound = 30f;

    // 开始生成动物的延迟时间
    private const float StartDelay = 2;

    // 生成动物的时间间隔
    private const float SpawnInterval = 5.0f;

    // 在游戏对象创建时调用，用于初始化
    private void Start()
    {
        // 调用InvokeRepeating方法，在指定的延迟后开始重复执行指定的方法
        // 第一个参数："SpawnRandomAnimal" 是要重复调用的方法的名称（字符串）
        // 第二个参数：startDelay 是延迟开始重复调用的时间（以秒为单位）
        // 第三个参数：spawnInterval 是重复调用的时间间隔（以秒为单位）        
        InvokeRepeating(nameof(SpawnRandomAnimal), StartDelay, SpawnInterval);
    }

    // 每帧调用一次
    private void Update()
    {
    }

    // 生成随机动物的方法
    private void SpawnRandomAnimal()
    {
        // 随机选择一个动物预制体
        int animalIndex = Random.Range(0, animalPrefabs.Length);

        // 计算生成位置
        Vector3 spawnPos = CalculateSpawnPosition();

        // 计算生成的旋转方向
        Quaternion rotation = CalculateRotation(spawnPos);

        // 实例化生成动物
        GameObject newAnimal = Instantiate(animalPrefabs[animalIndex], spawnPos, rotation);
    }

    // 计算生成位置的方法
    private static Vector3 CalculateSpawnPosition()
    {
        // 在场景边界范围内随机生成位置
        var x = Random.Range(-Bound, Bound);
        var z = Random.Range(-Bound, Bound);

        // 随机选择沿着x轴或z轴生成
        var alongX = Random.Range(0, 2) == 0;
        if (alongX)
        {
            z = Bound * (Random.Range(0, 2) == 0 ? 1 : -1);
        }
        else
        {
            x = Bound * (Random.Range(0, 2) == 0 ? 1 : -1);
        }

        return new Vector3(x, 0, z);
    }

    // 计算生成旋转方向的方法
    private static Quaternion CalculateRotation(Vector3 spawnPos)
    {
        // 计算指向场景中心的方向
        var directionToCenter = Vector3.zero - spawnPos;
        // 生成以该方向为前方向的旋转
        var rotation = Quaternion.LookRotation(directionToCenter, Vector3.up);
        return rotation;
    }
}
```

2. GameManager 多个脚本间通信
```cs
public class GameManager : MonoBehaviour
{
    private int score = 0;
    private int lives = 3;
    // Start is called before the first frame update
    void Start() {}

    // Update is called once per frame
    void Update() {}
    
    public void AddLives(int value)
    {
        lives += value;
        if (lives <= 0)
        {
            Debug.Log("Game Over");
            lives = 0;
        }
        Debug.Log("Lives = " + lives);
    }
    
    public void AddScore(int value)
    {
        score += value;
        Debug.Log("Score = " + score);
    }
}
```

在其他脚本中使用gameManager
```cs
public class Other : MonoBehaviour
{
    private GameManager gameManager;
    // Start is called before the first frame update
    void Start()
    {
        gameManager = GameObject.Find("GameManager").GetComponent<GameManager>();
    }
}
```


3. Collider 碰撞, Trigger

- 判断碰撞obj： `CompareTag()`
- obj调用自己的方法： `other.GetComponent<AnimalHunger>().FeedAnimal(1)`

```cs
public class DetectCollisions : MonoBehaviour
{
    private GameManager gameManager;
    // Start is called before the first frame update
    void Start()
    {
        gameManager = GameObject.Find("GameManager").GetComponent<GameManager>();
    }

    // Update is called once per frame
    void Update()
    {

    }

    /// <summary>
    /// 当碰撞器与其他碰撞器发生接触时调用此方法。
    /// </summary>
    /// <param name="other">与该碰撞器发生接触的另一个碰撞器。</param>
    void OnTriggerEnter(Collider other)
    {
        // 检查与碰撞器发生接触的其他对象是否被标记为"Player"
        if (other.CompareTag("Player"))
        {
            // 如果是"Player"对象，则调用GameManager的AddLives方法减少生命值，并销毁GameManager对象
            gameManager.AddLives(-1);
            Destroy(gameManager);
        } 
        // 检查与碰撞器发生接触的其他对象是否被标记为"Animal"
        else if (other.CompareTag("Animal"))
        {
            // 如果是"Animal"对象，则获取AnimalHunger组件，并调用FeedAnimal方法喂养动物，增加游戏分数，并销毁当前游戏对象
            other.GetComponent<AnimalHunger>().FeedAnimal(1);
            gameManager.AddScore(5);
            Destroy(gameObject);
        }
    }
}
```

> !!Note!!: 在Unity中，如果你使用的是物理系统（Physics System），当两个物体发生碰撞或进入触发器时，`至少一个物体需要拥有刚体组件`才能触发碰撞或触发事件。

> 例如，如果你想要在两个物体之间触发碰撞事件，其中一个物体必须拥有刚体组件，而另一个物体可以是一个普通的碰撞器，不需要刚体组件。

>通常来说，将刚体组件添加到动态移动的物体上，而将碰撞器组件添加到静止的物体上是比较常见的做法。


4. 基于UI与prefab的饥饿条

- UI-Slider
- 为animal prefab 添加 slider prefab ： [Doc](https://connect-prd-cdn.unity.com/20210505/70ffeabd-706f-4556-b9a9-ea6bd8ba631a/Unit%202%20-%20Bonus%20Features%20Solutions.pdf?_ga=2.263578828.1186801097.1620052249-59568313.1601905412) 从p32开始看

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class AnimalHunger : MonoBehaviour
{
    public Slider hungerSlider;
    public int amountToBeFed;
    private int currentFedAmount = 0;
    private GameManager gameManager;

    // Start is called before the first frame update
    void Start()
    {
        // 设置饥饿滑块的最大值为要喂养的量
        hungerSlider.maxValue = amountToBeFed;

        // 设置饥饿滑块的最小值为0
        hungerSlider.minValue = 0;

        // 禁用饥饿滑块的填充对象
        // 将对象的活动状态设置为假，即禁用该对象的渲染和碰撞功能。
        hungerSlider.fillRect.gameObject.SetActive(false);

        // 查找名为"GameManager"的游戏对象，并获取其GameManager组件
        gameManager = GameObject.Find("GameManager").GetComponent<GameManager>();
    }


    // Update is called once per frame
    void Update()
    {
    }

    public void FeedAnimal(int amount)
    {
        // 给动物喂食的方法，参数为喂食的数量

        // 增加当前喂食总量
        currentFedAmount += amount;

        // 激活饥饿滑块的填充物体
        hungerSlider.fillRect.gameObject.SetActive(true);

        // 更新饥饿滑块的值
        hungerSlider.value = currentFedAmount;

        // 如果当前喂食总量达到或超过需要喂食的总量
        if (currentFedAmount >= amountToBeFed)
        {
            // 调用游戏管理器的方法，增加分数（传入需要喂食的总量作为参数）
            gameManager.AddScore(amountToBeFed);

            // 销毁当前游戏对象（延迟0.1秒后销毁）
            Destroy(gameObject, 0.1f);
        }
    }
}
```


### Mod the Cube (纯脚本设置参数)

- Transform
- Material opacity


```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Cube : MonoBehaviour
{
    // 渲染器
    public MeshRenderer Renderer;
    // 材质
    private Material _material;
    // 不透明度
    private float _opacity;
    // 不透明度变化方向
    private float _opacityDirection;

    void Start()
    {
        // 设置初始位置
        transform.position = new Vector3(0, 0, 0);
        // 设置初始缩放
        transform.localScale = Vector3.one * 1.3f;
        // 设置初始旋转
        transform.rotation = Quaternion.Euler(Random.Range(0, 360), Random.Range(0, 360), Random.Range(0, 360));

        // 获取渲染器的材质
        _material = Renderer.material;
        // 初始化不透明度
        _opacity = 0f;
        // 初始化不透明度变化方向
        _opacityDirection = 1f;
        // 设置初始颜色和不透明度
        _material.color = new Color(0.5f, 1.0f, 0.3f, _opacity);
    }

    void Update()
    {
        // 设置旋转速度
        var rotateSpeed = Random.Range(0f, 360f);
        // 绕各轴旋转
        transform.Rotate(rotateSpeed * Time.deltaTime, rotateSpeed * Time.deltaTime, rotateSpeed * Time.deltaTime);
        
        // 周期性改变不透明度
        PeriodicalChangeOpacity();
    }

    void PeriodicalChangeOpacity()
    {
        // 根据不透明度的当前值确定不透明度的变化方向
        _opacityDirection = _opacity switch
        {
            // 当不透明度接近 1 时，使其减小
            > 0.9f => -0.0001f,
            // 当不透明度接近 0 时，使其增加
            < 0.1f => 0.0001f,
            // 其他情况不变
            _ => _opacityDirection
        };

        // 根据不透明度变化方向调整不透明度
        _opacity += _opacityDirection;
        // 更新材质的颜色和不透明度
        _material.color = new Color(0.5f, 1.0f, 0.3f, _opacity);
    }
}
```


### Personal Project
#### primitive

#### camera视角的常用实践
- 对于一个自上而下的游戏，将摄像机定位在（0，10，0）正上方，并在X轴上旋转90度

- 对于侧视图游戏，在X轴上旋转平面—90度

- 对于第三人称视角游戏，在Y轴和Z轴向上移动摄像机，并在X轴上增加其旋转

#### 同时调节scale
提示：在Unity的较新版本中，您可以通过切换"启用约束比例"图标，同时设置所有轴上的比例。
[Enabled Constrained Proportions icon](https://unity-connect-prd.storage.googleapis.com/20231214/learn/images/c2f44eba-5971-4f3b-9463-5ca844720e89_image.png)

#### 保存项目，打包备份
- In the Project window, Right-click on the `“Assets” folder > Export Package`, then click Export

- Create a new “Backups” folder in your Personal Project folder, then save it with your name and the version number (e.g. Carl_V0.1.unitypackage”)

#### GetKey和GetKeyDown
Input.GetKey(string keyName)：

这个方法用于检测指定按键是否被按下。
当按键被按下并保持按住时，该方法会持续返回 true。
如果按键没有被按下，则返回 false。
这个方法会在每一帧都检测按键状态。


Input.GetKeyDown(string keyName)：

这个方法用于检测指定按键在当前帧是否被按下。
当按键在当前帧被按下时，该方法返回 true，但是在后续的帧中，即使按键保持按住，也不会再次返回 true。
如果按键在当前帧没有被按下，则返回 false。
这个方法只会在按键按下的那一帧返回 true，而在之后的帧中会返回 false。


举例来说，假设你想要在玩家按下空格键时触发某个动作：

如果你使用 Input.GetKey("space")，那么当玩家按下空格键后，该动作将在每一帧都触发，只要空格键一直被按住。
如果你使用 Input.GetKeyDown("space")，那么该动作将只在玩家按下空格键的那一帧触发，而不管玩家是否保持按住空格键。

#### Prefab override
如果您对场景中的预制件进行了更改，并希望将这些更改应用于所有预制件




## Unity Essentials

## UI
#### Render mode
在Unity中设置Canvas的Render Mode可以通过以下步骤完成：

在Unity编辑器中打开Canvas对象。
在Inspector面板中，找到Canvas组件。
在Canvas组件下的Render Mode属性中，你可以选择不同的渲染模式。常见的选项包括：
Screen Space - Overlay：Canvas将覆盖在场景中的所有其他对象之上，不会随着场景中的相机移动而移动。
Screen Space - Camera：Canvas将放置在场景中的一个特定相机的前面，你需要指定一个目标相机。
World Space：Canvas将以世界坐标的形式存在，可以在场景中移动和旋转，通常用于在3D场景中创建HUD或者3DUI。



## Transform
#### Translate and Rotate


#### Scene操作

1. 按住` 右键 + WASD` 可以以游戏视角调整视角
2. F键聚焦
3. 使用滚轮进行放大和缩小，按住滚轮进行平移
4. 选中对象后，按住` option + 左键` 单击可绕焦点旋转，或按住 `Option + 右键` 单击可放大和缩小


#### Camera Projection
在camera的inspector里调整。

1. 透视投影（Perspective）：

- 透视投影模拟了人眼在现实世界中的视觉效果。远处的物体看起来比较小，而近处的物体看起来比较大，同时也存在景深（近大远小）效果。
- 透视投影会根据摄像机和物体之间的距离产生景深效果，远离摄像机的物体将显示得比较小，而靠近摄像机的物体将显示得比较大。

2. 正交投影（Orthographic）：

- 正交投影消除了景深效果，使得物体在屏幕上显示的大小与其距离摄像机的距离无关。无论物体距离摄像机多远，它们在屏幕上的大小都是固定的。
- 正交投影在一些2D游戏或需要简化透视效果的情况下很有用，例如俯视视角的游戏、UI界面等。
- 用size调整取景范围
  
如果你想要实现更加现实的视觉效果，或者需要在游戏中表现景深效果，则使用透视投影是一个不错的选择。
如果你的游戏是2D游戏，或者你想要简化透视效果并让物体在屏幕上的大小保持固定，那么使用正交投影可能更合适。


#### LateUpdate() 和 Update()

Update方法：

- Update方法在每一帧渲染之前被调用，因此它用于处理对象的常规更新逻辑，例如移动、用户输入响应等。
- 由于它在每一帧渲染之前执行，所以它是处理大多数游戏对象行为的理想位置。

LateUpdate方法：

- LateUpdate方法在所有Update方法执行完毕后被调用，所以它通常用于处理在Update方法中进行了一些更改后的后续调整或校正。
    例如，如果在Update方法中移动了一个对象，并且希望另一个对象跟随该对象移动，那么可以将跟随逻辑放在LateUpdate方法中，以确保它们在位置调整之后执行。
- LateUpdate还经常用于处理摄像机相关的逻辑，因为它能确保所有其他对象都已经更新完毕，摄像机再进行调整，从而避免画面抖动等问题。

#### InvokeRepeating

```cpp
// 调用InvokeRepeating方法，在指定的延迟后开始重复执行指定的方法

// 第一个参数："SpawnRandomAnimal" 是要重复调用的方法的名称（字符串）
// 第二个参数：startDelay 是延迟开始重复调用的时间（以秒为单位）
// 第三个参数：spawnInterval 是重复调用的时间间隔（以秒为单位）
InvokeRepeating("SpawnRandomAnimal", startDelay, spawnInterval);

```


#### 玩家控制输入

1. Explore the inputs: click `Edit` > `Project Settings`, select `Input Manager` in the left sidebar, then expand the `Axes` fold-out to explore the inputs

```cs
        if (Input.GetKeyDown(KeyCode.Space)) {
            // Launch a projectile from the player
            Instantiate(projectilePrefab, transform.position, projectilePrefab.transform.rotation);
        }

        // In order to improve game performance, we need to destroy them when they go out of bounds.
        if (transform.position.z > topBound) {
            Destroy(gameObject);
        }
        // 如果是要应用到全部prefab的clone，在inspector =》 override => apply all
```

- animalPrefabs[animalIndex]表示将要实例化的游戏对象的预制体。animalPrefabs是一个数组或列表，存储了多个预制体。animalIndex是一个整数变量，用于指定要实例化的预制体在数组中的索引。
- new Vector3(0, 0, 20)表示实例化后游戏对象的初始位置。这里的代码将在世界坐标系中创建一个新的位置，x和y坐标为0，z坐标为20。
- animalPrefabs[animalIndex].transform.rotation表示实例化后游戏对象的初始旋转。这里的代码获取了将要实例化的预制体的旋转信息，并将其应用于新创建的游戏对象。

```cs       
        if (Input.GetKeyDown(KeyCode.S))
        {
            Instantiate(
                animalPrefabs[animalIndex], 
                new Vector3(0, 0, 20), 
                animalPrefabs[animalIndex].transform.rotation
                );
        }        

```

#### 边界限制
```cs
        if (Mathf.Abs(transform.position.z) <= bound)
        {
            transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * verticalInput);
        }
        else
        {
            transform.position = new Vector3(transform.position.x, transform.position.y, transform.position.z > 0 ? bound : -bound);
        }
```

# Handbook
## 2D 项目
#### Layer
Inspector => order in layer

#### 固定
RigidBody 2D => Dynamic => constraints freeze

or

RigidBody 2D => Static


# 项目 & 团队

## 流程

#### 游戏设计文档
包括有关故事、游戏玩法、艺术指导、预期目标受众和可访问性的信息。

#### 生产

[分工图](https://unity-connect-prd.storage.googleapis.com/20200923/learn/images/00c0dbf7-09fe-49b8-858a-a75e55c1eddd_Foundations_UnityRT3D_1.1.3.2_chart_of_jobs.png)

#### 后期制作
评估、编辑、润色和修复。这通常包括alpha 测试和beta 测试。 

Alpha 测试是在内部进行的，以确定问题和需要改进的领域，而 Beta 测试是由潜在的最终用户在产品使用的预期环境中进行的。

#### GDD
设计文档包含您的项目的蓝图，包括：
- 高层概述；例如，游戏（或体验）设计文档中的总体项目愿景
- 项目中特定管道的要求和标准
- 特定功能的详细设计规范

您应该确定：
- 该项目的目标和目的
- 目标用户和受众
- 该项目的主要特点
- 最终交付形式

https://docs.google.com/document/d/1o1KFkuZrPbevpd7ZYBhJ5e8n3GRg6m15HkebVfiTufk/edit

#### 偏向agile的项目管理Sample
https://docs.google.com/document/d/1FR-GYr2hL67d6MleWTTP-mXfCHVZTM1Mko77MFodxFg/copy

#### 项目章程 Project Charter
设计文件获得批准并且项目被批准生产，项目章程就很有用，特别是当您在团队中工作时。

这是一份正式文件，描述了整个项目，包括项目的目标、项目的实施方式以及利益相关者是谁。项目章程用于预生产和生产阶段。

项目章程通常包括：
- 项目理由
- 项目的目标和限制
- 主要利益相关者是谁
- 已识别的风险
- 项目效益
- 预算总体概述

https://docs.google.com/document/d/1CzqyP1Qn8Ag-lXPaWVynb0InxUkXyWZLnkY2RllUSj8/edit

#### 管理项目，项目跟踪器
通过规划适当的时间表和管理项目计划来管理项目

项目计划采用设计文件和项目章程中确定的要素，并设置具体任务和交付日期。制作人或项目经理通常会创建此计划，并在需要进行更改时根据需要进行更新。

针对`个人和团队成功跟踪项目`的一些指南包括：
- 确定必要的项目步骤。
- 如果在团队中工作，请确定并分配特定的项目角色和职责。
- 创建包含具体可交付成果和截止日期的时间表。
- 识别项目管理中的常见问题和问题，例如范围蔓延和过于雄心勃勃的设计计划以及紧迫的时间限制。
- 确定已完成项目的到期时间。
- 为将构建到整个项目的项目的每个较小部分设置截止日期。
- 为每个项目阶段制定合理的时间框架。
- 如果在团队中工作，请为列表中的每项任务指定任务所有者。


### 测试

#### 错误报告的艺术
https://www.ministryoftesting.com/articles/the-art-of-the-bug-report


### 运营

#### 项目回顾
进行回顾的一种简单方法是制作一个包含三列的图表，并确定您认为应该做的事情：
- 开始做
- 不要做了
- 继续做



### prefab

既然我们的投射物具有我们想要的行为，我们需要把它做成一个`预制件`，这样它就可以在任何地方和任何时间重复使用，包括它的所有行为。
