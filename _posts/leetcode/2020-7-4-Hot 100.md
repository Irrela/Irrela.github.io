---
title: Hot 100
categories: Leetcode
---

# BinaryTree
## 前中后序的迭代遍历
[详细解答](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-fa-by-jason-2/)

## 617. 合并二叉树
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```
示例 1:
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
```

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        // 这个很关键，包括了两个都为null和其中一个为null的三种情况
        if(root1 == null || root2 == null) {
            return root1 == null ? root2 : root1; 
        }

        TreeNode node = root1; //root2也行

        node.val = root1.val + root2.val;
        node.left = mergeTrees(root1.left, root2.left);
        node.right = mergeTrees(root1.right, root2.right);

        return node;
    }
}
```

## 543. 二叉树的直径
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

```
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```
注意：两结点之间的路径长度是以它们之间边的数目表示。

```java
class Solution {
    
    int maxDiam = 0;

    public int diameterOfBinaryTree(TreeNode root) {

        this.maxDepth(root);
        return maxDiam;
    }

    private int maxDepth(TreeNode node) {
        if(node == null) {
            return 0;
        }

        int left = maxDepth(node.left);
        int right = maxDepth(node.right);

        this.maxDiam = Math.max(left + right, this.maxDiam);

        return Math.max(left, right) + 1;
    }
}
```


## 538. 把二叉搜索树转换为累加树
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。
 
```
示例 1：
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```
> BST的中序遍历，逆中序遍历分别是递增和递减数列

```java
class Solution {
    
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        inorder(root);
        return root;
    }

    private void inorder(TreeNode node) {
        if(node == null) {
            return ;
        }

        inorder(node.right);
        sum += node.val;
        node.val = sum;
        inorder(node.left);
    }
}
```



## 297. 二叉树的序列化与反序列化
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```
[DFS BFS详解](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/)

DFS方案
注意比较string内容用equals， ==是比较引用。
```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) {
            return "null";
        }

        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] nodes = data.split(",");
        List<String> nodesList = new ArrayList<>(Arrays.asList(nodes));
        return buildTree(nodesList);
    }

    private TreeNode buildTree(List<String> list) {
        String first = list.remove(0);
        TreeNode root = null;
        if(first.equals("null")) {
            return root;
        }
        
        root = new TreeNode(Integer.parseInt(first));
        root.left = buildTree(list);
        root.right = buildTree(list);

        return root;
    }
}
```

BFS解法
```java
public class Codec {
    public String serialize(TreeNode root) {
        //tree: [v1,v2,null,...]
        StringBuilder res = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList();
        queue.add(root);
        while(!queue.isEmpty()){
            TreeNode cur = queue.remove();
            if(cur == null){
                res.append("null,");
            }else{
                res.append(cur.val + ",");
                queue.add(cur.left);
                queue.add(cur.right);
            }
        }
        res.setLength(res.length() - 1);
        res.append("]");
        return res.toString();
    }

    public TreeNode deserialize(String data) {
        String[] nodes = data.substring(1, data.length()-1).split(",");
        TreeNode root = getNode(nodes[0]);
        Queue<TreeNode> parents = new LinkedList();
        TreeNode parent = root;
        boolean isLeft = true;
        for(int i = 1; i < nodes.length; i++){
            TreeNode cur = getNode(nodes[i]);
            if(isLeft){
                parent.left = cur;
            }else{
                parent.right = cur;
            }
            if(cur != null){
                parents.add(cur);
            }
            isLeft = !isLeft;
            if(isLeft){
                parent = parents.poll();
            }
        }
        return root;
    }

    private TreeNode getNode(String val){
        if(val.equals("null")){
            return null;
        }
        return new TreeNode(Integer.valueOf(val));
    }
}
```

```java
public class Codec {
    String sep = ",";
    String NULL = "#";

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        func1(root,sb);
        return sb.toString();
    }
    public void func1(TreeNode root,StringBuilder sb){
        if(root == null){
            sb.append(NULL).append(sep);
            return ;
        }
        sb.append(root.val).append(sep);
        func1(root.left,sb);
        func1(root.right,sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        LinkedList<String> ll = new LinkedList();
        for (String temp : data.split(sep)){
            ll.addLast(temp);
        }
        return func2(ll);
    }
    public TreeNode func2(LinkedList<String>  ll){
        if(ll.isEmpty()) return null;
        String s = ll.removeFirst();
        if(s.equals(NULL)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(s));
        root.left = func2(ll);
        root.right = func2(ll);
        return root;
    }
}
```

```java
public class Codec {

    // Encodes a tree to a single string.
    public List<Integer> serialize(TreeNode root) {
        List<Integer> res = new ArrayList();
        hSerialize(root, res);
        return res;
    }

    private void hSerialize(TreeNode root, List<Integer> res) {
        if (root == null) {
            res.add(null);
        } else {
            res.add(root.val);
            hSerialize(root.left, res);
            hSerialize(root.right, res);
        }
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(List<Integer> data) {
        return hDeserialize(data, new int[]{0});
    }

    private TreeNode hDeserialize(List<Integer> data, int[] index) {
        if (index[0] >= data.size()) return null;
        Integer val = data.get(index[0]);
        index[0] = index[0] + 1;
        if (val == null) return null;
        TreeNode node = new TreeNode(val);
        node.left = hDeserialize(data, index);
        node.right = hDeserialize(data, index);
        return node;
    }
}
```

## 226. 翻转二叉树

翻转一棵二叉树。
```
示例：
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
题目本身不难，重点是记住 java传参的特点，如在此题中用swap函数是无法起到交换两个指针的效果的。
这也是为什么要用swap(int[] arr, int a, int b)而不能直接swap(int[a], int[b]);

> java的参数传递分为两种，基本类型和String，是传值，这样函数内部的改变与外部参数无关。数组以及类的实例，是传引用，在函数内部对该引用的操作可以影响到外部参数，但是无法将该引用赋值对象的改变传递到函数体外。因此这个形式的void swap(Object obj1, Object obj2)函数是肯定不能实现的，至于变通的方案。


```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) {return null;}

        // exchange(root.left, root.right);
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }

    private void exchange(TreeNode nodeA, TreeNode nodeB) {
        TreeNode temp = nodeA;
        nodeA = nodeB;
        nodeB = temp;
    }
}
```

## 208. 实现 Trie (前缀树)
实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
```
示例:
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

```java
class Trie {

    class Node {
        private boolean isEnd;
        private Node[] next;

        public Node() {
            isEnd = false;
            next = new Node[26];
        }

    }

    private Node root;

    /** Initialize your data structure here. */
    public Trie() {
        root = new Node();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Node node = root;
        for(char c : word.toCharArray()) {
            if(node.next[c - 'a'] == null) { // 该char不是node的后续
                node.next[c - 'a'] = new Node();
            }
            node = node.next[c - 'a']; // node往下搜索
        }

        node.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Node node = root;
        for(char c : word.toCharArray()) {
            node = node.next[c - 'a'];
            if(node == null) {
                return false;
            }
        }
        return node.isEnd; // tree里有apple， 不代表有app
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Node node = root;
        for(char c : prefix.toCharArray()) {
            node = node.next[c - 'a'];
            if(node == null) {
                return false;
            }
        }
        return true;
    }
}
```

## 14. 二叉树展开为链表
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

```
示例 1：
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

```
```java
class Solution {
    public void flatten(TreeNode root) {
        while(root != null) {
            if(root.left == null) {
                root = root.right;
            } else {
                TreeNode left = root.left;

                while(left.right != null) {
                    left = left.right;
                }

                left.right = root.right;
                root.right = root.left;
                root.left = null;

                root = root.right;
            }
        }
    }
}
```

[原地解法（解法2）](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/)

## 105. 从前序与中序遍历序列构造二叉树
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder.length == 0) {
            return null;
        }   

        TreeNode root = new TreeNode(preorder[0]);
        int indexRootInorder = 0;
        for(int i = 0; i < inorder.length; i++) {
            if(inorder[i] == root.val) {
                indexRootInorder = i;
                break;
            }
        }

        int[] leftPre = Arrays.copyOfRange(preorder, 1, indexRootInorder + 1);
        int[] rightPre = Arrays.copyOfRange(preorder, indexRootInorder + 1, preorder.length);

        int[] leftIn = Arrays.copyOfRange(inorder, 0, indexRootInorder);
        int[] rightIn = Arrays.copyOfRange(inorder, indexRootInorder+1, inorder.length);

        root.left = this.buildTree(leftPre, leftIn);
        root.right = this.buildTree(rightPre, rightIn);

        return root;

    }
}
```
高速版本
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        int inorderIndex = 0;
        for (int i = 1; i < preorder.length; i++) {
            int preorderVal = preorder[i];
            TreeNode node = stack.peek();
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    inorderIndex++;
                }
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }
        return root;
    }
}
```

## 98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
```
示例 1:
输入:
    2
   / \
  1   3
输出: true
```
> BST的中序即是升序数列。

```java

class Solution {
    long pre = Long.MIN_VALUE; // 第一个节点可能是Integer.MIN_VALUE，所以得比它小
    public boolean isValidBST(TreeNode root) {
        if(root == null) {
            return true;
        }

        if(!this.isValidBST(root.left)) {
            return false;
        }

        if(root.val <= pre) {
            return false;
        }

        pre = root.val;

        return this.isValidBST(root.right);

    }
}

```
## 94. 二叉树的中序遍历
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        List<TreeNode> stack = new ArrayList<>();

        if(root == null) {
            return res;
        }

        TreeNode cur = root;

        while(cur != null || !stack.isEmpty()) {
            while(cur != null) {
                stack.add(cur);
                cur = cur.left;
            }
            cur = stack.remove(stack.size()-1);

            res.add(cur.val); // opera

            cur = cur.right;
        }

        return res;
    }
}
```



# Stack, Queue

## 739. 每日温度
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

### 栈解法
遍历一次， 如果当前气温高于栈顶，则出栈，更新出栈日期的数值（当前index - 栈顶index）

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        int len = T.length;
        int[] res = new int[len];
        List<Integer> stack = new ArrayList<>();

        for(int i = 0; i < len; i++) {
            while(!stack.isEmpty() && T[i] > T[stack.get(stack.size()-1)]) {
                int temp = stack.remove(stack.size()-1);
                res[temp] = i - temp;
            }
            stack.add(i);
        }
        return res;
    }
}
```

### DP解法
```java
class Solution {

    // Dynamic programing
    // Time: O(n^2)
    // Space: O(1)
    public int[] dailyTemperatures(int[] T) {
        if (T == null || T.length == 0) {
            return new int[0];
        } 

        int[] arr = new int[T.length];
        arr[T.length - 1] = 0;

        for (int i = T.length - 2; i >= 0; i--) {
            int next = i + 1;

            while (next < arr.length && T[i] >= T[next] && arr[next] != 0) {
                next += arr[next];
            }        
            if (next < arr.length && T[i] < T[next]) {
                arr[i] = next - i;
            } 
        }
        return arr;
    }
}
```

## 394. 字符串解码
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

```
示例 1：
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```
[辅助栈解析](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)

```java
class Solution {
    public String decodeString(String s) {

        List<Integer> multiStack = new ArrayList<>();
        List<String> strStack = new ArrayList<>();
        
        char[] chars = s.toCharArray();
        int multi = 0;
        StringBuilder strb = new StringBuilder();


        for(char c : chars) {
            if(c == '[') {
                multiStack.add(multi);
                strStack.add(new String(strb));

                strb = new StringBuilder();
                multi = 0;
            } else if(c == ']') {
                String lastStr = strStack.remove(strStack.size()-1);
                int curMulti = multiStack.remove(multiStack.size()-1);

                StringBuilder temp = new StringBuilder();
                for(int i = 0; i < curMulti; i++) {
                    temp.append(strb);
                }
                strb = new StringBuilder(lastStr + temp);

            } else if(c >= '0' && c <= '9') {
                multi = (multi * 10 + c - 48);
            } else {
                strb.append(c);
            }
        }

        return new String(strb);
    }
}
```

## 347. 前 K 个高频元素
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

```
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

示例 2:
输入: nums = [1], k = 1
输出: [1]
```

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));

        for(int num : nums) {
            if(map.containsKey(num)) {
                map.put(num, map.get(num)+1);
            } else {
                map.put(num, 1);
            }
        }

        for(Integer key : map.keySet()) {
            if(queue.size() < k) {
                queue.offer(key);
            } else if(map.get(key) > map.get(queue.peek())) {
                queue.poll();
                queue.offer(key);            
            }
        }

        int[] res = new int[k];
        for(int i = 0; i < k; i++) {
            res[i] = queue.poll();
        }
        return res;
    }
}
```

## 32. 最长有效括号
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```
示例 1：
输入：s = "(()"
输出：2
```
```
示例 2：
输入：s = ")()())"
输出：4
```
```
示例 3：
输入：s = ""
输出：0
```
> 我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」

- 对于遇到的每个'(' ，我们将它的下标放入栈中.
- 对于遇到的每个')' ，我们先弹出栈顶元素表示匹配了当前右括号：
== 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标.
== 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」.

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxRes = 0;
        LinkedList<Integer> stack = new LinkedList<>();
        stack.add(-1);

        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '(') {
                stack.add(i);
            } else {
                stack.remove(stack.size()-1);
                if(stack.isEmpty()) {
                    stack.add(i);
                } else {
                    maxRes = Math.max(maxRes, i-stack.get(stack.size()-1));
                }
            }
        }
        return maxRes;
    }
}
```

## 20. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

```
示例 1:
输入: "()"
输出: true
```
```
示例 2:
输入: "()[]{}"
输出: true
```
```
示例 3:
输入: "(]"
输出: false
```
```java
class Solution {
    private static final Map<Character, Character> map = new HashMap<>();
    public boolean isValid(String s) {

        map.put('{','}'); 
        map.put('[',']'); 
        map.put('(',')'); 
        map.put('?','?');

        if(s.length() > 0 && !map.containsKey(s.charAt(0))) {
            return false;
        }

        LinkedList<Character> stack = new LinkedList<>();
        stack.add('?');

        for(Character c : s.toCharArray()) {
            if(map.containsKey(c)) {
                stack.add(c);
            } else if(map.get(stack.remove(stack.size()-1)) != c) {
                return false;
            }
        }
        return stack.size() == 1;
    }
}

```

## 17. 电话号码的字母组合
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
```
示例:
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```
```java
class Solution {
	public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<>();
        if(digits == null || digits.length() == 0) {
            return res;
        }

        String[] letterMap = {"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        res.add("");

        for(int i = 0; i < digits.length(); i++) {
            String letters = letterMap[digits.charAt(i) - '2'];
            int currentSize = res.size(); // 记录当前queue长度再出队

            for(int j = 0; j < currentSize; j++) {
                String temp = res.remove(0);
                for(int k = 0; k < letters.length(); k++) {
                    res.add(temp + letters.charAt(k));
                }
            }
        }
        return res;
    }
}
```

# 链表

## 234. 回文链表
请判断一个链表是否为回文链表。
```
示例 1:
输入: 1->2
输出: false

示例 2:
输入: 1->2->2->1
输出: true
```
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head ==  null) {
            return true;
        }

        ListNode slow = head, fast = head;

        while(fast.next != null && fast.next.next != null) { // 注意找中点的jump条件
            fast = fast.next.next;
            slow = slow.next;
        }

        fast = reverse(slow);
        slow = head;

        while(slow != null) {
            if(slow.val != fast.val) {
                return false;
            }

            slow = slow.next;
            fast = fast.next;
        }

        return true;
    }

    private ListNode reverse(ListNode head) {
        if(head ==  null) {
            return null;
        }

        ListNode prev = null;
        ListNode cur = head;

        while(cur != null) {
            ListNode next = cur.next;

            cur.next = prev;
            prev = cur;
            cur = next;
        }

        return prev;
    }
}
```

## 面试题 02.05. 链表求和
给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
```
示例：
输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912
```
进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?
```
示例：
输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
输出：9 -> 1 -> 2，即912
```

思路:
将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010
每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值
如果两个链表全部遍历完毕后，进位值为 11，则在新链表最前方添加节点 11

> 小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carry = 0;
        ListNode head = new ListNode(0);
        ListNode cur = head;

        while (l1 != null || l2 != null) {
            int num1 = (l1 == null ? 0 : l1.val);
            int num2 = (l2 == null ? 0 : l2.val);
            
            int num = num1 + num2 + carry;
            carry = num / 10;
            
            cur.next = new ListNode(num % 10);
            
            l1 = (l1 == null ? null : l1.next);
            l2 = (l2 == null ? null : l2.next);
            cur = cur.next;
        }
        if (carry == 1)
            cur.next = new ListNode(carry);
        return head.next;
    }
}
```

## 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```
示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```
```
示例 2：
输入：l1 = [0], l2 = [0]
输出：[0]
```
```
示例 3：
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```
```java

```

# DP
[背包问题系列](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/)


## 10. 正则表达式匹配
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

```
示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4：

输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5：

输入：s = "mississippi" p = "mis*is*p*."
输出：false
```

```java
class Solution {
    public boolean isMatch(String s,String p){
        if (s == null || p == null) {
            return false;
        }
        
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配
        
        for (int i = 0; i < p.length(); i++) { // here's the p's length, not s's
            if (p.charAt(i) == '*' && dp[0][i - 1]) {
                dp[0][i + 1] = true; // here's y axis should be i+1
            }
        }

        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < p.length(); j++) {
                //如果是任意元素 或者是对于元素匹配
                if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) {
                    dp[i + 1][j + 1] = dp[i][j];
                }

                if (p.charAt(j) == '*') {
                    //如果前一个元素不匹配 且不为任意元素
                    if (p.charAt(j - 1) != s.charAt(i) && p.charAt(j - 1) != '.') {
                        dp[i + 1][j + 1] = dp[i + 1][j - 1];
                    } else {
                        dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1]);
                        /*
                        dp[i][j] = dp[i-1][j] // 多个字符匹配的情况	
                        or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况
                        or dp[i][j] = dp[i][j-2] // 没有匹配的情况
                            */
                    }
                }
            }
        }
        return dp[s.length()][p.length()];
    }
}
```

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                }
                else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}
```

## 416. 分割等和子集
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200

```
示例 1:
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

[解析及空间优化](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if(len < 2) {
            return false;
        }

        int sum = 0, max = Integer.MIN_VALUE;
        for(int num : nums) {
            sum += num;
            if(num > max) {
                max = num;
            }
        }

        if((sum & 1) == 1) {
            return false;
        }

        int half = sum / 2;
        if(max > half) {
            return false;
        }

        boolean[][] dp = new boolean[len][half+1];
        for(int i = 0; i < len; i++) {
            dp[i][0] = true;
        }
        dp[0][nums[0]] = true;

        for(int i = 1; i < len; i++) {
            int rightNum = nums[i];
            for(int j = 1; j <= half; j++) {
                if(j >= rightNum) {
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-rightNum];
                } else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        return dp[len-1][half];
    }
}
```


```java
// Faster, 只用1D dp数组

class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;
        if (n<2) {
            return false;
        }
        int sum = 0, maxNum = 0;
        for(int num: nums){
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        if(sum % 2 != 0){
            return false;
        }
        int target = sum/2;
        if(maxNum > target){
            return false;
        }
        boolean[] dp = new boolean[target+1];
        dp[0] = true;
        for(int i = 0; i<n; i++){
            int num = nums[i];
            for(int j = target; j>=num; --j){
                dp[j] |= dp[j - num]; 
            }
        }
        return dp[target];
    }
}
```

## 338. 比特位计数
给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```
示例 1:
输入: 2
输出: [0,1,1]
```

> leetcode上解法1的速度慢于暴力解法2， 但解法一的时间复杂度应该是更高的线性

```java
class Solution {
    public int[] countBits(int num) {
        int[] res = new int[num+1];
        res[0] = 0;

        for(int i = 0; i <=num; i++) {
            if(i % 2 == 1) { // 如果用&的话要加(), if((i & 1) == 1) {}
                res[i] = res[i-1] + 1;
            } else {
                res[i] = res[i/2];
            }
        }

        return res;
    }
    
    // 精简写法
    public int[] countBits(int num) { 
    int[] dp = new int[num + 1];
    for(int i = 1; i <= num; i++) {
        dp[i] = dp[i >> 1] + (i & 1);
    }
    return dp;
    }
}
```

```java
class Solution {
    // 暴力版本
    public int[] countBits1(int num) { 
        int[] res = new int[num + 1];
        for(int i = 1; i <= num; i++) {
            int c = 0;
            int n = i;
            while(n != 0) {
                n &= n - 1;
                c++;
            }
            res[i] = c;
        }
        return res;
    }
}
```

## 322. 零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。
```
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```
> dp[i] : 金额为i至少需要的硬币数
以coins = [1, 2], amount = 5 举例：
i = 1: dp[1] = dp[0] + 1 = 1
i = 2: dp[2] = dp[1-1] + 1 = 2, dp[2] = dp[2-2] + 1 = 1, 取min dp[2] = 1
... : dp[3] = dp[3-2] + 1 = 2, or dp[3-1] + 1 = 2 -> = 2
... : dp[4] = dp[4-1] + 1 = 3, or dp[4-2] + 1 = 2 -> 2
注意4=2+2的过程，如何取两次同种硬币

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int len = coins.length;
        if(len == 0) {
            return -1;
        }

        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount+1); // 先用一个max数占位，方便比较
        dp[0] = 0;

        for(int i = 1; i <= amount; i++) {
            for(int j = 0; j < len; j++) { // 其实反过来遍历也行，但一般会慢一点
                if(i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+1); 
                }
            }
        }

        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}
```
## 312. 戳气球
有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

```
示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```
> dp[low][high] : 从low -> high区间中能得到的最大coins数


```java
class Solution {
    public int maxCoins(int[] nums) {
        int len = nums.length;
        int[][] store = new int[len+2][len+2]; // [0, ..., len+1]

        int[] dp = new int[len+2]; // 首尾dummy
        dp[0] = dp[len+1] = 1;

        for (int i = 1; i <= len; i++) {
            dp[i] = nums[i-1]; 
        } // 将nums填入 -> [1, nums, 1]

        for (int high = 2; high <= len+1; high++) {
            for (int low = high-2; low >= 0; low--) { // 从high-2,high-1, high开始
                for(int k = low+1; k < high; k++) {
                    int sum = dp[low]*dp[high]*dp[k] + store[low][k] + store[k][high];
                    store[low][high] = Math.max(store[low][high], sum);
                }
            }
        }
        return store[0][len+1];
    }
}
```

## 300. 最长递增子数列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```
> 分错类了，应该是贪心+二分。
主要流程：
以输入序列 [0, 8, 4, 12, 2][0,8,4,12,2] 为例：

第一步插入 0，d = [0]

第二步插入 8，d = [0, 8]

第三步插入 4，d = [0, 4]

第四步插入 12，d = [0, 4, 12]

第五步插入 2，d = [0, 2, 12]

当d数组最后一位小于num时，直接把num加到后面，否则向前寻找比num小的一位k，在k+1位更新为当前num。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] tail = new int[n + 1]; // 用n+1数组，让0做dummy，方便找不到的情况
        tail[len] = nums[0];

        for (int i = 1; i < n; ++i) {
            if (nums[i] > tail[len]) {
                tail[++len] = nums[i];
            } else {
                int l = 1;
                int r = len;
                int pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (tail[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                tail[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```

## 152. 乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

```
示例 1:
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```


```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE;
        int curMax = 1, curMin = 1, temp;

        for (int num : nums) {
            // 关键处，如遇负数，交换当前最大最小再做乘法比较
            if(num < 0) {
                temp = curMax;
                curMax = curMin;
                curMin = temp;
            }

            curMax = Math.max(curMax * num, num);
            curMin = Math.min(curMin * num, num);

            max = Math.max(max, curMax);
        }

        return max;
    }
}
```
## 139. 单词拆分

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：
拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
```
示例 1：
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```
```java
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length()+1];
        dp[0] = true; // dp[x]表示s[:x-1]能组成

        for (int i = 1; i <= s.length(); i++) {
            for (int j = i-1; j >= 0; j--) {
                // if (dp[i] == true) break;
                // if (dp[j] == false) continue;
                
                String suffix = s.substring(j, i); // s[j:i-1]
                if(wordSet.contains(suffix) && dp[j]) { // s[j:i-1] 和 s[:j-1]都存在，所以dp[i]存在
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.length()];
    }
```

## 72. 编辑距离
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符

```
示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```
[Solution](https://leetcode-cn.com/problems/edit-distance/solution/edit-distance-by-ikaruga/)

讲一下我自己对状态转移方程的理解,麻烦大家看看我说得对不对有没有道理:
1. 当word1[i]==word2[j]时,由于遍历到了i和j,说明word1的0~i-1和word2的0~j-1的匹配结果已经生成,
由于当前两个字符相同,因此无需做任何操作,dp[i][j]=dp[i-1][j-1]
2. 当word1[i]!=word2[j]时,可以进行的操作有3个:
      ① 替换操作:可能word1的0~i-1位置与word2的0~j-1位置的字符都相同,
           只是当前位置的字符不匹配,进行替换操作后两者变得相同,
           所以此时dp[i][j]=dp[i-1][j-1]+1(这个加1代表执行替换操作)
      ②删除操作:若此时word1的0~i-1位置与word2的0~j位置已经匹配了,
         此时多出了word1的i位置字符,应把它删除掉,才能使此时word1的0~i(这个i是执行了删除操作后新的i)
         和word2的0~j位置匹配,因此此时dp[i][j]=dp[i-1][j]+1(这个加1代表执行删除操作)
      ③插入操作:若此时word1的0~i位置只是和word2的0~j-1位置匹配,
          此时只需要在原来的i位置后面插入一个和word2的j位置相同的字符使得
          此时的word1的0~i(这个i是执行了插入操作后新的i)和word2的0~j匹配得上,
          所以此时dp[i][j]=dp[i][j-1]+1(这个加1代表执行插入操作)
      ④由于题目所要求的是要最少的操作数:所以当word1[i] != word2[j] 时,
          需要在这三个操作中选取一个最小的值赋格当前的dp[i][j]

3. 总结:状态方程为:
if(word1[i] == word2[j]):
      dp[i][j] = dp[i-1][j-1]
else:
       min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int row = word1.length();
        int col = word2.length();

        int[][] dp = new int[row+1][col+1];

        for(int i = 1; i <= row; i++) {
            dp[i][0] = dp[i-1][0] + 1; 
        }

        for(int i = 1; i <= col; i++) {
            dp[0][i] = dp[0][i-1] + 1; 
        }

        for(int i = 1; i <= row; i++) { // 注意是从 1 开始遍历
            for(int j = 1; j <= col; j++) {
                if(word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i][j-1]) + 1;
                }
            }
        }

        return dp[row][col];
    }
}
```

## 64. 最小路径和

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;

        if(row == 1 && col == 1) {
            return grid[0][0];
        }

        int[][] dp = new int[row+1][col+1];
        dp[1][1] = grid[0][0];

        for(int i = 2; i <= row; i++) {
            dp[i][1] = dp[i-1][1] + grid[i-1][0];
        }

        for(int i = 2; i <= col; i++) {
            dp[1][i] = dp[1][i-1] + grid[0][i-1];
        }

        for(int i = 2; i <= row; i++) {
            for(int j = 2; j <= col; j++) {
                dp[i][j] = grid[i-1][j-1] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }

        return dp[row][col];
    }
}
```

## 62. 不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```java
class Solution {
    public int uniquePaths(int m, int n) {
        if(m < 2 || n < 2){return 1;}
        int[][] dp = new int[m+1][n+1];
        
        for(int i = 1; i <= m; i++) {
            dp[i][1] = 1;
        }

        for(int i = 1; i <= n; i++) {
            dp[1][i] = 1;
        }
        
        for(int i = 2; i <= m; i++){
            for(int j = 2; j <= n; j++){
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[m][n];
    }
}
```

## 55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

```
示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

1. 如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
2. 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。
3. 如果可以一直跳到最后，就成功了。



```java
class Solution {
    public boolean canJump(int[] nums) {
        int farthest = nums[0];
        for(int i = 0; i < nums.length; i++){
            if(i > farthest) {
                return false;
            } else {
                farthest = Math.max(farthest, i + nums[i]);
            }
        }
        return true;
    }
}
```

## 53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int oneBefore = nums[0];

        for(int i = 1; i < nums.length; i++) {
            if(oneBefore >= 0) {
                oneBefore += nums[i];
            } else {
                oneBefore = nums[i];
            }

            res = Math.max(oneBefore, res);
        }

        return res;
    }
}
```


## 32. 最长有效括号
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```
示例 1：
输入：s = "(()"
输出：2
```
```
示例 2：
输入：s = ")()())"
输出：4
```
```
示例 3：
输入：s = ""
输出：0
```
```java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxRes = 0;
        int[] dp = new int[s.length()];

        for(int i = 1; i < s.length(); i++) {
            if(s.charAt(i) == ')') {
                if(s.charAt(i-1) == '(') {
                    dp[i] = (i>=2 ? dp[i-2] : 0) + 2;
                } else if(i-dp[i-1] > 0 && s.charAt(i-dp[i-1]-1) == '(') {
                    dp[i] = dp[i-1] + ((i-dp[i-1]) >= 2 ? dp[i - dp[i-1] -2] : 0) + 2;
                }
                maxRes = Math.max(maxRes, dp[i]);
            }
        }
        return maxRes;
    }
}

```


# Pointer， 滑动窗口

二分查找：
1. while (left <= right)	简单问题用，在循环体里能找到答案以后退出。
2. while (left < right)	复杂问题用，把答案留到退出循环以后，再判断。是解决二分问题的利器，尤其在边界问题用，这种方式考虑细节最少，但是需要一定练习才能灵活运用。


[while (left <= right) 写法返回值的详细讨论](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/da-jia-bu-yao-kan-labuladong-de-jie-fa-fei-chang-2/)

## 647. 回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
```
示例 1：
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

### 中心扩展
以aba举例
1. a, b, a算 even中心点，左右指针都初始化到该char上
2. ab间的空隙, ba间的空隙, left初始化到左边char上，right初始化到右边char上。

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        if(len == 0) {
            return 0;
        }

        int res = 0;

        for(int i = 0; i < 2 * len - 1; i++) {
            if(i % 2 == 0) {
                res += this.evenCount(s, i / 2); //注意传入的idx是整除2后的
            } else {
                res += this.oddCount(s, i / 2);
            }
        } 
        return res;
    }

    private int evenCount(String s, int idx) {
        int res = 0;

        int left = idx, right = idx;

        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
            res++;
        }

        return res;
    }

    private int oddCount(String s, int idx) {
        int res = 0;

        int left = idx, right = idx + 1;

        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
            res++;
        }
        return res;
    }
}
```

## 动态规划

i = right, j = left, 左向右，右向左都可以

注意有一个`i - j <= 1`的条件，这个是初始条件， == 0是指从char开始，== 1是指从空隙开始

```java
class Solution {
    public int countSubstrings(String s) {
        int len = s.length();
        if(len == 0) {
            return 0;
        }
        
        boolean[][] dp = new boolean[len][len];
        int res = 0;

        for(int i = 0; i < len; i++) {
            for(int j = i; j >= 0; j--) {
                if(s.charAt(i) == s.charAt(j) && (i - j <= 1 || dp[i-1][j+1])) {
                    dp[i][j] = true;
                    res++;
                }
            }
        }

        return res;
    }
}
```

## 581. 最短无序连续子数组
给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 最短 子数组，并输出它的长度。

```
示例 1：

输入：nums = [2,6,4,8,10,9,15]
输出：5
解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
示例 2：

输入：nums = [1,2,3,4]
输出：0
示例 3：

输入：nums = [1]
输出：0
```

### 解法一 栈
```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        if(len == 0) {
            return 0;
        }

        List<Integer> stack = new ArrayList<>();
        int left = len - 1;
        int right = 0;

        stack.add(0);

        for(int i = 1; i < len; i++) {
            while(!stack.isEmpty() && nums[i] < nums[stack.get(stack.size()-1)]) {
                left = Math.min(left, stack.remove(stack.size()-1));
            }
            stack.add(i);
        }

        stack.clear();
        stack.add(len-1);

        for(int i = len-2; i >= 0; i--) {
            while(!stack.isEmpty() && nums[i] > nums[stack.get(stack.size()-1)]) {
                right = Math.max(right, stack.remove(stack.size()-1));
            }
            stack.add(i);
        }

        return right - left > 0 ? right - left + 1 : 0 ;
    }
}
```

### 解法二 双指针
这个算法背后的思想是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界。
```java
    public int findUnsortedSubarray(int[] nums) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int i = 1; i < nums.length; i++) {
            // 找到min
            if(nums[i] < nums[i-1]) {
                min = Math.min(min, nums[i]);
            }
            // 找到max
            if(nums[len-1-i] > nums[len-i]) {
                max = Math.max(max, nums[len-1-i]);
            }
        }

        int left = 0, right = len - 1;
        
        while(left < len && nums[left] < min) {
            left++;
        }

        while(right >= 0 && nums[right] > max) {
            right--;
        }

        return right - left >= 0 ? right - left + 1 : 0; // 有可能是顺序数组，即返回0的数组。
    }
```

## 438. 找到字符串中所有字母异位词
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。(更正！只要是字母相同就行，排列一样也算，可见示例2中的ab和ab)
不考虑答案输出的顺序。
```
示例 1:
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```
```
示例 2:
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
```
流程：
1. 用两个数组(长度26)保存每个char出现的数量，window是当前left，right指针之间的信息，needs是String p 需要的信息。

2. 遍历p string获得needs的信息。

3. right指针向右遍历，更新window信息。

4. 当right遍历到char使得window中的char出现数大于needs，开始右移left指针，直到从左边推出一个char。

5. 检查此时left-right是否是p string的异位词（检查长度即可）

```java
public class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        char[] strArr = s.toCharArray();
        char[] pArr = p.toCharArray();

        List<Integer> res = new ArrayList<>();

        int[] needs = new int[26];
        int[] window = new int[26];

        for(int i = 0; i < pArr.length; i++) {
            needs[pArr[i] - 'a'] += 1;
        }

        int left = 0, right = 0;

        while(right < strArr.length) {
            int rightCharIndex = strArr[right] - 'a';
            window[rightCharIndex] += 1;
            right++;

            while(window[rightCharIndex] > needs[rightCharIndex]) {
                int leftCharIndex = strArr[left] - 'a';
                window[leftCharIndex]--;
                left++;
            }

            if(right - left == p.length()) {
                res.add(left);
            }
        }

        return res;
    }
}
```

## 283. 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
```
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
> 让left指针一直指向最左边的0元素上，然后遍历指针将非零元素与其交换。
```java
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums.length == 0) {
            return ;
        }

        int leftZero = 0;

        for(int i = 0; i < nums.length; i++) {
            if(nums[i] != 0) {
                if(i > leftZero) {
                    nums[leftZero] = nums[i];
                    nums[i] = 0;
                }
                leftZero++; // 只有nums[i] ！= 0 时 left才移动， 可以保证left一直维持在最左的0上。
            }
        }
    }
}
```

## 287. 寻找重复数
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

```
示例 1：
输入：nums = [1,3,4,2,2]
输出：2
```
解法有数组实现hash，和更快的快慢指针

主要流程：
1. 快慢指针遍历，相遇在环内
2. finder从头开始，和slow一起单步，相遇在环入口

(快慢指针详解)[https://leetcode-cn.com/problems/find-the-duplicate-number/solution/kuai-man-zhi-zhen-de-jie-shi-cong-damien_undoxie-d/]

```java
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums.length == 0) {return -1;}

        int fast = nums[nums[0]], slow = nums[0]; //不能设为0，不然无法进入while循环。
        while(fast != slow){
            fast = nums[nums[fast]];
            slow = nums[slow];
            // if(fast == slow)
            //     break;
        }
        int finder = 0;
        while(finder != slow){
            finder = nums[finder];
            slow = nums[slow];
            // if(slow == finder)
            //     break;        
        }
        return slow;
    }
}
```


## 142. 环形链表 II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

说明：不允许修改给定的链表。

进阶：

你是否可以使用 O(1) 空间解决此题？

```
1. 快慢指针第一次相遇
2. fast = head
3. fast降速成单步指针
```

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null) {
           return null;
        } 

        ListNode slow = head;
        ListNode fast = head;

        while(true) {
            if(fast == null || fast.next == null) {
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) {
                break;
            }
        }

        fast = head;

        while(fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }

        return fast;

    }
}
```

## 11. 盛最多水的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

```
示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
> 移动指针：相对高的一边不动，矮的移动以寻求更大可能

```java
class Solution {
    public int maxArea(int[] height) {
        int low = 0, high = height.length - 1;
        int res = 0;
        int tempVol = 0;

        while(low < high) {
            tempVol = Math.min(height[low], height[high]) * (high - low);
            res = Math.max(res, tempVol);

            if(height[low] <= height[high]) {
                low++;
            } else {
                high--;
            }
        }

        return res;
    }
}
```

## 15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
```
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

1. 当 nums[k] > 0 时直接break跳出：因为 nums[j] >= nums[i] >= nums[k] > 0，即 33 个数字都大于 00 ，在此固定指针 k 之后不可能再找到结果了。

2. 当 k > 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。

3. i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，当i < j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：

- 当s < 0时，i += 1并跳过所有重复的nums[i]；
- 当s > 0时，j -= 1并跳过所有重复的nums[j]；
- 当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。



```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ret = new ArrayList<>();
        int n = nums.length;
        Arrays.sort(nums);
        
        for (int i = 0; i < n - 2; i++) {
            if (nums[i] > 0) {
                return ret;
            } // 数组是升序排列的，所以如果nums[i] > 0，后面不可能出现和为0的解，直接返回
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }// 跳过可能导致重复的解

            int left = i + 1, right = n - 1;
            while (left < right) {
                int temp = nums[i] + nums[left] + nums[right];
                if (temp > 0) {
                    right--;
                } else if (temp < 0) {
                    left++;
                } else {
                    List<Integer> t = new ArrayList<>();
                    t.add(nums[i]);
                    t.add(nums[left]);
                    t.add(nums[right]);
                    ret.add(t);
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return ret;
    }
}
```

## 31. 下一个排列
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

```
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]
```

1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
- 在尽可能靠右的低位进行交换，需要从后向前查找
- 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
- 将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

标准的“下一个排列”算法可以描述为：

1. 从后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] < A[j]。此时 [j,end) 必然是降序
2. 在 [j,end) 从后向前查找第一个满足 A[i] < A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
3. 将 A[i] 与 A[k] 交换
4. 可以断定这时 [j,end) 必然是降序，逆置 [j,end)，使其升序
5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len <= 1) {
            return;
        }

        int i = len - 2;
        int j = len - 1;
        int k = len - 1;
        
        // 从后向前找第一个相邻升序的元素对(i, j)。
        while(i >= 0 && nums[i] >= nums[j]) {
            i--;
            j--;
        }

        // 从后向前找最小的比i大的一个k
        if(i >= 0) {
            while(nums[i] >= nums[k]) {
                k--;
            }

            this.swap(nums, i, k);
        }

        // 将j往后的reverse
        for(i = j, j = len - 1; i < j; i++, j--) {
            this.swap(nums, i, j);
        }
    }

    private void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```

## 33. 搜索旋转排序数组
升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

```
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

```java
// 有序数组的二分查找

public int search(int[] nums, int target) {
    int lo = 0, hi = nums.length - 1, mid = 0;
    while (lo <= hi) {
        mid = lo + ((hi - lo) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            lo = mid + 1;
        } else {
            hi = mid - 1;
        }
    }
    return -1;
}
```
如上述代码所示，我们根据 nums[mid] 与 target 的大小关系，可以得知 target 是在 mid 的左边还是右边，从而来调整左右边界 lo 和 hi。

但是，对于旋转数组，我们无法直接根据 nums[mid] 与 target 的大小关系来判断 target 是在 mid 的左边还是右边，因此需要「分段讨论」。于是方法三呼之欲出！
> 先根据 nums[mid] 与 nums[lo] 的关系判断 mid 是在左段还是右段，接下来再判断 target 是在 mid 的左边还是右边，从而来调整左右边界 lo 和 hi。

```java
public int search(int[] nums, int target) {
        if(nums.length == 0) {
            return -1;
        }

        int low = 0, high = nums.length - 1;

        while(low <= high) { // 
            int mid = (low + high) / 2;

            if(target == nums[mid]) {
                return mid;
            }

            // 先根据 nums[mid] 与 nums[lo] 的关系判断 mid 是在左段还是右段 
            if(nums[low] <= nums[mid]) { 
                // 再判断 target 是在 mid 的左边还是右边，从而调整左右边界 lo 和 hi
                if(target >= nums[low] && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if(target > nums[mid] && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }
        return -1;
    }
```

## 34. 在排序数组中查找元素的第一个和最后一个位置
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

```
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int len = nums.length;
        if(len == 0) {
            return new int[] {-1, -1};
        }

        int firstPos = this.findeFirstPos(nums, target);
        if(firstPos == -1) {
            return new int[] {-1, -1}; 
        }

        int lastPos = this.findLastPos(nums, target);
        return new int[] {firstPos, lastPos};
    }

    private int findeFirstPos(int[] nums, int target) {
        int low = 0, high = nums.length - 1;

        while(low <= high) {
            int mid = (low + high) / 2;

            if(nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        // 此时 low 和 high 的位置关系是 [high, low]，注意上面的 ①，此时 low 才是第 1 次元素出现的位置
        // 因此还需要特别做一次判断
        if(low != nums.length && nums[low] == target) {
            return low;
        }
        return -1;
        
    }

    private int findLastPos(int[] nums, int target) {
        int low = 0, high = nums.length - 1;

        while(low <= high) {
            int mid = (low + high) / 2;
            if(nums[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return high;
    }
}
```

# 回溯, Search
[回溯](https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/)
```通用回溯
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

## 399. 除法求值
给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

 
```
示例 1：
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

### BFS
(算法解析)[https://leetcode-cn.com/problems/evaluate-division/solution/chu-fa-qiu-zhi-by-leetcode-solution-8nxb/]

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int nvars = 0;
        Map<String, Integer> variables = new HashMap<String, Integer>();

        int n = equations.size();
        for (int i = 0; i < n; i++) {
            if (!variables.containsKey(equations.get(i).get(0))) {
                variables.put(equations.get(i).get(0), nvars++);
            }
            if (!variables.containsKey(equations.get(i).get(1))) {
                variables.put(equations.get(i).get(1), nvars++);
            }
        }

        // 对于每个点，存储其直接连接到的所有点及对应的权值
        List<Pair>[] edges = new List[nvars];
        for (int i = 0; i < nvars; i++) {
            edges[i] = new ArrayList<Pair>();
        }
        for (int i = 0; i < n; i++) {
            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
            edges[va].add(new Pair(vb, values[i]));
            edges[vb].add(new Pair(va, 1.0 / values[i]));
        }

        int queriesCount = queries.size();
        double[] ret = new double[queriesCount];
        for (int i = 0; i < queriesCount; i++) {
            List<String> query = queries.get(i);
            double result = -1.0;
            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
                if (ia == ib) {
                    result = 1.0;
                } else {
                    Queue<Integer> points = new LinkedList<Integer>();
                    points.offer(ia);
                    double[] ratios = new double[nvars];
                    Arrays.fill(ratios, -1.0);
                    ratios[ia] = 1.0;

                    while (!points.isEmpty() && ratios[ib] < 0) {
                        int x = points.poll();
                        for (Pair pair : edges[x]) {
                            int y = pair.index;
                            double val = pair.value;
                            if (ratios[y] < 0) {
                                ratios[y] = ratios[x] * val;
                                points.offer(y);
                            }
                        }
                    }
                    result = ratios[ib];
                }
            }
            ret[i] = result;
        }
        return ret;
    }
}

class Pair {
    int index;
    double value;

    Pair(int index, double value) {
        this.index = index;
        this.value = value;
    }
}
```

### 并查集
(并查集及相关问题)[https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/]


## 437. 路径总和 III
给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。
```
示例：

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11
```

```java
class Solution {
    Map<Integer, Integer> prefixMap;
    int target;

    public int pathSum(TreeNode root, int sum) {
        prefixMap = new HashMap<>();
        target = sum;

        prefixMap.put(0, 1);
        return recur(root, 0);
    }

    private int recur(TreeNode node, int curSum) {
        if(node == null) {
            return 0;
        }

        int res = 0;
        curSum += node.val;

        res += prefixMap.getOrDefault(curSum - target, 0);
        prefixMap.put(curSum, prefixMap.getOrDefault(curSum, 0) + 1);

        int left = recur(node.left, curSum);
        int right = recur(node.right, curSum);

        res = res + left + right;

        prefixMap.put(curSum, prefixMap.get(curSum) - 1);

        return res;
    }
}
```



## 240. 搜索二维矩阵 II
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        if(rows == 0 || cols == 0) {
            return false;
        }

        int row = 0, col = cols - 1;

        while(col >= 0 && row < rows) {
            if(matrix[row][col] == target) {
                return true;
            }

            if(matrix[row][col] < target) { // 这里一定要用else，否则有可能row++后又符合了matrix[row][col] > target然后又做操作。
                row++;
            } else {
                col--;
            }
        }

        return false;
    }
}
```

## 207. 课程表
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

```
示例 1:
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

BFS做法
1. 统计课程安排图中每个节点的入度，生成 入度表 indegrees。
2. 借助一个队列 queue，将所有入度为 00 的节点入队。
3. 当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：
- 并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 -1−1，即 indegrees[cur] -= 1。
- 当入度 -1−1后邻接节点 cur 的入度为 00，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。
4. 在每次 pre 出队时，执行 numCourses--；
- 若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 00。
- 因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。

[DFS做法](https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        List<List<Integer>> adjacency = new ArrayList<>();
        List<Integer> queue = new ArrayList<>();

        for(int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }

        for(int[] course : prerequisites) {
            // 1 -> 0 所以统计0的入度，然后
            indegrees[course[0]]++;
            adjacency.get(course[1]).add(course[0]); // 可以修改get() 元素的内容，其本身？？
        }

        // 遍历一次，把所有入度为0的点入队
        for(int i = 0; i < numCourses; i++) {
            if(indegrees[i] == 0) {
                queue.add(i);
            }
        }

        while(!queue.isEmpty()) {
            int pre = queue.remove(0);
            numCourses--;

            // 在pre被删除后，检查pre指向的node们哪些入度-1后为0（即只被pre指向的node），他们就是新的要入队的点。
            for(int from : adjacency.get(pre)) {
                if(--indegrees[from] == 0) {
                    queue.add(from);
                }
            }
        }

        return numCourses == 0;
    }
}
```



## 78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
```
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

```java
class Solution {
    List<List<Integer>> res;

    public List<List<Integer>> subsets(int[] nums) {

        res = new ArrayList();

        if(nums.length == 0) {
            return res;
        }

        this.backTrack(nums, 0, new ArrayList());

        return res;

    }

    private void backTrack(int[] nums, int start, List<Integer> subset) {
        res.add(new ArrayList(subset)); // 要新建一个list，否则等于存了n次subset，之后的remove会修改所有的subset。

        for(int i = start; i < nums.length; i++) {
            subset.add(nums[i]);
            this.backTrack(nums, i+1, subset);
            subset.remove(subset.size()-1);
        }
    }
}
```
## 79. 单词搜索
给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。


```
示例:
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

```java
class Solution {
    int rows;
    int cols;

    public boolean exist(char[][] board, String word) {
        rows = board.length;
        cols = board[0].length;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if(this.pathFound(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean pathFound(char[][] board, String word, int index, int row, int col) {
        if(row < 0 || row >= rows || col < 0 || col >= cols) {
            return false;
        }

        char holder = board[row][col];

        if(word.charAt(index) != holder) {
            return false;
        }

        if(index == word.length() - 1){
            return true;
        }

        board[row][col] = '@';

        boolean res = this.pathFound(board, word, index+1, row+1, col) ||
                      this.pathFound(board, word, index+1, row-1, col) ||
                      this.pathFound(board, word, index+1, row, col+1) ||
                      this.pathFound(board, word, index+1, row, col-1);

        if(res) {
            return true;
        }

        board[row][col] = holder;
        return false;
    }
}
```
## 78. 子集
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```
示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

```java

```

## 127. 单词接龙
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的最短转换序列中的单词数目。如果不存在这样的转换序列，返回 0。

```
示例 1：
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```
```
示例 2：
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

```java
public class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordSet = new HashSet<>(wordList);
        if(wordSet.size() == 0 || !wordSet.contains(endWord)) {
            return 0;
        }
        wordSet.remove(beginWord);

        LinkedList<String> queue = new LinkedList<>();
        queue.add(beginWord);
        HashSet<String> visited = new HashSet<>();
        visited.add(beginWord);

        // Start BFS
        int step = 1;
        while(!queue.isEmpty()) {
            int currentSize = queue.size();
            for(int i = 0; i < currentSize; i++) {
                // 依次遍历当前队列中的单词
                String currentWord = queue.remove(0);
                
                // 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1
                if(changeOneWord(currentWord, endWord, queue, visited, wordSet)) {
                    return step + 1;
                }
            }
            step++;
        }
        return 0;
    }

    public boolean changeOneWord(String currentWord, String endWord, Queue<String> queue, Set<String> visited, Set<String> wordSet) {
        char[] charArray = currentWord.toCharArray();
        for(int i = 0; i < endWord.length(); i++) {
            char originChar = charArray[i];
            for(char k = 'a'; k <= 'z'; k++) {
                if(k == originChar) {
                    continue;
                }
                charArray[i] = k;
                String nextWord = String.valueOf(charArray);
                if(wordSet.contains(nextWord)) {
                    if(nextWord.equals(endWord)) {
                        return true;
                    }
                    if(!visited.contains(nextWord)) {
                        queue.add(nextWord);
                        visited.add(nextWord);
                    }
                }
            }
            // recovery
            charArray[i] = originChar;
        }
        return false;
    }
}
```

## 22. 括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

```
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```
当前左右括号都有大于 0 个可以使用的时候，才产生分支；
- 产生左分支的时候，只看当前是否还有左括号可以使用；
- 产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；
- 在左边和右边剩余的括号数都等于 0 的时候结算(return)。


1. 使用StringBuilder，记得删除
```java
public class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if(n == 0) {
            return res;
        }

        this.dfs(new StringBuilder(), n, n, res);
        return res;
    }

    private void dfs(StringBuilder curStr, int left, int right, List<String> res) {
        if(left == 0 && right == 0) {
            res.add(curStr.toString());
            return;
        }

        if(left > right) {
            return;
        }

        if(left > 0) {
            curStr.append("(");
            this.dfs(curStr, left - 1, right, res);
            curStr.deleteCharAt(curStr.length()-1);
        }

        if(right > 0) {
            // this.dfs(curStr.append(")"), left, right - 1, res);
            curStr.append(")");
            this.dfs(curStr, left, right - 1, res);
            curStr.deleteCharAt(curStr.length()-1);
        }
    }
}

```

2. 使用String的版本，无需删除，因为每次都生成新的String对象
```java
public class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if(n == 0) {
            return res;
        }

        this.dfs("", n, n, res);
        return res;
    }

    private void dfs(String curStr, int left, int right, List<String> res) {
        if(left == 0 && right == 0) {
            res.add(curStr);
            return;
        }

        if(left > right) {
            return;
        }

        if(left > 0) {

            this.dfs(curStr+"(", left - 1, right, res);

        }

        if(right > 0) {

            this.dfs(curStr+")", left, right - 1, res);

        }
    }
}
```

## 39. 组合总和
给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
```
示例 1：
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        int len = candidates.length;
        List<List<Integer>> res = new ArrayList<>();
        if(len == 0) {
            return res;
        }

        List<Integer> path = new ArrayList<>();
        this.dfs(candidates, 0, target, path, res);
        return res;
    }

    private void dfs(int[] candidates, int begin, int target, List<Integer> path, List<List<Integer>> res) {
        if(target < 0) {
            return;
        }

        if(target == 0) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < candidates.length; i++) {
            path.add(candidates[i]);
            this.dfs(candidates, i, target - candidates[i], path, res);
            path.remove(path.size()-1);
        }
    }
}
```



# String


# Digit
- `&`:	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
- `|`:	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
- `^`:	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
- `~`:	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。
- `<<`:	左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
- `>>`:	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数

[异或的使用](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-a/)

异或的性质
两个数字异或的结果a^b是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是
如果同一位的数字相同则为 0，不同则为 1

异或的规律

- 任何数和本身异或则为 0

- 任何数和 0 异或是 本身

- 异或满足交换律。 即 a ^ b ^ c ，等价于 a ^ c ^ b

## Java的 >>, >>>
`>>`是算术右移，`>>>`是逻辑右移。

在算术移位中，将扩展符号位以保留数字的符号性。

例如：用8位表示的-2将是11111110（因为最高有效位的权重为负）。使用算术移位将其右移一位，您将得到11111111-1。但是，逻辑上的右移并不关心该值是否可能表示一个带符号的数字。它只是将所有内容移至右侧，并从左侧填充0。使用逻辑移位将-2右移一位将得到01111111。  


## 461. 汉明距离
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

```
示例:
输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
```
> Integer.bitCount(int num) 计算二进制中1的数量
```java
class Solution {
    public int hammingDistance(int x, int y) {
        int temp = x ^ y;
        int res = 0;

        while(temp > 0) {
            res += (temp & 1);
            temp >>= 1;
        }

        return res;
    }
}
```


# Sort related

## 215. 数组中的第K个最大元素
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int low = 0, high = nums.length-1;

        int target = nums.length - k;

        while(true) {
            int index = partition(nums, low, high);
            if(index == target) {
                return nums[index];
            } else if(index < target) {
                low = index + 1;
            } else {
                high = index - 1;
            }
        }
    }

    private int partition(int[] nums, int low, int high) {
        int pivot = nums[low];
        int j = low;

        for(int i = low + 1; i <= high; i++) {
            if(nums[i] < pivot) {                 // 小于 pivot 的元素都被交换到前面
                // 小于 pivot 的元素都被交换到前面
                j++;
                swap(nums, i, j);
            }
        }
        // 在之前遍历的过程中，满足 [left + 1, j] < pivot，并且 (j, i] >= pivot
        swap(nums, j, left);
        // 交换以后 [left, j - 1] < pivot, nums[j] = pivot, [j + 1, right] >= pivot
        return j;
    }

    private void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```
优先队列解法
```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int mid = nums.length/2;
        if(k < mid) {
            PriorityQueue<Integer> maxHeap = new PriorityQueue<>(nums.length, (a, b) -> b - a); 

            for(int num : nums) {
                maxHeap.offer(num);
            }

            for(int i = 1; i < k; i++) {
                maxHeap.poll();
            }

            return maxHeap.poll();
        } else {
            PriorityQueue<Integer> minHeap = new PriorityQueue<>(nums.length, (a, b) -> a - b); 

            for(int num : nums) {
                minHeap.offer(num);
            }

            int newK = nums.length - k;

            for(int i = 0; i < newK; i++) {
                minHeap.poll();
            }  

            return minHeap.poll();
        }
    }
}
```

## 148. 排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

进阶：

你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

[原地方法](https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-di-gui-die-dai-xiang-jie-by-cherr/)

```java
public class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }

        // 快慢指针寻找中点，（奇数中点，偶数偏左）
        ListNode fast = head.next; 
        ListNode slow = head;

        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // 中点为slow，切断
        ListNode mid = slow.next;
        slow.next = null;


        ListNode dummy = new ListNode(-1);
        ListNode node = dummy;

        ListNode left = sortList(head);
        ListNode right = sortList(mid);
        
        // merge
        while(left != null && right != null) {
            if(left.val < right.val) {
                node.next = left;
                left = left.next;
            } else {
                node.next = right;
                right = right.next;
            }
            node = node.next;
        }

        node.next = left != null ? left : right;
        return dummy.next;
    } 
}
```

## 75. 颜色分类
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

```
示例 1：
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

```java
class Solution {
    public void sortColors(int[] nums) {
        if(nums == null || nums.length == 0) {
            return ;
        }

        this.quickSort(nums, 0, nums.length-1);

        return ;
    }

    private void quickSort(int[] nums, int low, int high) {
        if(low >= high) {
            return;
        }

        int i = low, j = high, pivot = nums[low];

        while(i < j) {
            while(i < j && nums[j] >= pivot) {
                j--;
            }
            while(i < j && nums[i] <= pivot) {
                i++;
            }

            this.swap(nums, i, j);
        }

        this.swap(nums, i, low);

        this.quickSort(nums, low, i-1);
        this.quickSort(nums, i+1, high);

    }

    private void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```


# Hash
## 1. 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

```
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
```
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
```
```
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
```

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> hashTable = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            if(hashTable.containsKey(target - nums[i])) {
                return new int[] {hashTable.get(target - nums[i], i)};
            }
            hashTable.put(nums[i], i);
        }
        return new int[0];
    }
}
```

# special

## 621. 任务调度器
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

```
示例 1：

输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
```

> 关于取max： 当所有冷却时间都被利用上时，res == tasks.length, 否则用我们的桶算法，
[桶算法](https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/)

```java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        int len = tasks.length;
        if(len == 0) {
            return 0;
        }

        int[] map = new int[26]; // 用数组做计数，代替map
        int maxOccur = 0;

        for(char c : tasks) {
            int index = c - 'A';
            map[index]++;
            maxOccur = Math.max(maxOccur, map[index]);
        }

        int maxTaskNum = 0;

        for(int i : map) {
            if(i == maxOccur) {
                maxTaskNum++;
            }
        }

        int res = (n+1) * (maxOccur - 1) + maxTaskNum;

        return res > len ? res : len;
    }
}
```

## 448. 找到所有数组中消失的数字
给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
```
示例:
输入:
[4,3,2,7,8,2,3,1]
输出:
[5,6]
```

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for(int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i])-1;
            if(nums[index] > 0) { // 仅对未翻转的进行负反转，否则偶数出现的数字会被翻转偶数次，以至于还是正数，被认为是未出现的数。
                nums[index] *= -1;
            }
        }

        List<Integer> list = new ArrayList<>();
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] > 0) {
                list.add(i+1);
            }
        }

        return list;
    }
}
```

## 279. 完全平方数
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```
示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```
贪心解法
```java
class Solution {
    int min=Integer.MAX_VALUE;
    public int numSquares(int n) {
        dfs(n,1);
        return min;
    }
    // 从根号num -> 1 找尽可能大的平方数， 将计数+1然后 dfs（num - 该平方数）
    public void dfs(int num,int index){
        if(index >= min)return;
        int a= (int)Math.sqrt(num);
        for(int i=a; i>=1; i--)
        {
            if(num-i*i==0)
            {
                min=index;
                break;
            }
            else
                dfs(num-i*i,index+1);
        }
    }
}
```
DP解法
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for (int i = 1; i <= n; i++) {
            dp[i] = i;
            for (int j = 1; i - j*j >= 0; j++) {
                dp[i] = Math.min(dp[i], dp[i-j*j]+1);
            }
        }

        return dp[n];
    }
}
```

## 238. 除自身以外数组的乘积
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
```
示例:
输入: [1,2,3,4]
输出: [24,12,8,6]
```

、
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        int p = 1, q = 1; // 区别于py做法，用一个var存迄今的连乘，节省每次循环中再计算一次的时间

        for (int i = 0; i < nums.length; i++) {
            res[i] = p;
            p *= nums[i];
        }
        for (int i = nums.length - 1; i > 0 ; i--) {
            q *= nums[i];
            res[i - 1] *= q;
        }
        return res;
    }
}
```

## 146. LRU 缓存机制
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

```
示例：
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

```java
class Node {
    int key, value;
    Node prev, next;
    public Node() {}
    public Node(int key, int value) {
        this.key = key; 
        this.value = value;
        }
}

public class LRUCache {
    private Map<Integer, Node> cache = new HashMap<Integer, Node>();
    private int listSize;
    private int capacity;
    private Node head, tail;

    public LRUCache(int capacity) {
        this.listSize = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            Node newNode = new Node(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            listSize++;
            if (listSize > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                Node tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                listSize--;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private Node removeTail() {
        Node last = tail.prev;
        last.prev.next = tail;
        tail.prev = last.prev;

        return last;
    }

    private void moveToHead(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        addToHead(node);
    }
}
```

## 128. 最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

> 进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？

```
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```java
class Solution {

    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        for(int num : nums) {
            numSet.add(num);
        }
        int longestStreak = 0;

        for(int num : numSet) {
            if(!numSet.contains(num-1)) {
                int curNum = num;
                int curStreak = 1;

                while(numSet.contains(curNum+1)) {
                    curNum++;
                    curStreak++;
                }

                longestStreak = Math.max(curStreak, longestStreak);
            }
        }
        
        return longestStreak;
    }
}
```
[并查集连通连续数字的索引](https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/bing-cha-ji-lian-tong-lian-xu-shu-zi-de-n9t87/)

## 96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

本质catalan数列：G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)

```java
class Solution {
    public int numTrees(int n) {
        int[] catalan = new int[n+1];
        catalan[0] = 1; 
        catalan[1] = 1;

        for (int i = 2; i < n+1; i++) {
            for (int j = 0; j < i; j++) {
                catalan[i] += catalan[j] * catalan[i-1-j];
            }
        }

        return catalan[n];
    }
}
```

## 48. 旋转图像
给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

```
示例 1:
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```
[题解](https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/)
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}
```
## 56. 合并区间
给出一个区间的集合，请合并所有重叠的区间。
```
示例 1:
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (e1, e2) -> (e1[0] - e2[0]));
        List<int[]> res  = new ArrayList<>();

        for (int[] i : intervals) {
            // 如果结果数组是空的，或者当前区间的起始位置 > 结果数组中最后区间的终止位置，则不合并，直接将当前区间加入结果数组。
            if(res.isEmpty() || i[0] > upper) {
                res.add(i);
            } else { // 反之将当前区间合并至结果数组的最后区间
                res.get(res.size()-1)[1] = Math.max(upper, i[1]);
            }
        }

        return res.toArray(new int[0][0]);
    }
}
```