---
title: Rust Book
categories: Rust
tags:
- Rust
---

- [Warning and Error](#warning-and-error)
- [ShortCut](#shortcut)
- [1. Getting Started](#1-getting-started)
  - [1.1 First Program](#11-first-program)
  - [1.2 Cargo](#12-cargo)
    - [！！！Cargo 操作慢](#cargo-操作慢)
    - [使用 Cargo 创建项目](#使用-cargo-创建项目)
    - [Cargo.toml结构](#cargotoml结构)
    - [为没有使用Cargo的项目引入Cargo](#为没有使用cargo的项目引入cargo)
    - [Cargo构建与运行](#cargo构建与运行)
    - [发布（release）构建](#发布release构建)
  - [2. Guessing Game](#2-guessing-game)
    - [使用变量储存值](#使用变量储存值)
    - [静态方法](#静态方法)
    - [输入输出(std::io)](#输入输出stdio)
    - [使用 Result 类型来处理潜在的错误](#使用-result-类型来处理潜在的错误)
    - [使用 println! 占位符打印值](#使用-println-占位符打印值)
    - [使用crate](#使用crate)
    - [Cargo.lock 文件确保构建是可重现的](#cargolock-文件确保构建是可重现的)
    - [更新 crate 到一个新版本](#更新-crate-到一个新版本)
    - [使用rand生成一个随机数](#使用rand生成一个随机数)
    - [比较猜测的数字和秘密数字](#比较猜测的数字和秘密数字)
    - [静态强类型 \& 类型推断](#静态强类型--类型推断)
    - [使用循环来允许多次猜测](#使用循环来允许多次猜测)
    - [处理无效输入](#处理无效输入)
- [3. Common Programming Concepts](#3-common-programming-concepts)
  - [3.1 Variables and Mutability](#31-variables-and-mutability)
    - [可变性](#可变性)
    - [常量](#常量)
    - [隐藏](#隐藏)
  - [3.2 数据类型](#32-数据类型)
    - [标量类型](#标量类型)
      - [数值运算](#数值运算)
      - [字符类型](#字符类型)
    - [复合类型](#复合类型)
      - [元组类型](#元组类型)
      - [数组类型](#数组类型)
      - [访问数组元素](#访问数组元素)
  - [3.2 函数](#32-函数)
    - [](#)
    - [具有返回值的函数](#具有返回值的函数)
  - [3.4 注释](#34-注释)
  - [3.5 控制流](#35-控制流)
    - [if](#if)
    - [else if](#else-if)
    - [loop、while 和 for](#loopwhile-和-for)
      - [loop](#loop)
      - [循环标签：在多个循环之间消除歧义](#循环标签在多个循环之间消除歧义)
      - [while](#while)
      - [for](#for)
- [4. Understanding Ownership](#4-understanding-ownership)
  - [4.1 什么是所有权？](#41-什么是所有权)
    - [所有权规则](#所有权规则)
    - [变量作用域](#变量作用域)
    - [演示所有权的规则 - String 类型](#演示所有权的规则---string-类型)
    - [变量与数据交互的方式（一）：移动](#变量与数据交互的方式一移动)
    - [变量与数据交互的方式（二）：克隆](#变量与数据交互的方式二克隆)
      - [只在栈上的数据：拷贝](#只在栈上的数据拷贝)
      - [Trait: Copy](#trait-copy)
      - [所有权与函数](#所有权与函数)
      - [返回值与作用域](#返回值与作用域)
  - [4.2 引用与借用](#42-引用与借用)
      - [尝试修改借用的变量](#尝试修改借用的变量)
    - [可变引用](#可变引用)
    - [悬垂引用（Dangling References）](#悬垂引用dangling-references)
  - [4.3 Slice 类型](#43-slice-类型)
      - ['' 和 b''](#-和-b)
      - [\&str 和 String](#str-和-string)
    - [其他类型的 slice](#其他类型的-slice)
- [5. `Structs` to Structure Related Data](#5-structs-to-structure-related-data)
  - [5.1 结构体的定义和实例化](#51-结构体的定义和实例化)
      - [访问和修改属性](#访问和修改属性)
      - [Builder](#builder)
    - [使用`结构体更新`语法从其他实例创建实例](#使用结构体更新语法从其他实例创建实例)
    - [元组结构体（tuple structs）](#元组结构体tuple-structs)
    - [类单元结构体（unit-like structs）](#类单元结构体unit-like-structs)
  - [5.2 结构体示例程序](#52-结构体示例程序)
    - [通过派生 trait 增加实用功能](#通过派生-trait-增加实用功能)
    - [使用 dbg!](#使用-dbg)
  - [5.3 方法语法](#53-方法语法)
      - [getter](#getter)
      - [-\> 运算符到哪去了？](#--运算符到哪去了)
    - [带有更多参数的方法](#带有更多参数的方法)
    - [关联函数](#关联函数)
- [6. Enums and Pattern Matching](#6-enums-and-pattern-matching)
    - [Option 枚举和其相对于空值的优势](#option-枚举和其相对于空值的优势)
  - [6.2 match 控制流结构](#62-match-控制流结构)
    - [绑定值的模式](#绑定值的模式)
    - [匹配 Option](#匹配-option)
    - [匹配是穷尽的(exhaustive)](#匹配是穷尽的exhaustive)
    - [通配模式和 \_ 占位符](#通配模式和-_-占位符)
  - [6.3 if let 简洁控制流](#63-if-let-简洁控制流)
- [7. Packages, Crates, and Modules](#7-packages-crates-and-modules)
  - [7.1 Package 和 Crate](#71-package-和-crate)
    - [Crate](#crate)
    - [Package](#package)
  - [7.2 定义模块来控制作用域与私有性](#72-定义模块来控制作用域与私有性)
    - [Module](#module)
    - [对相关代码进行分组](#对相关代码进行分组)
  - [7.3 引用模块项目的路径](#73-引用模块项目的路径)
    - [使用 pub 关键字暴露路径](#使用-pub-关键字暴露路径)
      - [executable 和 library 的最佳实践](#executable-和-library-的最佳实践)
    - [super 开始的相对路径](#super-开始的相对路径)
    - [创建公有的结构体和枚举](#创建公有的结构体和枚举)
  - [7.4 使用 use 关键字将路径引入作用域](#74-使用-use-关键字将路径引入作用域)
    - [使用 as 关键字提供新的名称](#使用-as-关键字提供新的名称)
    - [使用 pub use 重导出名称](#使用-pub-use-重导出名称)
    - [使用外部包](#使用外部包)
    - [嵌套路径来消除大量的 use 行](#嵌套路径来消除大量的-use-行)
    - [通过 glob 运算符(\*)将所有的公有定义引入作用域](#通过-glob-运算符将所有的公有定义引入作用域)
  - [7.5 将模块拆分成多个文件](#75-将模块拆分成多个文件)
- [8. 常见集合](#8-常见集合)
  - [8.1 Vector](#81-vector)
    - [Create](#create)
    - [Update](#update)
    - [Access](#access)
      - [借用规则与读取vec元素](#借用规则与读取vec元素)
    - [遍历 vector 中的元素](#遍历-vector-中的元素)
    - [使用枚举来储存多种类型](#使用枚举来储存多种类型)
    - [丢弃 vector 时也会丢弃其所有元素](#丢弃-vector-时也会丢弃其所有元素)
  - [8.2 字符串(String) 和 UTF-8 encoded Text](#82-字符串string-和-utf-8-encoded-text)
    - [新建字符串](#新建字符串)
    - [更新字符串](#更新字符串)
      - [push\_str](#push_str)
      - [+](#-1)
      - [format!](#format)
    - [索引字符串](#索引字符串)
    - [遍历字符串的方法](#遍历字符串的方法)
  - [8.3 HashMap and Key-Value entry](#83-hashmap-and-key-value-entry)
    - [新建一个哈希 map](#新建一个哈希-map)
    - [访问哈希 map 中的值](#访问哈希-map-中的值)
    - [哈希 map 和所有权](#哈希-map-和所有权)
    - [更新哈希 map](#更新哈希-map)
    - [哈希函数](#哈希函数)
- [9.错误处理](#9错误处理)
  - [9.1 用 panic! 处理不可恢复的错误](#91-用-panic-处理不可恢复的错误)
      - [对应 panic 时的栈展开或终止](#对应-panic-时的栈展开或终止)
    - [使用 panic! 的 backtrace](#使用-panic-的-backtrace)
      - [设置 RUST\_BACKTRACE 环境变量](#设置-rust_backtrace-环境变量)
  - [9.2 用 Result 处理可恢复的错误](#92-用-result-处理可恢复的错误)
    - [匹配不同的错误](#匹配不同的错误)
      - [使用闭包代替match和Result\<T, E\>](#使用闭包代替match和resultt-e)
    - [失败时 panic 的简写：unwrap 和 expect](#失败时-panic-的简写unwrap-和-expect)
    - [传播错误](#传播错误)
    - [传播错误的简写：? 运算符](#传播错误的简写-运算符)
  - [9.3 要不要 panic!](#93-要不要-panic)


# Warning and Error

- Cargo更新下载慢
    换源, `/Users/<your user name>/.cargo` 下新建config文件：
    ```xml
    [source.crates-io]
    registry = "https://github.com/rust-lang/crates.io-index"

    replace-with = 'ustc'

    [source.ustc]
    registry = "git://mirrors.ustc.edu.cn/crates.io-index"
    ```

- `No Cargo projects are found`
    
    这个错误通常意味着CLion无法找到任何Cargo项目，因此它无法在您的Rust代码上运行Cargo命令。
    
    检错：
    1. 确保您位于正确的目录中：导航到Rust项目的根目录。这是包含Cargo.toml文件的目录。您应该从此目录运行货物命令。
    2. 初始化Rust项目：如果您不在包含Cargo.toml文件的目录中，则可以通过运行以下命令来初始化新的Rust项目：
    > `cargo new your_project_name`

    extra:
    使用rust rover新建项目之后第一次cargo check完成以前会报这个错。等初始化完成就好了



- `module declaration missing`

- 检查模块声明(Check Module Declarations)：验证您已经在Rust代码中声明了模块。在Rust中，使用mod关键字声明模块。例如：
    ```rust
    // In your main.rs or lib.rs file
    mod my_module;
    ```


# ShortCut

- `cmd + option + t`: 包裹代码块

# 1. Getting Started
## 1.1 First Program

编译：`rustc main.rs`

编译完成会生成可执行文件`main.exe`, 包含调试信息文件`main.pdb`

## 1.2 Cargo
`cargo --version` 查看版本

### ！！！Cargo 操作慢


### 使用 Cargo 创建项目

`cargo new hello_cargo` 默认会在 hello_cargo 目录初始化一个 git 仓库, 以及一个.gitignore 文件

如果在一个已经存在的 git 仓库中运行 cargo new，则这些 git 相关文件则不会生成；可以通过运行 `cargo new --vcs=git` 来覆盖这些行为。

### Cargo.toml结构
```rust
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

`[dependencies]`，是罗列项目依赖的片段的开始。在 Rust 中，代码包被称为 `crates`。

Cargo 期望源文件存放在 src 目录中。项目根目录只存放 README、license 信息、配置文件和其他跟代码无关的文件。使用 Cargo 帮助你保持项目干净整洁，一切井井有条。

### 为没有使用Cargo的项目引入Cargo
要在任何已存在的项目上工作时，可以使用如下命令通过 Git 检出代码，移动到该项目目录并构建：

```rust
$ git clone example.org/some_project
$ cd some_project
$ cargo build
```

### Cargo构建与运行
1. `build`: 在根目录下运行 `cargo build`, 会创建一个可执行文件 `target/debug/hello_cargo`。
   - 由于默认的构建方法是`调试构建（debug build）`，Cargo 会将可执行文件放在名为 `debug` 的目录中。
   - 首次运行 `cargo build` 时，也会使 Cargo 在项目根目录创建一个新文件：`Cargo.lock`。这个文件记录项目依赖的实际版本。这个项目并没有依赖，所以其内容比较少。你自己永远也不需要碰这个文件，让 Cargo 处理它就行了。
2. `run`: 同时编译并运行生成的可执行文件。
   - Cargo 会检查源文件是否有修改，如果没有它就不用重新编译，而是直接运行了可执行文件。如果修改了源文件的话，Cargo 会在运行之前重新构建项目
3. `check`: 快速检查代码确保其可以编译，但并`不产生可执行文件`。
   - 通常 `cargo check` 要比 `cargo build` 快得多，因为它省略了生成可执行文件的步骤。
   - 如果你在编写代码时持续的进行检查，`cargo check` 可以让你快速了解现在的代码能不能正常通过编译！当准备好使用可执行文件时才运行 `cargo build`

### 发布（release）构建
当项目最终准备好发布时，可以使用 `cargo build --release` 来`优化`编译项目。这会在 `target/release` 而不是 `target/debug` 下生成可执行文件。

这些优化可以让 Rust 代码运行的更快，不过启用这些优化也需要消耗更长的编译时间。

如果你在测试代码的运行时间，请确保运行 `cargo build --release` 并使用 target/release 下的可执行文件进行测试。


## 2. Guessing Game

默认情况下，Rust 设定了若干个会自动导入到每个程序作用域中的标准库内容，这组内容被称为 `预导入（preclude）` 内容。

如果你需要的类型不在预导入内容中，就必须使用 `use` 语句显式地将其引入作用域。

`std::io` 库提供很多有用的功能，包括接收用户输入的功能。

### 使用变量储存值
在 Rust 中，`变量默认是不可变的`，这意味着一旦我们给变量赋值，这个值就不再可以修改了。

在变量名前使用 `mut` 来使一个变量可变:
```rust
let apples = 5; // 不可变
let mut bananas = 5; // 可变
```

### 静态方法
```rust
let mut guess = String::new();
```
`:: `语法表明 `new` 是 `String` 类型的一个 `关联函数（associated function）`。

关联函数是针对类型实现的，在这个例子中是 String，而不是 String 的某个特定实例。一些语言中把它称为 `静态方法（static method）`。

### 输入输出(std::io)
```rust
    io::stdin()
        .read_line(&mut guess)
        .`expect`("Failed to read line");
```
- 如果程序的开头没有使用 use std::io; 引入 io 库，我们仍可以通过把函数调用写成 std::io::stdin 来使用函数。
- 调用 `read_line` 方法从标准输入句柄获取用户输入。将 `&mut guess` 作为参数传递给 `read_line()` 函数，让其将用户输入储存到这个字符串中。
- `read_line` 的工作是，无论用户在标准输入中键入什么内容，都将其`追加（不会覆盖其原有内容）`到一个字符串中，因此它需要字符串作为参数。
- `&` 表示这个参数是一个 `引用（reference）`，它允许多处代码访问同一处数据，而无需在内存中多次拷贝。


### 使用 Result 类型来处理潜在的错误

```rust
    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");
```
- `read_line` 会将用户输入附加到传递给它的字符串中，返回一个类型为 `Result` 的值
- `Result` 是一种枚举类型，通常也写作 `enum` 。枚举类型变量的值可以是`多种可能状态`中的一个。我们把每种可能的状态称为一种 `枚举成员（variant）`。
- `Result` 的成员是 `Ok` 和 `Err`:
  - `Ok` 成员表示操作成功，内部包含成功时产生的值。 
  - `Err` 成员则意味着操作失败，并且包含失败的前因后果。
- `Result` 的实例拥有 `expect` 方法。
  - 如果 `io::Result` 实例的值是 `Err` ， `expect` 会导致程序崩溃，并显示当做参数传递给 `expect` 的信息。
  - 如果 `Result` 实例的值是 `Ok`, `expect` 会获取 `Ok` 中的值并原样返回。在本例中，这个值是用户输入到标准输入中的字节数。

### 使用 println! 占位符打印值

`{} `是预留在特定位置的占位符.

当打印变量的值时，`变量名可以写进大括号中`。当打印表达式的执行结果时，格式化字符串（format string）中大括号中留空，格式化字符串后跟逗号分隔的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。

```rust
let x = 5;
let y = 10;
println!("x = {x} and y + 2 = {}", y + 2);
```
这行代码会打印出` x = 5` and `y + 2 = 12`。

### 使用crate
`crate` 分为`库crate`和`二进制crate`：
  - 库crate 可以包含任意能被其他程序使用的代码，但是不能自执行
  - 二进制crate，如我们正在构建的项目，它生成一个可执行文件

Cargo 对外部 crate 的运用是其真正的亮点所在。在我们使用 rand 编写代码之前，需要修改 Cargo.toml 文件，引入一个 rand 依赖。
```toml
[dependencies]
rand = "0.8.5"
```
> 0.8.5 事实上是 `^0.8.5 `的简写，它表示任何至少是 0.8.5 但小于 0.9.0 的版本。


### Cargo.lock 文件确保构建是可重现的

Cargo 有一个机制来确保任何人在任何时候重新构建代码，都会产生相同的结果：Cargo 只会使用你指定的依赖版本，除非你又手动指定了别的。

Rust 在你第一次运行 `cargo build` 时建立了 Cargo.lock 文件, 当将来构建项目时，Cargo 会发现 Cargo.lock 已存在并使用其中指定的版本，而不是再次计算所有的版本. 例如，如果下周 rand crate 的 0.8.6 版本出来了，它修复了一个重要的 bug，同时也含有一个会破坏代码运行的缺陷, 多亏有了 Cargo.lock 文件, 项目会持续使用 0.8.5 直到你显式升级。


### 更新 crate 到一个新版本
`cargo update` 会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本. Cargo 接下来会把这些版本写入 Cargo.lock 文件。

不过，Cargo 默认只会寻找大于 0.8.5 而小于 0.9.0 的版本。如果想要使用 0.9.0 版本的 rand 或是任何 0.9.x 系列的版本，必须像这样更新 Cargo.toml 文件：
```toml
[dependencies]

rand = "0.9.0"
```
下一次运行 `cargo build` 时，Cargo 会从 registry 更新可用的 crate，并根据你指定的新版本重新计算。


### 使用rand生成一个随机数
```rust
use rand::Rng;
// ...
    let secret_number =
        rand::thread_rng()
            .gen_range(1..=100);
```
- `Rng` 是一个 `trait` ，它定义了随机数生成器应实现的方法
- `rand::thread_rng` 函数提供实际使用的随机数生成器：它位于当前执行线程的本地环境中，并从操作系统获取 seed
- 接着调用随机数生成器的 `gen_range` 方法: 获取一个范围表达式（range expression）作为参数，并生成一个在此范围之间的随机数:
  - 这里使用的这类范围表达式使用了 `start..=end` 这样的形式，也就是说包含了上下端点，所以需要指定 `1..=100` 来请求一个 1 和 100 之间的数。

> 你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法，因此每个 crate 有使用说明文档。
> Cargo 有一个很棒的功能是：运行 `cargo doc --open` 命令来构建所有本地依赖提供的文档，并在浏览器中打开。
> 例如，假设你对 rand crate 中的其他功能感兴趣，你可以运行 `cargo doc --open` 并点击左侧导航栏中的 rand。


### 比较猜测的数字和秘密数字
```rust
use std::cmp::Ordering;

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }

```
- `Ordering` 也是一个枚举，不过它的成员是 `Less` `、Greater` 和 `Equal` 。这是比较两个值时可能出现的三种结果。
- `cmp` 方法用来比较两个值, 并可以在任何可比较的值上调用。它获取一个被比较值的引用：这里是把 guess 与 secret_number 做比较。然后它会返回一个 `Ordering` 枚举的成员。
- `match` 表达式，根据对 guess 和 secret_number 调用 cmp 返回的 Ordering 成员来决定接下来做什么。


### 静态强类型 & 类型推断
Rust 有一个`静态强类型`系统，同时也有`类型推断`。

当我们写出 `let guess = String::new()` 时，Rust 推断出 `guess` 应该是 `String` 类型，并不需要我们写出类型。

另一方面，`secret_number`，是数字类型。Rust 默认使用 `i32` ，所以它是 secret_number 的类型，除非增加类型信息，或任何能让 Rust 推断出不同数值类型的信息。
> Rust的一些数字类型的值可以介于1和100之间：i32为 32位数字；u32为 无符号32位数字；i64为64位数字；以及其他

所以我们必须把从输入中读取到的 `String` 转换为一个真正的数字类型，才好与 `secret_number` 进行比较。

```rust
    let guess: u32 =
        guess.trim()
            .parse()
            .expect("Please type a number!");
```
这里创建了一个叫做 guess 的变量。不过等等，不是已经有了一个叫做 guess 的变量了吗？确实如此，不过 Rust 允许用一个新值来 `隐藏 （Shadowing）` guess 之前的值。这个功能常用在需要`转换值类型`之类的场景。它允许我们`复用 guess` 变量的名字，而不是被迫创建两个不同变量，诸如 guess_str 和 guess 之类。

- String 实例的 `trim` 方法会去除字符串开头和结尾的空白字符. 
  - 用户必须输入 `enter` 键才能让 read_line 返回并输入他们的猜想，这将会在字符串中增加一个`换行（newline）符`。
  - 例如，用户输入 5 并按下 enter（在 Windows 上，按下 enter 键会得到一个回车符和一个换行符，`\r\n`），guess 看起来像这样：5\n 或者 5\r\n。
  - \n 代表 “换行”; \r 代表 “回车”
  - trim 方法会消除 \n 或者 \r\n，只留下 5。


String 实例的 `parse` 方法 将字符串转换成其他类型。
  - 这里用它来把字符串转换为数值。
  - 我们需要告诉 Rust 具体的数字类型，guess 后面的冒号 `:` 指定了变量的类型 `u32`
  - `parse` 方法只有在 String 逻辑上可以转换为数字的时候才能工作, 所以非常容易出错。因此，`parse` 方法返回一个 `Result` 类型。如果 `parse` 不能从字符串生成一个数字，返回一个 `Err` 成员


### 使用循环来允许多次猜测

`loop` 关键字创建了一个无限循环。我们会增加循环来给用户更多机会猜数字：

```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
```

我们想要当猜测正确的数字时游戏停止, 增加一个 `break` 语句:
```rust
    loop {
        print!("You guessed: {guess}");

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
```

退出循环也意味着退出程序，因为循环是 main 的最后一部分。

### 处理无效输入
```rust
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
```
- 我们将 `expect` 调用换成 `match` 语句，以从遇到错误就崩溃转换为处理错误.
- `Err(_)` 模式：`_` 是一个通配符值，本例中用来匹配所有 Err 值，不管其中有何种信息
- break, continue必须处于loop中


# 3. Common Programming Concepts
## 3.1 Variables and Mutability
### 可变性
Rust变量默认是不可改变的（immutable）: 当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。 否则就会报错
Error: `cannot assign twice to immutable variable`

不过`可变性`也是非常有用的，尽管变量默认是不可变的，你仍然可以在变量名前添加 `mut` 来使其可变

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
通过 `mut` ，允许把绑定到 x 的值从 5 改成 6。

### 常量
类似于不可变变量，`常量 (constants)` 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别：
- 不允许对常量使用 `mut`, 常量不光默认不可变，它总是不可变。
- 声明常量使用 `const` 关键字而不是 let，并且 `必须 注明值的类型`。
- 常量可以在任何作用域中声明，包括`全局作用域`，这在一个值需要被很多部分的代码用到时很有用。
- 常量只能被设置为`常量表达式`，而`不可以是`其他任何`只能在运行时计算出的值`。
- Rust 对常量的`命名约定`是在单词之间使用全大写加下划线
  
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

> 在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。
>
> 将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。

### 隐藏
我们可以定义一个与之前变量同名的新变量。实际上，第二个变量“遮蔽”了第一个变量， 此时任何使用该变量名的行为，编译器将其视为是在使用第二个变量，直到第二个变量自己也被隐藏或第二个变量的作用域结束。

可以用相同变量名称来隐藏一个变量，以及`重复使用 let 关键字来多次隐藏`，如下所示：
```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

// The value of x in the inner scope is: 12
// The value of x is: 6
```

`隐藏`与将变量标记为 `mut` 是有区别的: 
- 当不小心尝试对变量重新赋值时，如果没有使用 `let` 关键字，就会导致编译时错误。
- 通过使用 `let` ，我们可以用这个值进行一些计算，不过计算完之后变量仍然是`不可变`的。
- 当再次使用 `let` 时，实际上创建了一个`新变量`，我们可以改变值的`类型`，并且复用这个名字。
    ```rust
        let spaces = "   "; // 字符串类型
        let spaces = spaces.len(); // 数字类型
    ```


## 3.2 数据类型

Rust 是 `静态类型（statically typed）`语言，也就是说在`编译时`就必须知道所有变量的类型。

根据值及其使用方式，编译器通常可以`推断`出我们想要用的类型。
当多种类型均有可能时，必须增加`类型注解`:
```rust
let guess: u32 = "42".parse().expect("Not a number!"); // 类型注解 : u32
```
> 缺乏类型注解报错
> error[E0282]: type annotations needed 


### 标量类型

`标量（scalar）`类型代表一个单独的值。Rust 有四种基本的标量类型：
- 整型
- 浮点型
- 布尔类型
- 字符类型

#### 数值运算
```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // 结果为 -1

    // remainder
    let remainder = 43 % 5;
}
```
> `整数除法`会向`零舍入到最接近的整数`。


#### 字符类型
Rust 的 `char` 类型是语言中最原生的字母类型
```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```
- 用单引号声明 `char` 字面量. `char` 类型的大小为四个字节 (four bytes)
- 使用双引号声明 `字符串字面量(String Literals)`， 其数据类型为`&str`

### 复合类型
`复合类型（Compound types）`可以将多个值组合成一个类型。Rust 有`两个原生的复合类型`：
- 元组（tuple）
- 数组（array）

#### 元组类型

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。

元组`长度固定`：一旦声明，其长度不会增大或缩小。

```rust
fn main() {
    let tup = (500, 6.4, 1);
    // let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (x, y, z) = tup; // 模式匹配（pattern matching）来解构（destructure）元组值

    println!("The value of y is: {y}");

    // 我们也可以使用点号（.）后跟值的索引来直接访问它们。
    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```
访问元组元素：
- 模式匹配（pattern matching）来解构（destructure）元组值
- 使用`点号（.）`后跟值的索引来直接访问它们。

#### 数组类型

另一个包含多个值的方式是 数组（array）: 
- 数组中的`每个元素的类型必须相同`。
- 数组`长度是固定`的。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // 在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组
    // let a = [3, 3, 3, 3, 3]; 效果相同
    let a = [3; 5];

}

```

#### 访问数组元素
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    // 索引访问
    let first = a[0];
    let second = a[1];
}
```
> 访问越界: 如果我们访问数组结尾之后的元素时，导致 `运行时 错误(panic)`。程序带着错误信息退出


## 3.2 函数

函数拥有 `参数（parameters）（形参）`的函数，参数是特殊变量，是函数签名的一部分
为这些参数提供具体的`值（实参）`。技术上讲，这些具体值被称为参数（arguments），


在函数签名中，`必须声明每个参数的类型`。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。

### 

`语句（Statements）`是执行一些操作但不返回值的指令:
- `let y = 6;` 是一个语句。
- `语句`不返回值。因此，不能把 let 语句赋值给另一个变量

`表达式（Expressions）`计算并产生一个值:
- 语句 `let y = 6; `中的 `6` 是一个表达式
- 用大括号创建的一个新的块作用域也是一个表达式，例如：
   ```rust
   let y = {
        let x = 3;

        // 注意 x+1 这一行在结尾没有分号，与你见过的大部分代码行不同。
        // 如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值
        x + 1 
    };
   ```
   y的值是 4



### 具有返回值的函数

在 Rust 中，函数的返回值等同于函数体`最后一个表达式`的值。
```rust
fn five() -> i32 {
    5
}
```

使用 `return` 关键字和指定值，可从函数中提前返回

> 用最后一个表达式返回值时不要加`分号`


## 3.4 注释

用双斜杠` // `注释 Rust 代码

文档注释使用三斜杠 `///` 而以支持 Markdown 注解来格式化文本。
```rust 
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```


## 3.5 控制流

### if

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```
> 不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是`显式地使用布尔值`作为 if 的条件。


### else if
```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }

    // 在 let 语句中使用 if
    let number = if condition { 5 } else { 6 };
}
```
> 使用过多的 else if 表达式会使代码显得杂乱无章，所以如果有多于一个 else if 表达式，最好重构代码。为此，第六章会介绍一个强大的 Rust 分支结构（branching construct），叫做 `match`。


### loop、while 和 for
#### loop
```rust
// loop
fn main() {
    let mut counter = 0;
    
    // 赋值给 result 
    let result = loop {
        counter += 1;

        if counter == 10 {
            // 使用 break 关键字返回值 counter * 2
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```
#### 循环标签：在多个循环之间消除歧义
如果存在嵌套循环，break 和 continue 应用于此时`最内层的循环`。
你可以选择在一个循环上指定一个 `循环标签（loop label）`，然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。

```rust
// loop
fn main() {
    let mut count = 0;

    // 标签 counting_up
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```


#### while
```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```


#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }

    // 使用 for 循环来倒计时
    // rev，用来反转 range
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

# 4. Understanding Ownership
所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全.

## 4.1 什么是所有权？
> Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

在像 Rust 这样的系统编程语言中，`值是位于栈上还是堆上`在更大程度上影响了语言的行为以及为何必须做出这样的抉择。

栈中的所有数据都必须占用已知且固定的大小。

大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。

入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间. 其位置总是在栈顶

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。

> 跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。


### 所有权规则
- Rust 中的每一个值都有一个 所有者（owner）。
- 值在任一时刻有且只有一个所有者。
- 当所有者（变量）离开作用域，这个值将被丢弃。


### 变量作用域
```rust
    {                      // s 在这里无效，它尚未声明
        let s = "hello";   // 从此处起，s 是有效的

        // 使用 s
    }                      // 此作用域已结束，s 不再有效
```


### 演示所有权的规则 - String 类型

我们已经见过`字符串字面值(String literals)`，即被硬编码进程序里的字符串值。 字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。
- 原因之一就是`它们是不可变的`。
- 另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？

> 为此，Rust 有第二个字符串类型，`String`。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。

```rust
    // 使用 from 函数基于字符串字面值来创建 String
    let mut s = String::from("hello");

    // String 可以修改
    s.push_str(", world!"); // push_str() 在字符串后追加字面值

    println!("{}", s); // 将打印 `hello, world!`
```

对于 `String` 类型，为了支持一个`可变，可增长`的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
- 必须在`运行时`向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 `String` 时将不再使用的内存返还给分配器的方法。

> Rust 采取了一个不同的策略：内存在`拥有它的变量离开作用域后`就被自动释放。

当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop` ，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的` } `处自动调用 `drop` 。


### 变量与数据交互的方式（一）：移动

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```
指针s1和s2同时指向同一块内存，是 `浅拷贝`。
这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 `二次释放（double free）`的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

为了确保内存安全，在 let s2 = s1; 之后，Rust `认为 s1 不再有效`，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

因而在 s2 被创建之后尝试使用 s1 会发生：`error[E0382]: borrow of moved value: s1`

> 如果你在其他语言中听说过术语 `浅拷贝（shallow copy）`和 `深拷贝（deep copy）`，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。`不过因为 Rust 同时使第一个变量无效了`，这个操作被称为 `移动（move）`，而不是叫做浅拷贝。

> 这里还隐含了一个设计选择：`Rust 永远也不会自动创建数据的 “深拷贝”`。因此，可以假定任何自动复制在运行时性能方面都是廉价的。


### 变量与数据交互的方式（二）：克隆
如果我们确实需要 `深度复制` String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。
```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

#### 只在栈上的数据：拷贝
```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

像`整型`这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。


#### Trait: Copy
Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的`存储在栈上的类型`上.
如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。
Rust 不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait。

作为一个通用的规则，任何一组`简单标量值的组合`都可以实现 `Copy` ，
任何`不需要分配内存或某种形式资源的类型`都可以实现 `Copy` 。


#### 所有权与函数

将值传递给函数与给变量赋值的原理相似。
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，
                                    // 所以在后面可继续使用 x

} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 没有特殊之处

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。
  // 占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。没有特殊之处
```

当尝试在调用 `takes_ownership` 后使用 `s` 时，Rust 会抛出一个编译时错误。


#### 返回值与作用域

> 返回值也可以转移所有权。变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 转移给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到takes_and_gives_back 中, 它也将返回值移给 s3                                 
    // takes_and_gives_back返回后s2即被drop


} // 这里，s3，s1移出作用域并被丢弃。

fn gives_ownership() -> String {

    let some_string = String::from("yours");
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

在每一个函数中都获取所有权并接着返回所有权有些啰嗦。
如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了.
-> Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 `引用（references）`

除此之外，我们也可能想返回函数体中产生的一些数据。
-> 我们可以使用`元组`来返回多个值


## 4.2 引用与借用
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    // calculate_length完成后并不会drop s1
    println!("The length of '{}' is {}.", s1, len);
}

// s 是 String 的引用
fn calculate_length(s: &String) -> usize {
    s.len()
}
// 当 s 停止使用时并不丢弃引用指向的数据，因为 s 并没有所有权。
```

`&s1 `语法让我们创建一个 `指向 值 s1 `的引用，但是并不拥有它。
因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。

#### 尝试修改借用的变量
```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
> 试图修改引用的参数会报错：error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference

### 可变引用
通过一个小调整就能允许我们修改一个借用的值,`可变引用（mutable reference）`：
- 我们必须将 `s` 改为 `mut`。
- 然后在调用 change 函数的地方创建一个可变引用 `&mut s`
- 并更新函数签名以接受一个可变引用 `some_string: &mut String`

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
可变引用有一个很大的限制：
- 如果你有一个对该变量的可变引用，在这个可变引用不再使用前，你不能再创建另一个可变引用。
- 我们 也 不能在拥有不可变引用的同时拥有可变引用。
> 尝试创建两个 s 的可变引用的代码会失败: error[E0499]: cannot borrow `s` as mutable more than once at a time

这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。
这个限制的好处是 Rust 可以在编译时就避免`数据竞争`。

> 注意一个引用的作用域从声明的地方开始一直`持续到最后一次使用为止`。



### 悬垂引用（Dangling References）
在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 `悬垂指针（dangling pointer）`，所谓悬垂指针是`其指向的内存可能已经被分配给其它持有者`。

> 下述代码会报错：error[E0106]: missing lifetime specifier

```rust
fn main() {
    let reference_to_nothing = dangle();
}


// 返回一个String的引用
fn dangle() -> &String {
    let s = String::from("hello");

    &s
    // 预期返回s的引用，但注意此函数完成后s本身会被drop，因而返回的引用指向null
}
```


## 4.3 Slice 类型

`slice` 允许你引用集合中一段连续的元素序列，而不用引用整个集合。
`slice` 是引用，所以它没有所有权。

> usize 是 Rust 编程语言中的一种整数类型，它代表无符号整数。
> 它的大小取决于运行 Rust 代码的计算机架构，通常是与计算机的指针大小相同。在 32 位计算机上，usize 是 32 位无符号整数，而在 64 位计算机上，usize 是 64 位无符号整数。


#### '' 和 b''
注意：' ' 是 Rust 中的 char 字面值，它可以包含单个字符，
而 b' ' 是字节字面值，只包含一个字节。
在 Rust 中，字符字面值通常用于表示文本字符，而字节字面值用于处理二进制数据。


#### &str 和 String 
`&str：` 是一个字符串切片，它是一个`不可变引用（immutable reference）`，通常用于引用字符串文本的一部分，例如从一个 String 或字符串字面值中提取的子串。由于 str 是不可变的，你不能对其进行修改。str 类型通常用于参数传递和字符串处理的引用形式。

`String：`是 Rust 的标准库中提供的可变的、拥有（owned）的字符串类型。它是一个堆分配的字符串，可以随时进行增加、删除和修改操作。String 通常用于需要动态分配和修改字符串内容的情况。

> 当编写函数的入参为字符串时，最好让其类型为`&str`，如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。
> 定义一个获取 `&str` 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：


### 其他类型的 slice
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // data type of slice: &[i32]

assert_eq!(slice, &[2, 3]);
```


# 5. `Structs` to Structure Related Data
struct或structure是一种自定义数据类型，允许您将多个相关的值打包在一起并命名，这些值组成一个有意义的组。
如果您熟悉面向对象的语言， `struct` 就像对象的数据属性。在本章中，我们将比较和对比 `tuple` 和 `struct` ，以建立在您已经知道的基础上，并演示 `struct` 是分组数据的更好方法。

我们将演示如何定义和实例化 `struct` 。我们将讨论如何定义关联函数，特别是称为方法的关联函数，以指定与 `struct` 类型关联的行为。 `Structs` 和 `Enum` (在第6章中讨论)是在程序域中创建新类型以充分利用Rust的编译时类型检查的构建块。

## 5.1 结构体的定义和实例化

```rust
// Def
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
> 结构体数据的所有权: 我们使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型。
> 这是一个有意而为之的选择，因为我们想要这个结构体`拥有它所有的数据`，为此只要整个结构体是有效的话其数据也是有效的。
> 要使结构体存储`被其他对象拥有的数据的引用`, 需要用上 `生命周期（lifetimes）`

#### 访问和修改属性
注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变

```rust
fn main() {
    // Initialize an instance
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    // Access attribute with `.`
    // Modify attribute requires struct to be mutable
    user1.email = String::from("anotheremail@example.com");
}
```

#### Builder
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}

// 为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 email 和 username 字段名称与变量有些啰嗦。
// 如果结构体有更多字段，重复每个名称就更加烦人了。幸运的是，有一个方便的简写语法！
fn build_user_compact(email: String, username: String) -> User {
    User {
        active: true,
        // 使用了字段初始化简写语法，因为 username 和 email 参数与结构体字段同名
        username,
        email,
        sign_in_count: 1,
    }
}
```

### 使用`结构体更新`语法从其他实例创建实例

`使用旧实例的大部分值`但`改变其部分值`来创建一个新的结构体实例通常是很有用的。这可以通过 `结构体更新语法（struct update syntax）`实现。

通过 `..` 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。

```rust
fn main() {
    let user2 = User {
        // 使用user1实例的属性
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,    
    };
}

// `..` 语法进一步减省
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
        // ..user1 必须放在最后
    };

```
> 请注意，`结构更新语法`就像带有 = 的赋值，因为它`移动`了数据
> 总体上说我们在创建 user2 后不能就再使用 user1 了，因为 user1 的 username 字段中的 String 被移到 user2 中.
> 但如果`更新的字段都是基础类型`如bool和i32，是`实现 Copy trait 的类型`。那么 user1 在创建 user2 后仍然有效


### 元组结构体（tuple structs）

元组结构体`有着结构体名称`提供的含义，但`没有具体的字段名`，只有字段的类型。

虽然Color，Point两个类型都由三个 i32 值组成，但black，origin是不同的元组结构体的实例

元组结构体实例类似于元组，你可以将它们`解构为单独的部分`，也`可以使用 . 后跟索引来访问单独的值`，等等。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
### 类单元结构体（unit-like structs）

我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）

类单元结构体常常在你想要`在某个类型上实现 trait 但不需要在类型中存储数据的时候`发挥作用

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```


## 5.2 结构体示例程序
```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn area(rectangle: Rectangle) -> u32 {
    rectangle.height * rectangle.width
}

pub(crate) fn main() {

    let rectangle = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rectangle)
    );
}
```

### 通过派生 trait 增加实用功能
`println! `宏能处理很多类型的格式，不过，`{}` 默认告诉 `println! `使用被称为 Display 的格式：意在提供给直接终端用户查看的输出。

目前为止见过的基本类型都默认实现了 `Display` ，因为它就是向用户展示 1 或其他任何基本类型的唯一方式。

对于结构体，`println!` 应该用来输出的格式是不明确的，因为这有更多显示的可能性：是否需要逗号？需要打印出大括号吗？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，所以`结构体并没有提供一个 Display 实现`来使用 `println!` 与 `{}` 占位符。

打印结构体时:
- 在 `{} `中加入 `:? `指示符告诉 `println!` 我们想要使用叫做 `Debug` 的输出格式。
- 结构体定义之前加上外部属性 #[derive(Debug)]

> 当我们有一个更大的结构体时，能有更易读一点的输出就好了，为此可以使用` {:#?}` 替换 println! 字符串中的 `{:?}`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    // Use {:?}
    println!("rect1 is {:?}", rect1);
}
```

### 使用 dbg!
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        // dbg! 返回表达式的值的所有权，所以 width 字段将获得相同的值，就像我们在那里没有 dbg! 调用一样
        width: dbg!(30 * scale),
        height: 50,
    };
    // 我们不希望 dbg! 拥有 rect1 的所有权，所以我们在下一次调用 dbg! 时传递一个引用
    dbg!(&rect1);
}
```

## 5.3 方法语法

`方法（method）`与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。

与函数是不同的，因为它们在结构体的上下文`impl`中被定义（或者是枚举或 trait 对象的上下文，将分别在第六章和第十七章讲解），并且它们第一个参数总是 `self` ，它代表调用该方法的结构体实例。

> `method` 是 结构体 `实现impl` 中定义的

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
 
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

#### getter
```rust
impl Rectangle {

    fn width(&self) -> u32 {
        self.width
    }
}

pub(crate) fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    println!(
        "The width of the rectangle is {} square pixels.",
        rect1.width()
    );
}
```

在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle，`&self 实际上是 self: &Self 的缩写。`, 有4种缩写：
- self 获取所有权
- &self 仅仅读取
- mut self 获取所有权
- &mut self 做出修改

这里选择 `&self `的理由跟在函数版本中使用 &Rectangle 是相同的：我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。

如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self`

> 使用方法替代函数的目的：
> 不需要在每个函数签名中重复 self 的类型之外，
> 其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 impl 块中，而不是让将来的用户在我们的库中到处寻找 Rectangle 的功能。


Getters 很有用，因为你`可以把字段变成私有的，但方法是公共的`，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。

#### -> 运算符到哪去了？
在 C/C++ 语言中，有两个不同的运算符来调用方法：`.` 直接在对象上调用方法，而 `->` 在一个对象的指针上调用方法, 这时需要先`解引用（dereference）指针`。换句话说，如果 object 是一个指针，那么 `object->something()` 就像 `(*object).something()` 一样。

Rust 并没有一个与 -> 等效的运算符；相反，Rust 有一个叫 `自动引用和解引用（automatic referencing and dereferencing）`的功能。`方法调用`是 Rust 中少数几个拥有这种行为的地方。


### 带有更多参数的方法
```rust
impl Rectangle {
    fn can_hold(&self, another_rectangle: &Rectangle) -> bool {
        self.width >= another_rectangle.width
            && self.height >= another_rectangle.height
    }
}
```

### 关联函数
所有在 `impl` 块中定义的函数被称为 `关联函数（associated functions）`，因为它们与 `impl` 后面命名的类型相关。

可以定义`不以 self 为第一参数的关联函数（因此不是方法）`，因为它们并`不作用于一个结构体的实例`。我们已经使用了一个这样的函数：在 String 类型上定义的 `String::from` 函数。

不是方法的关联函数`经常被用作返回一个结构体新实例的构造函数`。

> 使用结构体名和 `::` 语法来调用这个关联函数

```rust
impl Rectangle {
    fn square(size: u32) -> Self { // Self 即是 Rectangle
        Self {
            width: size,
            height: size,
        }
    }
}
```

# 6. Enums and Pattern Matching

enums 提供了一种说明一个 value 是一组可能的 value 之一的方法

假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4（version four）和 IPv6（version six）。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以 `枚举` 出所有可能的值. 

任何一个 IP 地址要么是 IPv4 的要么是 IPv6 的，而且不能两者都是。IP 地址的这个特性使得枚举数据结构非常适合这个场景，因为枚举值只可能是其中一个成员。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// 类似于定义多个不同类型的结构体，如下
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
```

枚举还有另一个相似点：就像可以使用 `impl` 来为结构体定义方法那样
```rust
    impl Message {
        fn call(&self) {
            // 在这里定义方法体
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
```

### Option 枚举和其相对于空值的优势

`Option` 是标准库定义的一个枚举. `Option` 类型应用广泛因为它编码了一个非常普遍的场景，`即一个值要么有值要么没值。`

Rust 并`没有`很多其他语言中有的`空值功能`。空值（Null ）是一个值，它代表没有值。空值是一个因为某种原因目前无效或缺失的值。
在有空值的语言中，变量总是这两种状态之一：空值和非空值。

`Rust 并没有空值`，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`, 它定义于标准库中:
```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T> `枚举是如此有用以至于它甚至被包含在了 `prelude` 之中, 可以不需要 Option:: 前缀来`直接使用 Some 和 None`

> <T> 语法是一个我们还未讲到的 Rust 功能。它是一个泛型类型参数，第十章会更详细的讲解泛型。

我们在 Some 成员中指定了值，`Rust 可以推断其类型。`
```rust
    // some_number 的类型是 Option<i32>
    let some_number = Some(5);
    // some_char 的类型是 Option<char>
    let some_char = Some('e');
    // 需要指定 Option 整体的类型，因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型
    // 我们告诉 Rust 希望 absent_number 是 Option<i32> 类型的。
    let absent_number: Option<i32> = None;
```

`Option<T>` 为什么就比空值要好呢？
-> 因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型，编译器不允许像一个`肯定有效的值`那样使用 `Option<T>`
```rust
    let x: i8 = 5;
    let y: Option<i8> = Some(5);

    let sum = x + y;
```
上述代码会报错：error[E0277]: cannot add `Option<i8>` to `i8`。因为它尝试将 `Option<i8>` 与 `i8` 相加.
换句话说，在对 `Option<T>` 进行运算之前必须将其转换为` T`.

如何从 `Some` 成员中取出 `T` 的值来使用它呢?
-> 为了使用` Option<T>` 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 `Some(T)` 值时运行，允许这些代码使用其中的 `T`。也希望一些代码只在值为 `None` 时运行，这些代码并没有一个可用的 `T` `值。match` 表达式就是这么一个处理枚举的控制流结构


## 6.2 match 控制流结构
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }, // 分支后的逗号是可选的
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 绑定值的模式
```rust
#[derive(Debug)] // 这样可以立刻看到州的名称
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```
调用 `value_in_cents(Coin::Quarter(UsState::Alaska))` 会打印 `State quarter from Alaska`, 且返回值为`25`

### 匹配 Option<T>
比如我们想要编写一个函数，它获取一个 `Option<i32>` ，如果其中含有一个值，将其加一。
如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => {
            Some(i + 1)
        },
        None => None,
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

### 匹配是穷尽的(exhaustive)
match 还有另一方面需要讨论：这些分支必须覆盖了所有的可能性。否则会报错：`error[E0004]: non-exhaustive patterns: `None` not covered`

### 通配模式和 _ 占位符
```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(other), // other变量名不matter, 可以用其他名称
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
```
即使我们没有列出 `u8` 所有可能的值，这段代码依然能够编译，因为最后一个模式将匹配所有未被特殊列出的值。
这种通配模式满足了 `match` 必须被穷尽的要求。
> 请注意，我们必须将`通配分支放在最后`，因为模式是按顺序匹配的。

Rust 还提供了一个模式，当我们`不想使用通配模式获取的值`时，请使用 `_` ，这是一个特殊的模式，可以匹配任意值而不绑定到该值。
这告诉 Rust 我们不会使用这个值，所以 Rust 也不会警告我们存在未使用的变量。
> 使用 _ 时，=>右边不能有使用 _ 的场景
```rust
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(), // reroll函数不关心也不使用 _
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
```

## 6.3 if let 简洁控制流
`if let `语法让我们以一种不那么冗长的方式结合 `if` 和 `let` ，来处理`只匹配一个模式的值`而忽略其他模式的情况。

```rust
    let config_max = Some(3u8); // 等价于 let config_max: Option<u8> = Some(3);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
```
上述代码为了满足 match 表达式（穷尽性）的要求，必须在处理完这唯一的成员后加上 `_ => ()`，这样也要增加很多烦人的样板代码。
我们可以使用 if let 这种更短的方式编写:

```rust
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
```

可以在 if let 中包含一个 else。else 块中的代码与 match 表达式中的 _ 分支块中的代码相同，这样的 match 表达式就等同于 if let 和 else。

```rust
    let mut count = 0;
    match coin {
        Coin::Quarter(state) => println!("State quarter from {:?}!", state),
        _ => count += 1,
    }

    // 上述代码等价于下：
    if let coin = Coin::Quarter(state) { // = 左右顺序不重要
        println!("State quarter from {:?}!", state);
    } else {
        count += 1;
    }

```

换句话说，可以认为 `if let` 是 match 的一个`语法糖`，它当值匹配某一模式时执行代码而忽略所有其他值。

# 7. Packages, Crates, and Modules

- 包（Packages）：Cargo 的一个功能，它允许你构建、测试和分享 crate。
- Crates ：一个模块的树形结构，它形成了库(library)或二进制项目(executable)。
- 模块（Modules）和 use：允许你控制作用域和路径的私有性。
- 路径（path）：一个命名例如结构体、函数或模块等项的方式

## 7.1 Package 和 Crate

### Crate
crate 是 Rust 在编译时最小的代码单位。

crate 可以包含模块，模块可以定义在其他文件，然后和 crate 一起编译，我们会在接下来的章节中遇到。

crate 有两种形式：
- library: `没有 main 函数`，它们也不会编译为可执行程序，它们提供一些诸如函数之类的东西，使其他项目也能使用这些东西
- executable: 被编译为可执行程序，比如一个命令行程序或者一个服务器。它们必须有一个 main 函数来定义当程序被执行的时候所需要做的事情。

> `crate root` 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块
> 对于一个 executable , crate root = src/main.rs 
> 对于一个 library, crate root = src/lib.rs

### Package
package 是提供一系列功能的一个或者多个 crate。一个package会包含一个 `Cargo.toml` 文件，阐述如何去构建这些 crate。

package 必须至少包含一个 crate:
- 可以包含至多一个 library
- 可以包含任意多个 executable

> 通过将文件放在 `src/bin` 目录下，一个包可以拥有多个 executable ：每个` src/bin `下的文件都会被编译成一个独立的 executable 。


## 7.2 定义模块来控制作用域与私有性
### Module

声明模块
```rust
// in main.rs or lib.rs

// normal declaration
mod normal_module;
// inline declaration
mod inline_module {
    fn some_function() {
        println!("This is a function inside the my_module.");
    }

    pub fn public_function() {
        println!("This is a public function inside the my_module.");
    }
}

fn main() {
    normal_module::some_function();
    inline_module::public_function();
}
```

- 一个模块里的代码默认对其父模块私有。
- 为了使一个模块公用，应当在声明时使用`pub mod`替代mod。
- 为了使一个公用模块内部的成员公用，应当在声明前使用`pub`。


`use `关键字: 在一个作用域内，use关键字创建了一个成员的快捷方式，用来减少长路径的重复。
```rust
use crate::garden::vegetables::Asparagus;

pub mod garden; // 意味着在src/garden/vegetables.rs中的代码也应该被包括

fn main() {
    let plant = Asparagus {};
    println!("I'm growing {:?}!", plant);
}
```

### 对相关代码进行分组
模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。

一个模块中的代码默认是`私有的`，所以还可以利用模块控制项的 私有性。

```rust
mod front_of_house {
    mod hosting { // child mod
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving { // child mod
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

## 7.3 引用模块项目的路径

我们使用`路径`的方式在模块树中找到一个项的位置

路径有两种形式：
- 绝对路径（absolute path）是以 crate root开头的全路径；对于外部 crate 的代码，是以 crate 名开头的绝对路径，对于当前 crate 的代码，则以字面值 crate 开头。
- 相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    // front_of_house 模块与 eat_at_restaurant 定义于同一模块，
    // 所以从 eat_at_restaurant 中开始定义的该模块相对路径是有效的。
    front_of_house::hosting::add_to_waitlist();
}
```

上述代码会报错：`error[E0603]: module `hosting` is private`。虽然调用路径是合法的，但在 Rust 中，默认所有项（函数、方法、结构体、枚举、模块和常量）`对父模块都是私有的`。

父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项

不过 Rust 也确实提供了通过使用 `pub` 关键字来创建公共项，使子模块的内部部分暴露给上级模块。

### 使用 pub 关键字暴露路径
```rust
mod front_of_house {
    // 让父模块中的 eat_at_restaurant 函数可以访问子模块 hosting
    pub mod hosting {
        //  让父模块中的 eat_at_restaurant 函数可以访问子模块内部代码add_to_waitlist
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}
```

#### executable 和 library 的最佳实践
- 在 executable 中只有足够的代码来启动一个可执行文件，可执行文件调用 library 的代码。
- 模块树应该定义在 src/lib.rs 中。这样通过以包名开头的路径，公有项就可以在 executable 中使用。
-  executable 就完全变成了同其它 外部 crate 一样的 library 的用户：它只能使用公有 API
- 这有助于你设计一个好的 API；你不仅仅是作者，也是用户！ 


### super 开始的相对路径
```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        // 通过在路径的开头使用 super ，从父模块开始构建相对路径
        super::deliver_order();
    }

    fn cook_order() {}
}
```

super可以`多重使用`
```rust
mod a {
    pub fn hello() {
        println!("Hello from module a");
    }

    pub(crate) mod b {
        pub fn hello() {
            println!("Greetings from module b");
        }

        pub(crate) mod c {
            pub fn greet() {
                // b::hello()
                super::hello();
                // a::hello()
                super::super::hello();
            }
        }
    }
}

pub(crate) fn main() {
    a::b::c::greet();
}
```

### 创建公有的结构体和枚举

- 在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。
- 将枚举设为公有，则它的所有成员都将变为公有。

> 如果枚举成员不是公有的，那么枚举会显得用处不大；给枚举的所有成员挨个添加 pub 是很令人恼火的，因此枚举成员默认就是公有的。
> 结构体通常使用时，不必将它们的字段公有化，因此结构体遵循常规

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String, // toast公有
        seasonal_fruit: String, // seasonal_fruit仍然是私有
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }

    // Soup, Salad都为公有
    pub enum Appetizer {
        Soup,
        Salad,
    }
}
```

## 7.4 使用 use 关键字将路径引入作用域

不得不编写路径来调用函数显得不便且重复。
-> 们可以使用 `use` 关键字创建一个短路径，然后就可以在`作用域中`的任何地方使用这个更短的名字。

在作用域中增加 `use` 和路径类似于在文件系统中创建`软连接（符号连接，symbolic link）`。

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

### 使用 as 关键字提供新的名称
考虑以下场景, fmt和io都有各自的Result, 通过use来区分
```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

使用 use 将两个同名类型引入同一作用域这个问题还有另一个解决办法：在这个类型的路径后面，我们使用 as 指定一个新的本地名称或者别名。

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```


### 使用 pub use 重导出名称
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

// 重导出（re-exporting)
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```
修改之前，外部代码需要使用路径 `restaurant::front_of_house::hosting::add_to_waitlist()`

现在, 外部代码现在可以使用路径 `restaurant::hosting::add_to_waitlist`

> 当你代码的内部结构与调用你代码的程序员所想象的结构不同时，重导出会很有用。

### 使用外部包

crates.io 上有很多 Rust 社区成员发布的包，将其引入你自己的项目都需要一道相同的步骤：
- 在 Cargo.toml 列出它们
- 并通过 use 将其中定义的项引入项目包的作用域中。

```rust
// in Cargo.toml
rand = "0.8.5"

// in your rs code
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
```

注意 `std` 标准库对于你的包来说也是外部 crate。
- 无需修改 Cargo.toml 来引入 std
- 不过需要通过 use 将标准库中定义的项引入项目包的作用域中来引用它们

```rust
use std::collections::HashMap;
```

### 嵌套路径来消除大量的 use 行

当需要引入很多`定义于相同包或相同模块的项`时，为每一项单独列出一行会占用源码很大的空间。

```rust
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--

// 等价于
use std::{cmp::Ordering, io};


use std::io;
use std::io::Write;

// 等价于
use std::io::{self, Write};

```

### 通过 glob 运算符(*)将所有的公有定义引入作用域
如果希望将一个路径下` 所有 公有项`引入作用域，可以指定路径后跟 glob 运算符(`*`)：
```rust
use std::collections::*;
```
> 使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。
> glob 运算符经常用于测试模块 tests 中，这时会将所有内容引入作用域

## 7.5 将模块拆分成多个文件

注意你只需在模块树中的某处使用一次 mod 声明就可以加载这个文件。

换句话说，mod 不是 你可能会在其他编程语言中看到的 "include" 操作。

# 8. 常见集合
## 8.1 Vector

类型 `Vec<T>` 允许我们在一个单独的数据结构中储存多于一个的值，它在`内存中彼此相邻地排`列所有的值。


### Create
```rust 
    // create a empty vector
    let v: Vec<i32> = Vec::new();
    // create an initialized vector with macro 'vec!'
    let v = vec![1, 2, 3];
```

### Update
```rust
    // 放入其中的所有值都是 i32 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 Vec<i32> 注解。
    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
```

### Access
```rust
    let v = vec![1, 2, 3, 4, 5];

    // style-1: read with index
    let third: &i32 = &v[2];

    // style-2: read with .get()
    let third: Option<&i32> = v.get(2)
    match third {
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }
```

> 索引语法, 当引用一个不存在的元素时 Rust 会造成 panic

#### 借用规则与读取vec元素
```rust
    let mut v = vec![1, 2, 3, 4, 5];

    // 获取了一个有效的引用
    // immutable borrow occurs here
    let first = &v[0];

    // 在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。
    // 这时，第一个元素的引用就指向了被释放的内存。
    // mutable borrow occurs here
    v.push(6);

    // immutable borrow later used here
    println!("The first element is: {first}");
```
上述代码会报错：`error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable`

> 如果没有 `println!("The first element is: {first}");` 或者这行在 `v.push(6);` 之前则不会有问题

### 遍历 vector 中的元素
```rust
    let v = vec![100, 32, 57];
    
    // 获取 v 中的每一个元素的不可变引用并将其打印
    for i in &v {
        println!("{i}");
    }

    // 遍历可变 vector 的每一个元素的可变引用以便能改变它们
    let mut v = vec![100, 32, 57];
    for i in &mut v {
        // 解引用运算符（*）获取 i 中的值
        *i += 50;
    }
```

> 因为借用检查器的规则，无论可变还是不可变地遍历一个 vector 都是安全的。
> 如果尝试在 for 循环体内`插入或删除项`，都会得到`error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable`。
> for 循环中获取的 vector 引用阻止了同时对 `vector 整体`的修改。

### 使用枚举来储存多种类型

vector `只能储存相同类型的值`。这是很不方便的

会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！

```rust
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(10.12),
        SpreadsheetCell::Text(String::from("blue")),
    ];
```

Rust 在编译时就必须准确的知道 vector 中类型:
- 它需要知道储存每个元素到底需要多少内存
- 如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误。

### 丢弃 vector 时也会丢弃其所有元素
```rust
    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v

    } // <- v goes out of scope and is freed here
      // 借用检查器确保了任何 vector 中内容的引用仅在 vector 本身有效时才可用。
```

## 8.2 字符串(String) 和 UTF-8 encoded Text

Rust 的核心语言中只有一种字符串类型：字符串 `slice str`，它通常以被借用的形式出现，&str

### 新建字符串

很多 Vec 可用的操作在 String 中同样可用，事实上 String 被实现为一个带有一些额外保证、限制和功能的`字节 vector 的封装`。

```rust
    // new 函数新建了一个叫做 s 的空的字符串
    let mut s = String::new();

    // to_string 方法，它能用于任何实现了 Display trait 的类型，比如字符串字面值
    let data = "initial contents";
    let s = data.to_string();
    // 该方法也可直接用于字符串字面值：
    let s = "initial contents".to_string();

    // 使用 String::from 函数来从string slice 创建 String
    let s = String::from("initial contents");

```

### 更新字符串

String 的大小可以增加，其内容也可以改变，就像可以放入更多数据来改变 Vec 的内容一样。

#### push_str
```rust
    // 通过 push_str 方法来附加字符串 slice，从而使 String 变长
    // -> foobar
    let mut s = String::from("foo");
    // "bar" 是 &str, 我们并不需要获取参数的所有权
    // 否则下面的println! s2就会出错
    s.push_str("bar"); 
    println!("s2 is {s2}"); 
```
#### + 
```rust
    // 使用 + 运算符 拼接字符串
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
```

+ 运算符使用了 add 函数，这个函数签名看起来像这样：
`fn add(self, s: &str) -> String {`

所以 `let s3 = &s1 + &s2;` 也是不行的，会报错 `Cannot add &String to &String [E0369]`

之所以能够在 add 调用中使用 &s2 是因为 &String 可以被 强转（coerced）成 &str。当add函数被调用时，Rust 使用了一个被称为 `Deref 强制转换（deref coercion）`的技术，你可以将其理解为它把 &s2 变成了 &s2[..]

> a + b 会获取a的所有权， 如果想要级联多个字符串，+ 的行为就显得笨重了，很难理解具体发生了什么。

#### format!
format! 与 println! 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 String。

宏 format! 生成的代码使用引用所以`不会获取任何参数的所有权`。

```rust
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
```


### 索引字符串

Rust 的字符串不支持索引，如`let h = s[0]`, 索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。

如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```
这里，s 会是一个 &str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。

如果获取 &hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic，就跟访问 vector 中的无效索引时一样：`thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З'`

### 遍历字符串的方法
操作字符串每一部分的最好的方法是明确表示需要字符还是字节。

```rust
// З
// д
for c in "Зд".chars() {
    println!("{c}");
}

// 208
// 151
// 208
// 180
for b in "Зд".bytes() {
    println!("{b}");
}

```

## 8.3 HashMap and Key-Value entry

HashMap<K, V> 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中。

### 新建一个哈希 map
```rust
    use std::collection::HashMap;

    let mut scores = HashMap::new();

    // push an entry
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
```

> 注意必须首先 use 标准库中集合部分的 HashMap。在这三个常用集合中，HashMap 是最不常用的，所以并没有被 prelude 自动引用。
> 标准库中对 HashMap 的支持也相对较少，例如，并没有内建的构建宏。

### 访问哈希 map 中的值
```rust
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let score = scores.get(&String::from("Blue"))
                      .copied()
                      .unwrap_or(0);
```
- get 方法返回 Option<&V>, 如果某个键在哈希 map 中没有对应的值，get 会返回 None
- copied 方法来获取一个 Option<i32> 而不是 Option<&i32>
- unwrap_or在 scores 中没有该键所对应的项时将其设置为零。

可以使用与 vector 类似的方式来`遍历`哈希 map 中的每一个键值对，也就是 for 循环：
```rust
    for (key, value) in &scores {
        println!("{key}: {value}");
    }
```

### 哈希 map 和所有权
对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。
对于像 String 这样拥有所有权的值，其值将被移动而`哈希 map 会成为这些值的所有者`，

```rust
    use std::collections::HashMap;

    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // 这里 field_name 和 field_value 不再有效，
```

> 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。
> 但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。

### 更新哈希 map

当我们想要改变哈希 map 中的数据时，必须决定如何处理一个键已经有值了的情况:
- 可以选择完全无视旧值并用新值代替旧值。-> insert
- 可以选择保留旧值而忽略新值，并只在键 没有 对应值时增加新值。 -> entry().or_insert()
- 可以结合新旧两值。-> 

```rust
    use std::collection::HashMap;

    let mut scores = HashMap::new();

    // 完全无视旧值并用新值代替旧值
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Blue"), 25);
    
    // 保留旧值而忽略新值
    // 对应的值存在时就返回这个值的可变引用, 没有 对应值时增加新值
    scores.entry(String::from("Blue")).or_insert(50);
    
    // 找到一个键对应的值并根据旧的值更新它
    // 计数一些文本中每一个单词分别出现了多少次
    let text = "hello world wonderful world";
    let mut map = HashMap::new();
    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        // 为了赋值必须首先使用星号（*）解引用 count
        *count += 1;
    }

```

### 哈希函数
HashMap 默认使用一种叫做 `SipHash` 的哈希函数，它可以抵御涉及哈希表（hash table）1 的拒绝服务（Denial of Service, DoS）攻击

> 拒绝服务攻击（Denial of Service，缩写为DoS）是一种网络攻击，旨在使目标系统、网络或服务不可用，从而阻止合法用户访问或使用这些资源。这类攻击的目标是破坏系统的正常运行、削弱性能、或完全使其停止响应请求。拒绝服务攻击通常不涉及对系统的未经授权访问或数据盗窃，而是专注于瘫痪或干扰目标系统的可用性。
> 分布式拒绝服务攻击（DDoS，Distributed Denial of Service）是一种网络攻击，它旨在通过同时从多个来源发送大量请求或数据流量，使目标系统、网络或服务不可用。

# 9.错误处理
Rust 将错误分为两大类：
- 可恢复的（recoverable）: 对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。
- 不可恢复的（unrecoverable）: 错误不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。


`Rust 没有异常`。
相反，它有 `Result<T, E>` 类型，用于处理可恢复的错误，
还有 `panic!` 宏，在程序遇到不可恢复的错误时停止执行。

本章首先介绍 `panic!` 调用，接着会讲到如何返回 `Result<T, E>`。

## 9.1 用 panic! 处理不可恢复的错误
在实践中有两种方法造成 panic：
- 执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）
- 显式调用 panic! 宏。

通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。

#### 对应 panic 时的栈展开或终止
当出现 panic 时，程序会:
- 默认: 展开（unwinding）,Rust 会回溯栈并清理它遇到的每一个函数的数据
- 直接 终止（abort），这会不清理数据就退出程序。程序所使用的内存需要由操作系统来清理。

如果你需要项目的最终二进制文件越小越好, 可以由`展开`切换为`终止`。
```rust
// 在 release 模式中 panic 时直接终止
[profile.release]
panic = 'abort'
```

### 使用 panic! 的 backtrace

`RUST_BACKTRACE` 是一个用于 Rust 程序的环境变量，它用于控制程序在发生 panic（恐慌）时生成堆栈跟踪信息。

堆栈跟踪信息显示了程序在哪里发生了 panic，帮助开发人员定位问题并进行调试。

具体来说，RUST_BACKTRACE 环境变量有以下值：

- `RUST_BACKTRACE=0`：这是`默认值`。在发生 panic 时，程序不会生成堆栈跟踪信息。

- `RUST_BACKTRACE=1`：当发生 panic 时，程序会生成简单的堆栈跟踪信息，显示 panic 发生的位置（函数调用链），但不会包括源代码行号信息。

- `RUST_BACKTRACE=full`：当发生 panic 时，程序会生成详细的堆栈跟踪信息，包括源代码行号信息，帮助你更容易地追踪问题。

设置 `RUST_BACKTRACE=1` 或 `RUST_BACKTRACE=full` 可以`在开发和调试阶段`帮助你快速定位和修复程序中的问题，特别是在处理 panic 或错误时，这些堆栈跟踪信息对于找出问题的原因非常有帮助。

但`在生产环境中`，通常应将其设置为默认值 `RUST_BACKTRACE=0`，以避免泄漏敏感信息，并提高程序的性能。

#### 设置 RUST_BACKTRACE 环境变量
1. `命令行参数：`你可以在运行 Rust 程序的命令行中直接设置 RUST_BACKTRACE 环境变量，例如：
   ```bash
   RUST_BACKTRACE=1 ./your_rust_program
   ```
2. `Unix/Linux 的shell环境变量：`你可以在终端中设置 RUST_BACKTRACE 环境变量，然后运行程序，例如：
    ```bash
    export RUST_BACKTRACE=1
    ./your_rust_program
    ```
3. `.env 文件(recommended)：`你可以在项目目录中创建一个名为 .env 的文件，然后在其中设置 RUST_BACKTRACE 环境变量。这对于项目特定的配置非常有用。
在 .env 文件中添加以下内容：
    ```makefile
    RUST_BACKTRACE=1
    ```
    然后在运行 Rust 程序之前，可以使用工具（如 dotenv）加载 .env 文件以设置环境变量。
4. 系统环境变量：你还可以在操作系统级别设置 RUST_BACKTRACE 环境变量，这将影响整个系统上的 Rust 程序。
   例如，在Unix/Linux系统中，你可以编辑 ~/.bashrc 或 ~/.bash_profile 文件，并添加以下行：
   ```bash
   export RUST_BACKTRACE=1
   ```

## 9.2 用 Result 处理可恢复的错误

Result 枚举，它定义有如下两个成员，Ok 和 Err：
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` 和 `E` 是泛型类型参数.  `T` 代表成功时返回的 Ok 成员中的数据的类型，而 `E` 代表失败时返回的 Err 成员中的错误的类型。


如示例所示打开一个文件:
```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        // 成功时 greeting_file_result 变量将会是一个包含文件句柄的 Ok 实例
        Ok(file) => file,
        // 失败时，greeting_file_result 变量将会是一个包含了更多关于发生了何种错误的信息的 Err 实例。
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

> Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::。

### 匹配不同的错误
上述代码不管 File::open 是因为什么原因失败都会 panic!。

我们真正希望的是对不同的错误原因采取不同的行为：
- 如果 File::open 因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。
- 如果 File::open 因为任何其他原因失败，例如没有打开文件的权限，我们仍然希望像示例 9-4 那样 panic!

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            // 尝试通过 File::create 创建文件。
            // 然而因为 File::create 也可能会失败，还需要增加一个内层 match 语句。
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
```

#### 使用闭包代替match和Result<T, E>
上述代码可以被改写为:

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```
`unwrap_or_else` 用于处理可能的错误情况或Option中的None值, 允许你从Option或Result中获取值: 
- 如果值存在，就返回它；
- 如果值不存在（Option为None或Result为Err），则可以提供一个闭包（closure）作为参数，以生成或计算一个替代值来代替错误值或None。

```rust
fn unwrap_or_else<F>(self, op: F) -> T
```
- self 表示一个Option或Result类型的实例，即要操作的值。
- op 是一个闭包，用于生成替代值的逻辑。这个闭包不接受任何参数，返回类型必须与Option中的值类型或Result中的Ok值类型匹配。如果操作成功，它会返回替代值。

示例1 - 处理Option：
```rust
let maybe_value: Option<i32> = Some(42);
let default_value = 0;
let result = maybe_value.unwrap_or_else(|| default_value * 2);
// 如果maybe_value包含Some(42)，则result为42，否则为0 * 2 = 0
```

示例2 - 处理Result：
```rust
fn potentially_fallible_operation() -> Result<i32, &'static str> {
    // 模拟可能失败的操作
    Err("Something went wrong")
}

let result = potentially_fallible_operation();
let default_result = 100;
let final_result = result.unwrap_or_else(|err| {
    println!("Error: {}", err);
    default_result
});
// 如果potentially_fallible_operation()返回Err("Something went wrong")，final_result为100，并打印错误信息。

```

> 上述代码中的||, |err|的 ||是用来干什么的

`||` 用于包裹闭包的参数：
- `||`：这是一个空参数列表的闭包。在这种情况下，它表示不接受任何参数。闭包内部的逻辑不依赖于外部的参数。
- `|err|`: 这是一个带有参数的闭包，其中err 是闭包的参数名。它表示闭包接受一个参数，该参数用于处理函数内部的逻辑。


### 失败时 panic 的简写：unwrap 和 expect

`unwrap`: 
- 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。
- 如果 Result 是成员 Err，unwrap 会为我们调用 panic!

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

expect:
- 如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。
- 如果实际是 Err 分支，它将引发 panic。expect 方法将在标准错误流中输出指定的错误消息，然后终止程序的执行。
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
```

> expect 在调用 panic! 时使用的错误信息将是我们传递给 expect 的参数，而不像 unwrap 那样使用默认的 panic! 信息。
> 在生产级别的代码中，大多数Rustaceans选择Expect而不是Unrap，并给出了更多关于为什么预期操作总是成功的上下文。

### 传播错误
当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 传播（propagating）错误。
> 类似于java中的抛出异常，作为中间环节的程序员并不需要总是在自己的环节处理所有可能的错误。


```rust
use std::fs::File;
use std::io::{self, Read};

// 展示了一个从文件中读取用户名的函数。
// Note: 返回值类型为Result<String, io::Error>
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        // 如果文件不存在, 将错误返回给调用它的代码
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        // 不能读取, 将错误返回给调用它的代码
        Err(e) => Err(e),
    }
}
```

> 这里选择 io::Error 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：File::open 和 read_to_string 。

### 传播错误的简写：? 运算符

使用 `? `运算符改写上节的`read_username_from_file`代码:
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```
Rust 中的 ? 运算符用于处理 Result 类型，特别是在函数中处理可能引发错误的操作。

? 运算符的主要作用是将 Result 类型的结果解包：
- 如果结果是 Ok 则将 Ok 分支的值返回
- 如果结果是 Err 则将 Err 分支的错误值作为函数的返回值，并用 ? 运算符早期返回（即提前从函数中返回错误）。

我们甚至可以在 ? 之后直接使用`链式方法`调用来进一步缩短代码:
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
```

## 9.3 要不要 panic!

你可以选择对任何错误场景都调用 panic!，不管是否有可能恢复，不过这样就是你代替调用者决定了这是不可恢复的。

选择返回 Result 值的话，就将选择权交给了调用者，而不是代替他们做出决定。


