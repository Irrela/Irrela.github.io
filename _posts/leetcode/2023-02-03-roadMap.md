---
title: Road Map
categories: Leetcode
tags:
- Leetcode
---

- [Coding Pattern: Two Pointers](#coding-pattern-two-pointers)
- [Coding Pattern: Sliding Window](#coding-pattern-sliding-window)
- [Coding Pattern: Intervals](#coding-pattern-intervals)
- [Coding Pattern: Linked List Manipulation](#coding-pattern-linked-list-manipulation)
- [Coding Pattern: Hash Maps](#coding-pattern-hash-maps)
- [Coding Pattern: Modified Binary Search](#coding-pattern-modified-binary-search)
- [Coding Pattern: Top K Elements](#coding-pattern-top-k-elements)
- [Coding Pattern: Heaps (Priority Queue)](#coding-pattern-heaps-priority-queue)
- [Coding Pattern: Two Heaps](#coding-pattern-two-heaps)
- [Coding Pattern: K-way Merge](#coding-pattern-k-way-merge)
- [Coding Pattern: Subsets](#coding-pattern-subsets)
- [Coding Pattern: Greedy](#coding-pattern-greedy)
- [Coding Pattern: Backtracking](#coding-pattern-backtracking)
- [Coding Pattern: DP](#coding-pattern-dp)
- [Coding Pattern: Cyclic Sort](#coding-pattern-cyclic-sort)
- [Coding Pattern: Topological Sort](#coding-pattern-topological-sort)
- [Coding Pattern: Stacks](#coding-pattern-stacks)
- [Coding Pattern: Breadth-First Search](#coding-pattern-breadth-first-search)
- [Coding Pattern: Depth-First Search](#coding-pattern-depth-first-search)
- [Coding Pattern: Recursion (-TODO)](#coding-pattern-recursion--todo)
- [Coding Pattern: Trie](#coding-pattern-trie)
- [Coding Pattern: Union Find](#coding-pattern-union-find)
- [Coding Pattern: Design](#coding-pattern-design)
- [Bonus: Data Structure + System Design](#bonus-data-structure--system-design)
- [Solution](#solution)
  - [Two Pointers](#two-pointers)
    - [Valid Palindrome](#valid-palindrome)
    - [680. Valid Palindrome II](#680-valid-palindrome-ii)
      - [Naive one based on Valid Palindrome I](#naive-one-based-on-valid-palindrome-i)
    - [Closest Sum](#closest-sum)
    - [3Sum](#3sum)
    - [Best Time to Buy and Sell Stock](#best-time-to-buy-and-sell-stock)
    - [209. Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
    - [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)


# Coding Pattern: Two Pointers

- [Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/)
- [Valid Palindrome II(Medium)](https://leetcode.com/problems/valid-palindrome-ii/)
- [Closest Sum(Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

- [3Sum(Medium)](https://leetcode.com/problems/3sum/)
- [Best Time to Buy and Sell Stock(Medium)(todo-no two pointer type)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

- [Trapping Rain Water(Hard)](https://leetcode.com/problems/trapping-rain-water/)

# Coding Pattern: Sliding Window

- [Longest Substring without Repeats(Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [Minimum Size Subarray Sum(Medium)](https://leetcode.com/problems/minimum-size-subarray-sum/)
- Fruit into Baskets
- Permutation in String
- Longest Subarray with Ones after Replacement

- Minimum Window Substring

# Coding Pattern: Intervals
- Meeting Rooms I
- Interval List Intersections

- Insert Interval
- Merge Intervals

# Coding Pattern: Linked List Manipulation
- Swap Nodes in Pairs
- Palindrome Linked List

- Reverse Linked List II
- Rotate List
- Odd Even Linked List

- Reorder List

# Coding Pattern: Hash Maps
- Isomorphic Strings
- Word Pattern

- Group Anagrams
- Find All Anagrams in a String
- Longest Subarray with Sum Divisible by K

- Rate Limiter

# Coding Pattern: Modified Binary Search
- First Bad Version
- Maximum Count of Positives or Negatives 

- Search in Rotated Sorted Array
- Find Minimum in Rotated Sorted Array
- Find Peak Element

- Median of Two Sorted Arrays

# Coding Pattern: Top K Elements
- Kth Largest Element in a Stream
- Kth Largest Element in a Stream

- K Closest Points to Origin
- Top K Frequent Elements in a Stream
- Sliding Window Maximum

- Rearrange String k Distance Apart

# Coding Pattern: Heaps (Priority Queue)

- Meeting Rooms II (Hard)

# Coding Pattern: Two Heaps
- Find Kth Largest Element in a Stream
- Find Median of Two Sorted Arrays

- Kth Smallest Element in a Sorted Matrix
- Find Kth Smallest Pair Distance
- Find K Pairs with Smallest Sums

- Sliding Window Median

# Coding Pattern: K-way Merge 
- Top K Frequent Elements
- Merge Intervals

- Kth Smallest Number in Sorted Matrix
- Merge k Sorted Lists
- Smallest Number Range

- Super Ugly Number

# Coding Pattern: Subsets
- Subsets
- Letter Combinations of a Phone Number

- Subsets II
- Combination Sum
- Palindrome Partitioning

- Combination Sum II

# Coding Pattern: Greedy
- Assign Cookies
- Jump Game

- Queue Reconstruction by Height
- Jump Game II
- Non-overlapping Intervals (Intervals problem)

- Gas Station
- Meeting Rooms II

# Coding Pattern: Backtracking
- Generate Parentheses
- Letter Tile Possibilities

- Combination Sum
- Combination Sum II
- Word Search

- N-Queens

# Coding Pattern: DP
- Climbing Stairs
- Longest Increasing Subsequence

- Unique Paths
- Coin Change
- House Robber

- Edit Distance

# Coding Pattern: Cyclic Sort
- Find the Missing Number
- Set Mismatch

- Find All Numbers Disappeared in an Array
- First Missing Positive
- Find the Duplicate Number

- Find All Duplicates in an Array

# Coding Pattern: Topological Sort
- Course Schedule
- Alien Dictionary

- Course Schedule II
- Sequence Reconstruction
- Minimum Height Trees

- Course Schedule III

# Coding Pattern: Stacks
- Valid Parentheses
- Min Stack

- Evaluate Reverse Polish Notation
- Simplify Path
- Binary Tree Inorder Traversal

- Largest Rectangle in Histogram

# Coding Pattern: Breadth-First Search 
- Binary Tree Level Order Traversal  [Tree]
- Cousins in Binary Tree  [Tree]
- Number of Islands [Graph]
- Find if Path Exists in Graph [Graph]

- Binary Tree Zigzag Level Order Traversal  [Tree]
- Populating Next Right Pointers in Each Node [Tree]
- Word Ladder [Graph]
- Pacific Atlantic Water Flow [Graph]
- Number of Connected Components in an Undirected Graph [Graph]

- Serialize and Deserialize Binary Tree

# Coding Pattern: Depth-First Search 
- Maximum Depth of Binary Tree [Tree]
- Binary Tree Inorder Traversal [Tree]
- Course Schedule [Graph]

- Path Sum II [Tree]
- Symmetric Tree [Tree] 
- Binary Tree Right Side View [Tree]
- Invert Binary Tree [Tree]
- Clone Graph [Graph]

- Lowest Common Ancestor of a Binary Tree [Tree]

# Coding Pattern: Recursion (-TODO)

# Coding Pattern: Trie
- Design Add and Search Words Data Structure
- Word Search II

- Add and Search Words Data Structure
- Palindrome Pairs
- Design Search Autocomplete System

- Word Break II

# Coding Pattern: Union Find
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Coding Pattern: Design
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Bonus: Data Structure + System Design
- Design HashSet
- Min Stack

- Design LRU Cache
- Design Twitter
- Design a Parking Lot

- Design an Online Shopping System
- Design a Social Network


# Solution
## Two Pointers

### Valid Palindrome
```java
// Use built-in replaceAll
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase().replaceAll("[^a-zA-Z0-9]", "");

        int forward = 0;
        int backward = s.length() - 1;

        while (backward > forward) {
            if (s.charAt(forward) != s.charAt(backward)) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }
}
```

```java
// Self implemented support fns
class Solution {
    public boolean isPalindrome(String s) {
        char[] charArray = s.toCharArray();
        int forward = 0;
        int backward = charArray.length - 1;

        while (backward > forward) {
            // Skip non-alphanumeric characters from the beginning
            while (forward < charArray.length && !isAlphanumeric(charArray[forward])) {
                forward++;
            }
            
            // Skip non-alphanumeric characters from the end
            while (backward >= 0 && !isAlphanumeric(charArray[backward])) {
                backward--;
            }

            // Compare characters (case-insensitive)
            if (forward < charArray.length && backward >= 0 && toLowerCase(charArray[forward]) != toLowerCase(charArray[backward])) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }

    private boolean isAlphanumeric(char c) {
        return (c >= 'a' && c <= 'z') 
            || (c >= 'A' && c <= 'Z') 
            || (c >= '0' && c <= '9');
    }

    private char toLowerCase(char c) {
        if (c >= 'A' && c <= 'Z') {
            // Convert uppercase to lowercase by adding the ASCII offset
            return (char) (c + 'a' - 'A');
        }
        return c;
    }
}
```

### 680. Valid Palindrome II
#### Naive one based on Valid Palindrome I
```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            // Allow skip once.
            if (s.charAt(left) != s.charAt(right)) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }

        return true;
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

### Closest Sum
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int begin = 0;
        int end = numbers.length - 1;

        while (begin < end) {
            int sum = numbers[begin] + numbers[end];
            if (sum == target) {
                return new int[] {begin + 1, end + 1};
            }

            if (sum > target) {
                end--;
            } else {
                begin++;
            }
        }

        return null;
    }
}
```

```java
// BF
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=1;i<nums.length;i++)
        {
            for(int j=i;j<nums.length;j++)
            {
                if(nums[j-i]+nums[j]==target)
                {
                    return new int[]{j-i,j};
                }
            }
        }
        return null;
        
    
    }
}
```

```java
// HashMap
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];

            if (map.containsKey(complement)) {
                return new int[] {i, map.get(complement)};
            }

            map.put(nums[i], i);
        }

        return null;
    }
}
```

### 3Sum
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // Note: B-I sort 
        Arrays.sort(nums);
        List<List<Integer>> ret = new ArrayList<>();

        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            // Skip duplicates
            if (i > 0 && nums[i] == nums[i - 1]) { continue;}

            int begin = i + 1;
            int end = n - 1;
            // 如果是要求sum为value，这里可以做修改适配
            int target = -nums[i];

            while (begin < end) {
                int sum = nums[begin] + nums[end];
                if (sum == target) {
                    ret.add(Arrays.asList(nums[i], nums[begin], nums[end]));
                    // Skip duplicates
                    while (begin < end && nums[begin] == nums[begin + 1]) {
                        begin++;
                    }
                    while (begin < end && nums[end] == nums[end - 1]) {
                        end--;
                    }

                    begin++;
                    end--;
                } else if (sum < target) {
                    begin++;
                } else {
                    end--;
                }
            }
            
        }

        return ret;
    }
}

```

### Best Time to Buy and Sell Stock
> 用双指针 O(n^2) 太高。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        // 可以代表在i天卖出时可能得最大收益
        int curProfit = 0;

        for (int i = 1; i < prices.length; i++) {
            int interval = prices[i] - prices[i - 1];
            // 如果为负，说明i是一个低价，低到在其之前任何一天买入在i卖出都是亏的
            // 所以it's better to start over at i
            curProfit = Math.max(0, interval + curProfit);
            maxProfit = Math.max(curProfit, maxProfit);
        }

        return maxProfit;
    }
}
```


### 209. Minimum Size Subarray Sum
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int sum = 0;
        int minLength = Integer.MAX_VALUE;

        for (; right < nums.length; right++) {
            sum += nums[right];
            // 只有在sum大于等于过target时才记录minLength
            // 如果全程都没有大于等于过，需要最后将minLength处理为0
            boolean needUpdate = false;

            while (sum >= target) {
                sum -= nums[left];
                left++;
                needUpdate = true;
            }

            if (needUpdate) {
                minLength = Math.min(minLength, right - left + 2);
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```

### 3. Longest Substring Without Repeating Characters
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        int maxLength = 0;
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;

        for (int right = 0; right < len; right++) {
            char currentChar = s.charAt(right);
            
            // 如果当前子字符串中没有看到当前字符
            // 或者它出现在当前左指针之前，它是当前子字符串的一部分。
            if (map.getOrDefault(currentChar, -1) < left) {
                maxLength = Math.max(maxLength, right - left + 1);
            } else {
                // 如果该字符已被看到并且在当前子字符串中，
                // 将左指针更新到该字符最后一次出现后的位置。
                left = map.get(currentChar) + 1;
            }
            
            map.put(currentChar, right);
        }

        return maxLength;
    }
}
```