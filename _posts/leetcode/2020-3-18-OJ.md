---
title: OJ
categories: Leetcode
---
## 障碍棋盘
### Description
一个len为M的棋盘，上面有O个障碍，N条行走指令，agent从(0, 0)出发，按指令行走：

1. 每次行走计数器+1，将更新在走到的坐标格上
2. 如果遇到障碍，则坐标不变，但计数器增加
3. 走出棋盘则结束，输出:INVALID

障碍由row 和 col标记位置
指令由 方向 和 step 组成

输入例子：
```
5
3
4
3 0
0 2
2 3
R 2
D 4
R 3
U 3
```
输出例子：
```
0    2    X    0    0
0    3    0    0    12
0    4    0    X    11
X    5    0    0    10
0    6    7    8    9
```

### Solution
```java
import java.util.*;

public class Board {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int m = sc.nextInt();
        int o = sc.nextInt();
        int n = sc.nextInt();

        int[][] grid = new int[m][m];

        for(int i = 0; i < o;i++){
            int row = sc.nextInt();
            int col = sc.nextInt();

            grid[row][col] = -1;
        }

        int count = 0;
        int curRow = 0;
        int curCol = 0;

        for(int i = 0; i < n; i++){
            int newRow = curRow;
            int newCol = curCol;

            String op = sc.next();
            int step = sc.nextInt();

            for(int j = 0; j < step; j++){
                switch (op) {
                    case "R":
                        newCol++;
                        break;
                    case "L":
                        newCol--;
                        break;
                    case "D":
                        newRow++;
                        break;
                    case "U":
                        newRow--;
                        break;
                    default:
                        break;
                }

                if(newRow < 0 || newCol < 0 || newRow >= m || newCol >= m){
                    System.out.println("INVALID");
                    return;
                }

                if(grid[newRow][newCol] == -1){
                    newRow = curRow;
                    newCol = curCol;
                }

                count++;
                curRow = newRow;
                curCol = newCol;

                grid[curRow][curCol] = count;
            }
        }

        for(int i = 0; i < m; i++){
            for(int j = 0; j < m; j++){
                int num = grid[i][j];

                if(num == -1){
                    System.out.print("X    ");
                }else{
                    System.out.printf("%-5d", num);
                }
            }
            System.out.print("\n");
        }

    }
}
```

## 判断是不是子字符串

给定两个字符串 s和 t ，判断 s是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

输入例子1:
```
abc
ahbgdc
```
输出例子1:
```
true
```

```py
sub = raw_input()
t = raw_input()

def main(sub, t):
    i = 0
    for char in sub:
        try:
            index = t[i:].index(char)+i
            i = index+1
        except Exception as e:
            return False
    return True

if main(sub, t):
    print('true')
else:
    print('false')
```


## 汽水瓶Bottles
### Description
有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？

```java
import java.util.*;

public class Main{
    public static void main(String[] agrs){
        Scanner sc = new Scanner(System.in);
        
        Deque<Integer> list = new LinkedList<>();
        while(sc.hasNextInt()){
            int temp = sc.nextInt();
            if(temp != 0){
                list.addLast(temp);
            }
        }
        
        while(!list.isEmpty()){
            int empty = list.pollFirst();
            int exchange = 0;
            int count = 0;
            
            while(empty > 2){
                exchange = empty / 3;
                empty = empty % 3;
                
                count += exchange;
                
                empty += exchange;
                exchange = 0;
            }
            
            if(empty == 2){
                count++;
            }
            
            System.out.println(count);
        }   
    }
}
```

## 机器人路径
```java
class Solution {

    boolean[][] isVisited;
    int count;
    int rows;
    int cols;
    int limit;

    public int movingCount(int m, int n, int k) {
        
        isVisited = new boolean[m][n];
        count = 0;
        rows = m;
        cols = n;
        limit = k;

        search(0, 0);

        return count;
    }

    public void search(int i, int j){
        if(!inGrid(i, j) || isVisited[i][j]){
            return;
        }

        isVisited[i][j] = true;

        if(digitSum(i) + digitSum(j) > limit){
            return;
        }

        count++;

        search(i+1, j);
        search(i, j+1);

    }

    public boolean inGrid(int i, int j){
        return i < rows && j < cols;
    }

    public int digitSum(int num){
        int sum = 0;

        while(num > 0){
            sum += num % 10;
            num /= 10;
        }

        return sum;
    }
}
```
## ByteD Inter-1
### Description
为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1<=L2<=R2<=R1)。

#### Input
输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数  第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l<=i<=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n <= 300000,q<=300000 k是整型

#### Output
输出：一共q行，每行一个整数代表喜好值为k的用户的个数

#### Showcase

Input:
```
5
1 2 3 3 5
3
1 2 1
2 4 5
3 5 3
```

Output:
```
1
0
2
```

### 50%AC 
直接用Array存储所有喜好值， 然后在每个case的用户index区间中挨个检查给定的喜好值target，一致则加一。

问题：时间复杂度，如果给定的用户区间很大的话，每次的遍历cost很大。

```java
public class BD1 {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int userNum = sc.nextInt();
        int[] like = new int[userNum];

        for(int i = 0; i < userNum; i++){
            like[i] = sc.nextInt();
        }

        int caseNum = sc.nextInt();
        int[] res = new int[caseNum];

        for(int i = 0; i < caseNum; i++){
            int left = sc.nextInt() - 1;
            int right = sc.nextInt() - 1;
            int curLike = sc.nextInt();

            for(int j = left; j <= right; j++){
                if(like[j] == curLike){
                    res[i]++;
                }
            }
        }

        for(int i = 0; i < caseNum; i++){
            System.out.println(res[i]);
        }
    }
}
```

### 100%AC
用HashMap<Integer, List<Integer>>来为每个喜好值生成一个list，将符合的用户index添加到list，之后只用遍历每个target对应的list，cost会小很多。

HashMap<Integer, List<Integer>>的trick很好，可以处理为某个attribute生成另一个相关，想记录的attribute的可变长度list。

```java
public class BD1 {
    public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int userNum = sc.nextInt();
    Map<Integer, List<Integer>> map = new HashMap<>();

    for(int i = 1; i < userNum+1; i++){
        int like = sc.nextInt();

        if(!map.containsKey(like)){
            List<Integer> list = new ArrayList<>();
            list.add(i);
            map.put(like, list);
        }else{
            map.get(like).add(i);
        }
    }

    int caseNum = sc.nextInt();

    for(int i = 0; i < caseNum; i++){
        int l = sc.nextInt();
        int r = sc.nextInt();
        int fav = sc.nextInt();

        int count = 0;

        List<Integer> list = map.get(fav);

        if(list != null){
            for(int f : list){
                if(f >= l && f <= r){
                    count++;
                }
            }
        }

        System.out.println(res[i]);
    }
}
```