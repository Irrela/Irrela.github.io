---
title: Road Map
categories: Leetcode
tags:
- Leetcode
---

- [Common Snippet](#common-snippet)
  - [快慢指针找中点](#快慢指针找中点)
  - [Reverse Linked List](#reverse-linked-list)
  - [交错合并两个链表(长度无限制)](#交错合并两个链表长度无限制)
  - [交错合并两个链表(数量最多相差1)](#交错合并两个链表数量最多相差1)
- [Coding Pattern: Two Pointers](#coding-pattern-two-pointers)
- [Coding Pattern: Sliding Window](#coding-pattern-sliding-window)
- [Coding Pattern: Intervals](#coding-pattern-intervals)
- [Coding Pattern: Linked List Manipulation](#coding-pattern-linked-list-manipulation)
- [Coding Pattern: Hash Maps](#coding-pattern-hash-maps)
- [Coding Pattern: Modified Binary Search](#coding-pattern-modified-binary-search)
- [Coding Pattern: Top K Elements](#coding-pattern-top-k-elements)
- [Coding Pattern: Heaps (Priority Queue)](#coding-pattern-heaps-priority-queue)
- [Coding Pattern: Two Heaps](#coding-pattern-two-heaps)
- [Coding Pattern: K-way Merge](#coding-pattern-k-way-merge)
- [Coding Pattern: Subsets](#coding-pattern-subsets)
- [Coding Pattern: Greedy](#coding-pattern-greedy)
- [Coding Pattern: Backtracking](#coding-pattern-backtracking)
- [Coding Pattern: DP](#coding-pattern-dp)
- [Coding Pattern: Cyclic Sort](#coding-pattern-cyclic-sort)
- [Coding Pattern: Topological Sort](#coding-pattern-topological-sort)
- [Coding Pattern: Stacks](#coding-pattern-stacks)
- [Coding Pattern: Breadth-First Search](#coding-pattern-breadth-first-search)
- [Coding Pattern: Depth-First Search](#coding-pattern-depth-first-search)
- [Coding Pattern: Recursion (-TODO)](#coding-pattern-recursion--todo)
- [Coding Pattern: Trie](#coding-pattern-trie)
- [Coding Pattern: Union Find](#coding-pattern-union-find)
- [Coding Pattern: Design](#coding-pattern-design)
- [Bonus: Data Structure + System Design](#bonus-data-structure--system-design)
- [Solution](#solution)
  - [Two Pointers](#two-pointers)
    - [Valid Palindrome](#valid-palindrome)
    - [680. Valid Palindrome II](#680-valid-palindrome-ii)
      - [Naive one based on Valid Palindrome I](#naive-one-based-on-valid-palindrome-i)
    - [Closest Sum](#closest-sum)
    - [3Sum](#3sum)
    - [Best Time to Buy and Sell Stock](#best-time-to-buy-and-sell-stock)
    - [209. Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
    - [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
    - [904. Fruit Into Baskets](#904-fruit-into-baskets)
      - [基于最长连续水果类型的解法](#基于最长连续水果类型的解法)
      - [基于sliding windows的解法（Recommended）](#基于sliding-windows的解法recommended)
    - [567. Permutation in String](#567-permutation-in-string)
    - [1493. Longest Subarray of 1's After Deleting One Element](#1493-longest-subarray-of-1s-after-deleting-one-element)
      - [手动记录zero\_idx](#手动记录zero_idx)
      - [不记录zero\_idx, 让left递增直到zero\_idx](#不记录zero_idx-让left递增直到zero_idx)
    - [Interval](#interval)
      - [986. Interval List Intersections](#986-interval-list-intersections)
      - [57. Insert Interval](#57-insert-interval)
      - [56. Merge Intervals](#56-merge-intervals)
    - [Linked List Manipulation](#linked-list-manipulation)
      - [24. Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
      - [234. Palindrome Linked List](#234-palindrome-linked-list)
      - [92. Reverse Linked List II](#92-reverse-linked-list-ii)
      - [61. Rotate List](#61-rotate-list)
      - [328. Odd Even Linked List](#328-odd-even-linked-list)
      - [143. Reorder List](#143-reorder-list)


# Common Snippet
## 快慢指针找中点
循环结束后, `slow`会指向链表的中间节点（如果链表有奇数个节点，则是正中间的节点；如果是偶数个节点，则是中间偏右的节点）。
```java
    ListNode slow = head;
    ListNode fast = head;
    // 偶数时，slow停在靠右
    while (null != fast && null != fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // 偶数时，slow停在靠左
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
```

## Reverse Linked List
```java
    private ListNode reverseList(ListNode node) { // Side-effect change node's list
        ListNode prev = null;

        while (node != null) {
            ListNode nextNode = node.next;
            node.next = prev;
            prev = node;
            node = nextNode;
        }

        return prev;
    }
```

## 交错合并两个链表(长度无限制)
```java
    public static ListNode mergeAlternately(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            // Link a node from the first list
            current.next = l1;
            l1 = l1.next;
            current = current.next;

            // Link a node from the second list
            current.next = l2;
            l2 = l2.next;
            current = current.next;
        }

        // If one list is longer than the other, link the remaining nodes
        if (l1 != null) {
            current.next = l1;
        }
        if (l2 != null) {
            current.next = l2;
        }

        return dummy.next;
    }
```

## 交错合并两个链表(数量最多相差1)


# Coding Pattern: Two Pointers

- [Valid Palindrome(Easy)](https://leetcode.com/problems/valid-palindrome/)
- [Valid Palindrome II(Medium)](https://leetcode.com/problems/valid-palindrome-ii/)
- [Closest Sum(Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

- [3Sum(Medium)](https://leetcode.com/problems/3sum/)
- [Best Time to Buy and Sell Stock(Medium)(todo-no two pointer type)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

- [Trapping Rain Water(Hard)](https://leetcode.com/problems/trapping-rain-water/)

# Coding Pattern: Sliding Window

- [Longest Substring without Repeats(Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [Minimum Size Subarray Sum(Medium)](https://leetcode.com/problems/minimum-size-subarray-sum/)
- [Fruit into Baskets(Medium)](https://leetcode.com/problems/fruit-into-baskets/description/)
- [Permutation in String(Medium)](https://leetcode.com/problems/permutation-in-string/)
- [Longest Subarray with Ones after Replacement(Medium)](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

- Minimum Window Substring(Hard)

# Coding Pattern: Intervals
- Meeting Rooms I(premium)
- [Meeting Rooms III(Hard)](https://leetcode.com/problems/meeting-rooms-iii/)
- [Interval List Intersections(Hard)](https://leetcode.com/problems/interval-list-intersections/description/)

- [Insert Interval(Medium)](https://leetcode.com/problems/insert-interval/)
- [Merge Intervals(Medium)](https://leetcode.com/problems/merge-intervals/)

# Coding Pattern: Linked List Manipulation
- [Swap Nodes in Pairs(Medium)](https://leetcode.com/problems/swap-nodes-in-pairs/description/)
- [Palindrome Linked List(Medium)](https://leetcode.com/problems/palindrome-linked-list/)

- [Reverse Linked List II(Medium)](https://leetcode.com/problems/reverse-linked-list-ii/)
- [Rotate List(Medium)](https://leetcode.com/problems/rotate-list/)
- [Odd Even Linked List(Medium)](https://leetcode.com/problems/odd-even-linked-list/)

- [Reorder List(M)](https://leetcode.com/problems/reorder-list/)

# Coding Pattern: Hash Maps
- Isomorphic Strings
- Word Pattern

- Group Anagrams
- Find All Anagrams in a String
- Longest Subarray with Sum Divisible by K

- Rate Limiter

# Coding Pattern: Modified Binary Search
- First Bad Version
- Maximum Count of Positives or Negatives 

- Search in Rotated Sorted Array
- Find Minimum in Rotated Sorted Array
- Find Peak Element

- Median of Two Sorted Arrays

# Coding Pattern: Top K Elements
- Kth Largest Element in a Stream
- Kth Largest Element in a Stream

- K Closest Points to Origin
- Top K Frequent Elements in a Stream
- Sliding Window Maximum

- Rearrange String k Distance Apart

# Coding Pattern: Heaps (Priority Queue)

- Meeting Rooms II (Hard)

# Coding Pattern: Two Heaps
- Find Kth Largest Element in a Stream
- Find Median of Two Sorted Arrays

- Kth Smallest Element in a Sorted Matrix
- Find Kth Smallest Pair Distance
- Find K Pairs with Smallest Sums

- Sliding Window Median

# Coding Pattern: K-way Merge 
- Top K Frequent Elements
- Merge Intervals

- Kth Smallest Number in Sorted Matrix
- Merge k Sorted Lists
- Smallest Number Range

- Super Ugly Number

# Coding Pattern: Subsets
- Subsets
- Letter Combinations of a Phone Number

- Subsets II
- Combination Sum
- Palindrome Partitioning

- Combination Sum II

# Coding Pattern: Greedy
- Assign Cookies
- Jump Game

- Queue Reconstruction by Height
- Jump Game II
- Non-overlapping Intervals (Intervals problem)

- Gas Station
- Meeting Rooms II

# Coding Pattern: Backtracking
- Generate Parentheses
- Letter Tile Possibilities

- Combination Sum
- Combination Sum II
- Word Search

- N-Queens

# Coding Pattern: DP
- Climbing Stairs
- Longest Increasing Subsequence

- Unique Paths
- Coin Change
- House Robber

- Edit Distance

# Coding Pattern: Cyclic Sort
- Find the Missing Number
- Set Mismatch

- Find All Numbers Disappeared in an Array
- First Missing Positive
- Find the Duplicate Number

- Find All Duplicates in an Array

# Coding Pattern: Topological Sort
- Course Schedule
- Alien Dictionary

- Course Schedule II
- Sequence Reconstruction
- Minimum Height Trees

- Course Schedule III

# Coding Pattern: Stacks
- Valid Parentheses
- Min Stack

- Evaluate Reverse Polish Notation
- Simplify Path
- Binary Tree Inorder Traversal

- Largest Rectangle in Histogram

# Coding Pattern: Breadth-First Search 
- Binary Tree Level Order Traversal  [Tree]
- Cousins in Binary Tree  [Tree]
- Number of Islands [Graph]
- Find if Path Exists in Graph [Graph]

- Binary Tree Zigzag Level Order Traversal  [Tree]
- Populating Next Right Pointers in Each Node [Tree]
- Word Ladder [Graph]
- Pacific Atlantic Water Flow [Graph]
- Number of Connected Components in an Undirected Graph [Graph]

- Serialize and Deserialize Binary Tree

# Coding Pattern: Depth-First Search 
- Maximum Depth of Binary Tree [Tree]
- Binary Tree Inorder Traversal [Tree]
- Course Schedule [Graph]

- Path Sum II [Tree]
- Symmetric Tree [Tree] 
- Binary Tree Right Side View [Tree]
- Invert Binary Tree [Tree]
- Clone Graph [Graph]

- Lowest Common Ancestor of a Binary Tree [Tree]

# Coding Pattern: Recursion (-TODO)

# Coding Pattern: Trie
- Design Add and Search Words Data Structure
- Word Search II

- Add and Search Words Data Structure
- Palindrome Pairs
- Design Search Autocomplete System

- Word Break II

# Coding Pattern: Union Find
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Coding Pattern: Design
- Friend Circles
- Redundant Connection

- Number of Islands II
- Surrounded Regions
- Graph Valid Tree

- Accounts Merge

# Bonus: Data Structure + System Design
- Design HashSet
- Min Stack

- Design LRU Cache
- Design Twitter
- Design a Parking Lot

- Design an Online Shopping System
- Design a Social Network


# Solution
## Two Pointers

### Valid Palindrome
```java
// Use built-in replaceAll
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase().replaceAll("[^a-zA-Z0-9]", "");

        int forward = 0;
        int backward = s.length() - 1;

        while (backward > forward) {
            if (s.charAt(forward) != s.charAt(backward)) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }
}
```

```java
// Self implemented support fns
class Solution {
    public boolean isPalindrome(String s) {
        char[] charArray = s.toCharArray();
        int forward = 0;
        int backward = charArray.length - 1;

        while (backward > forward) {
            // Skip non-alphanumeric characters from the beginning
            while (forward < charArray.length && !isAlphanumeric(charArray[forward])) {
                forward++;
            }
            
            // Skip non-alphanumeric characters from the end
            while (backward >= 0 && !isAlphanumeric(charArray[backward])) {
                backward--;
            }

            // Compare characters (case-insensitive)
            if (forward < charArray.length && backward >= 0 && toLowerCase(charArray[forward]) != toLowerCase(charArray[backward])) {
                return false;
            }
            forward++;
            backward--;
        }

        return true;
    }

    private boolean isAlphanumeric(char c) {
        return (c >= 'a' && c <= 'z') 
            || (c >= 'A' && c <= 'Z') 
            || (c >= '0' && c <= '9');
    }

    private char toLowerCase(char c) {
        if (c >= 'A' && c <= 'Z') {
            // Convert uppercase to lowercase by adding the ASCII offset
            return (char) (c + 'a' - 'A');
        }
        return c;
    }
}
```

### 680. Valid Palindrome II
#### Naive one based on Valid Palindrome I
```java
class Solution {
    public boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;

        while (left < right) {
            // Allow skip once.
            if (s.charAt(left) != s.charAt(right)) {
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }

        return true;
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

### Closest Sum
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int begin = 0;
        int end = numbers.length - 1;

        while (begin < end) {
            int sum = numbers[begin] + numbers[end];
            if (sum == target) {
                return new int[] {begin + 1, end + 1};
            }

            if (sum > target) {
                end--;
            } else {
                begin++;
            }
        }

        return null;
    }
}
```

```java
// BF
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i=1;i<nums.length;i++)
        {
            for(int j=i;j<nums.length;j++)
            {
                if(nums[j-i]+nums[j]==target)
                {
                    return new int[]{j-i,j};
                }
            }
        }
        return null;
        
    
    }
}
```

```java
// HashMap
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];

            if (map.containsKey(complement)) {
                return new int[] {i, map.get(complement)};
            }

            map.put(nums[i], i);
        }

        return null;
    }
}
```

### 3Sum
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // Note: B-I sort 
        Arrays.sort(nums);
        List<List<Integer>> ret = new ArrayList<>();

        int n = nums.length;

        for (int i = 0; i < n - 2; i++) {
            // Skip duplicates
            if (i > 0 && nums[i] == nums[i - 1]) { continue;}

            int begin = i + 1;
            int end = n - 1;
            // 如果是要求sum为value，这里可以做修改适配
            int target = -nums[i];

            while (begin < end) {
                int sum = nums[begin] + nums[end];
                if (sum == target) {
                    ret.add(Arrays.asList(nums[i], nums[begin], nums[end]));
                    // Skip duplicates
                    while (begin < end && nums[begin] == nums[begin + 1]) {
                        begin++;
                    }
                    while (begin < end && nums[end] == nums[end - 1]) {
                        end--;
                    }

                    begin++;
                    end--;
                } else if (sum < target) {
                    begin++;
                } else {
                    end--;
                }
            }
            
        }

        return ret;
    }
}

```

### Best Time to Buy and Sell Stock
> 用双指针 O(n^2) 太高。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxProfit = 0;
        // 可以代表在i天卖出时可能得最大收益
        int curProfit = 0;

        for (int i = 1; i < prices.length; i++) {
            int interval = prices[i] - prices[i - 1];
            // 如果为负，说明i是一个低价，低到在其之前任何一天买入在i卖出都是亏的
            // 所以it's better to start over at i
            curProfit = Math.max(0, interval + curProfit);
            maxProfit = Math.max(curProfit, maxProfit);
        }

        return maxProfit;
    }
}
```


### 209. Minimum Size Subarray Sum
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int sum = 0;
        int minLength = Integer.MAX_VALUE;

        for (; right < nums.length; right++) {
            sum += nums[right];
            // 只有在sum大于等于过target时才记录minLength
            // 如果全程都没有大于等于过，需要最后将minLength处理为0
            boolean needUpdate = false;

            while (sum >= target) {
                sum -= nums[left];
                left++;
                needUpdate = true;
            }

            if (needUpdate) {
                minLength = Math.min(minLength, right - left + 2);
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```

### 3. Longest Substring Without Repeating Characters
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int len = s.length();
        int maxLength = 0;
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;

        for (int right = 0; right < len; right++) {
            char currentChar = s.charAt(right);
            
            // 如果当前子字符串中没有看到当前字符
            // 或者它出现在当前左指针之前，它是当前子字符串的一部分。
            if (map.getOrDefault(currentChar, -1) < left) {
                maxLength = Math.max(maxLength, right - left + 1);
            } else {
                // 如果该字符已被看到并且在当前子字符串中，
                // 将左指针更新到该字符最后一次出现后的位置。
                left = map.get(currentChar) + 1;
            }
            
            map.put(currentChar, right);
        }

        return maxLength;
    }
}
```


### 904. Fruit Into Baskets
> 内核: 找一个最长的仅有两种元素组成的子串

#### 基于最长连续水果类型的解法
```java
class Solution {
    public int totalFruit(int[] fruits) {
        int maxFruits = 0;           // Initialize the maximum number of fruits to be collected.
        int lastFruit = -1;          // Type of the last fruit in the second basket.
        int secondLastFruit = -1;    // Type of the last fruit in the first basket.
        int lastFruitCount = 0;      // Number of contiguous fruits of the last type.
        int currentMax = 0;          // Current maximum number of fruits.

        for (int fruit : fruits) {
            if (fruit == secondLastFruit || fruit == lastFruit) {
                // If the current fruit is the same as one of the fruits in the baskets, 
                // add it to the currentMax because it can be collected.
                currentMax++;
            } else {
                // If the current fruit is different from the fruits in the baskets,
                // we need to start collecting a new type of fruit. In this case, 
                // we consider the last fruit count plus the current fruit as the new 
                // maximum, and reset the currentMax.
                currentMax = lastFruitCount + 1;
            }

            if (fruit == lastFruit) {
                // If the current fruit is the same as the last fruit, increment the 
                // count of contiguous fruits of this type.
                lastFruitCount++;
            } else {
                // If the current fruit is different from the last fruit, it becomes 
                // the new last fruit, and we reset the last fruit count to 1.
                lastFruitCount = 1;
                secondLastFruit = lastFruit;
                lastFruit = fruit;
            }

            // Update the maximum number of fruits that can be collected.
            maxFruits = Math.max(maxFruits, currentMax);
        }

        return maxFruits;  // Return the maximum number of fruits that can be collected.
    }
}
```

#### 基于sliding windows的解法（Recommended）
```java
class Solution {
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> map = new HashMap<>();  // Create a HashMap to store fruit counts.
        int left = 0;  // Initialize the left pointer for the sliding window.
        int right = 0;  // Initialize the right pointer for the sliding window.
        int len = fruits.length;  // Get the length of the input array.
        int ret = 0;

        for (; right < len; right++) {
            map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1);

            // 从left端逐个移除fruit
            while (map.size() > 2) {
                // map中减少该水果数量
                map.put(fruits[left], map.get(fruits[left]) - 1);
                // 如果减少到0了，剔除该键值对
                // 说明当前篮子可以装入新的水果种类
                if (map.get(fruits[left]) == 0) {
                    map.remove(fruits[left]);
                }

                left++;
            }

            ret = Math.max(ret, right - left + 1);
        }

        return ret;
    }
}
```

### 567. Permutation in String
> 1. 用toCharArray代替charAt，提高速度
> 2. 只构建一次count_s2，然后每次循环用滑动窗口更新改数组


```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int len_s1 = s1.length();
        int len_s2 = s2.length();

        char[] char_s1 = s1.toCharArray();
        char[] char_s2 = s2.toCharArray();
        
        if (len_s1 > len_s2) {
            return false;
        }

        int[] count_s1 = new int[26];
        int[] count_s2 = new int[26];
        
        // Initialize the count_s1 and the first window in s2
        for (int i = 0; i < len_s1; i++) {
            count_s1[char_s1[i] - 'a']++;
            count_s2[char_s2[i] - 'a']++;
        }
        
        // 优化后方案： 只构建一次count_s2，然后每次循环用滑动窗口更新改数组
        for (int i = 0; i < len_s2 - len_s1; i++) {
            if (isSameArr(count_s1, count_s2)) {
                return true;
            }

            // Key!!!
            // 滑动一格后将滑出的char数量--，滑进的char数量++即可
            count_s2[char_s2[i] - 'a']--;
            count_s2[char_s2[i + len_s1] - 'a']++;
        }
        
        // 被优化前的：每次循环都重新构建count_s2数组
        // for (int i = 0; i <= len_s2 - len_s1; i++) {
        //     int[] count_s2 = new int[26];
        //     for (int j = 0; j < len_s1; j++) {
        //         count_s2[char_s2[i+j] - 'a']++;
        //     }

        //     if (isSameArr(count_s1, count_s2)) {
        //         return true;
        //     }
        // }

        // Check the last window
        return isSameArr(count_s1, count_s2);
    }

    private boolean isSameArr(int[] arrA, int[] arrB) {
        for (int i = 0; i < arrA.length; i++) {
            if (arrA[i] != arrB[i]) {
                return false;
            }
        }

        return true;
    }
}
```

### 1493. Longest Subarray of 1's After Deleting One Element
#### 手动记录zero_idx
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        int left = 0;
        int right = 0;
        int zero_idx = 0;
        int zero_count = 0;
        int ret = 0;

        for (; right < len; right++) {
            if (nums[right] == 0) {
                if (zero_count > 0) {
                    left = zero_idx + 1;
                    zero_idx = right;
                } else {
                    zero_idx = right;
                    zero_count++;
                }
            }

            ret = Math.max(ret, right - left);
        }

        return ret;
    }
}
```
#### 不记录zero_idx, 让left递增直到zero_idx
```java
class Solution {
    public int longestSubarray(int[] nums) {
        int len = nums.length;
        int left = 0;
        int right = 0;
        int zero_count = 0;
        int ret = 0;

        for (; right < len; right++) {
            if (nums[right] == 0) {
                zero_count++;

                while (zero_count > 1) {
                    if (nums[left] == 0) {
                        zero_count--;
                    }
                    left++;
                }
            }

            ret = Math.max(ret, right - left);
        }

        return ret;

    }
}
```

### Interval

#### 986. Interval List Intersections

- `List<int[]>` 存储结果，`.toArray(new int[result.size()][])` 返回结果处理
- 双指针指向第一维，用于选取interval
- 循环条件是任一指针遍历到最后一个interval
- 通过两组start，end来截取intersection的start，end
- 判断是否加入结果
- 根据end大小判断哪个指针跳入下个interval

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        // Create a list to store the result intervals
        List<int[]> result = new ArrayList<>();
        
        // Initialize two pointers, one for each input list
        int i = 0, j = 0;

        // Iterate through both lists
        while (i < firstList.length && j < secondList.length) {
            // Get the start and end points of the current intervals in both lists
            int start1 = firstList[i][0];
            int end1 = firstList[i][1];
            int start2 = secondList[j][0];
            int end2 = secondList[j][1];

            // Find the intersection of the two intervals
            int intersectionStart = Math.max(start1, start2);
            int intersectionEnd = Math.min(end1, end2);

            // If there is an intersection (i.e., valid interval), add it to the result
            if (intersectionStart <= intersectionEnd) {
                result.add(new int[]{intersectionStart, intersectionEnd});
            }

            // Move the pointer that points to the interval with the smaller endpoint
            if (end1 < end2) {
                i++; // Move the pointer for the first list
            } else {
                j++; // Move the pointer for the second list
            }
        }

        // Convert the result list to a 2D array and return it as the final result
        return result.toArray(new int[result.size()][]);
    }
}

```

#### 57. Insert Interval

- left, right的初始取值应该直接用newInterval，可以适配一些特殊场景如：intervals = [], newInterval = [5,7]
- hasInserted标记， 用于在`第一次right < start` 或 `newInterval[1] >= intervals的最右端`时添加overlap interval
- 存在overlap的场景处理

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {        
        
        List<int[]> ret = new ArrayList<>();

        // 注意初始化取值，对特殊intervals也能适配
        int left = newInterval[0];
        int right = newInterval[1];

        boolean hasInserted = false;

        for (int i = 0; i < intervals.length; i++) {
            int start = intervals[i][0];
            int end = intervals[i][1]; 

            if (left > end) {
                // 当前interval 完全在 newInterval 左边
                ret.add(intervals[i]);
            } else if (right < start) {
                // 当前interval 完全在 newInterval 右边
                if (!hasInserted) {
                    // 如果有这种interval，先添加overlap的interval
                    // 用标记防止对每个这种interval都插入overlap的interval
                    // 即是在仅遇到第一个时添加
                    ret.add(new int[] {left, right});
                    hasInserted = true;
                }
                ret.add(intervals[i]);
            } else {
                // 存在overlap的场景
                left = Math.min(left, start);
                right = Math.max(right, end);
            }

        }

        if (!hasInserted) {
            ret.add(new int[] {left, right});
        }

        return ret.toArray(new int[ret.size()][]);
    }
}
```

#### 56. Merge Intervals

- 根据start排序整个二维数组
- 用currentInterval来跨越多个overlap interval，初始值为intervals[0]
- 循环从i=1开始

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals; // No merging needed for 0 or 1 interval.
        }

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0])); // Sort by start times.

        List<int[]> ret = new ArrayList<>();
        int[] currentInterval = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            int currentEnd = currentInterval[1];
            int nextStart = intervals[i][0];
            int nextEnd = intervals[i][1];

            if (currentEnd >= nextStart) {
                // Intervals overlap or are adjacent, so we merge them.
                currentInterval[1] = Math.max(currentEnd, nextEnd);
            } else {
                // Intervals don't overlap, so we add the current interval to the result and update it to the next interval.
                ret.add(currentInterval);
                currentInterval = intervals[i];
            }
        }

        // Add the last ret interval.
        ret.add(currentInterval);

        return ret.toArray(new int[ret.size()][]);
    }
}


```


### Linked List Manipulation
#### 24. Swap Nodes in Pairs

- 用prev, left, right, after来做swap
- Extreme case: one-element and empty list
- Boundary: after is null circumstances.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {

        if (null == head || null == head.next) {
            return head;
        }
        
        ListNode left = head;
        ListNode right = left.next;

        ListNode new_head = right;

        ListNode prev = head;
        ListNode after = head;

        while (null != left && null != right) {
            // Update after
            after = right.next;

            // Swap ref
            prev.next = right;
            right.next = left;
            left.next = after;

            // Update prev and left
            prev = left;
            left = after;

            // In case that `after` is null casuing after.next NPE
            if (null != after) {
                right = after.next;
            } else {
                right = null;
            }
            
        }

        return new_head;
    }
}
```

#### 234. Palindrome Linked List

1. 遍历两次，辅助int[]
- 用array记录前半的val

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        // Count the number of nodes in the linked list
        int count = 0;
        ListNode node = head;
        while (node != null) {
            count++;
            node = node.next;
        }
        
        // Create an array to store the first half of the values
        int[] arr = new int[count / 2];
        
        // Reset the node to the head of the linked list
        node = head;
        
        // Store the values of the first half in the array
        for (int i = 0; i < arr.length; i++) {
            arr[i] = node.val;
            node = node.next;
        }
        
        // If the total count is odd, move to the next node
        if (count % 2 != 0) {
            node = node.next;
        }
        
        // Compare the values in the array with the second half of the linked list
        for (int i = arr.length - 1; i >= 0; i--) {
            if (node.val != arr[i]) {
                return false;
            }
            node = node.next;
        }
        
        return true;
    }
}

```

2. 遍历一次快慢指针，stack辅助

- 快慢指针
- 快慢指针处理奇数list中间点的方式

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> stack = new Stack<>();
        ListNode node = head;

        ListNode slow = head;
        ListNode fast = head;

        // Find the middle of the linked list
        while (fast != null && fast.next != null) {
            stack.push(slow.val);
            slow = slow.next;
            fast = fast.next.next;
        }

        
        if (null != fast) { // List有奇数个node, slow跳过中间点
            slow = slow.next;
        }

        while (null != slow) {
            if (slow.val != stack.pop()) {
                return false;
            }
            slow = slow.next;
        }

        return true;
    }
}
```

1. 遍历一次快慢指针, 后半reverse

- `reverseList` 方法可复用

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true; // An empty list or a list with one node is considered a palindrome.
        }

        ListNode slow = head;
        ListNode fast = head;

        // Find the middle of the linked list
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Reverse the second half of the linked list
        ListNode secondHalf = reverseList(slow);

        // Compare the first half and the reversed second half
        ListNode firstHalf = head;
        while (secondHalf != null) {
            if (firstHalf.val != secondHalf.val) {
                return false;
            }
            firstHalf = firstHalf.next;
            secondHalf = secondHalf.next;
        }

        return true;
    }

    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;

        while (current != null) {
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }

        return prev;
    }
}

```

#### 92. Reverse Linked List II

- index从1开始算，left和right都是指index

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || left == right) {
            return head;
        }

        ListNode dummy = new ListNode(-1); // Create a dummy node to simplify the code.
        dummy.next = head;
        ListNode prev = dummy;

        // Move to the node just before the left position.
        for (int i = 1; i < left; i++) {
            prev = prev.next;
        }

        // Initialize pointers for reversing the sublist.
        ListNode current = prev.next;
        ListNode next = null;

        // Reverse the sublist from left to right.
        for (int i = left; i < right; i++) {
            next = current.next;
            current.next = next.next;
            next.next = prev.next;
            prev.next = next;
        }

        return dummy.next;
    }
}
```

#### 61. Rotate List

- 将链表的尾部与头部相连，形成一个环形链表。
- 计算实际旋转的位置。由于旋转是向右的，所以实际旋转的位置是 len - k % len，其中 len 是链表的长度。这是因为如果k大于链表的长度，旋转k次等于旋转k % len次。
- 找到新的链表头部和尾部。遍历链表，找到原链表的新尾部，它是位于第 len - k % len - 1 个位置的节点，然后新的头部是新尾部的下一个节点。
- 断开环形链表，使其变成一个常规链表。将新尾部的next指针设置为None，同时将原链表的头部指针设置为新头部。
- > Note: 将count初始值设为1，遍历停止条件为 null != node.next 的方式来获取长度并保证 node不为null

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (null == head || k == 0) {
            return head;
        }

        // 计算链表长度
        int len = 1;
        ListNode node = head;
        while (null != node.next) {
            len++;
            node = node.next;
        }
        
        // 将链表的尾部与头部相连，形成一个环形链表
        node.next = head;

        // 计算实际旋转位置
        k %= len;

        // 找到新的链表头尾
        ListNode new_tail = head;
        for (int i = 0; i < len - k - 1; i++) {
            new_tail = new_tail.next;
        }
        ListNode new_head = new_tail.next;

        // 断开环形链表
        new_tail.next = null;

        return new_head;

    }
}
```

#### 328. Odd Even Linked List
- 需要一个`evenHead`索引到even list的头结点
- 用两个指针odd和even，odd的next先指向even的next，然后odd指针指向自己的next即已经链接上的下一个odd节点。
- 对even做同样处理
- 跳出边界后，将odd.next指向evenHead

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (null == head || null == head.next || null == head.next.next) {
            return head;
        }

        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;

        while (null != even && null != even.next) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }

        odd.next = evenHead;

        return head;

    }
}
```

#### 143. Reorder List
- 快慢指针确定中点middle（选用偶数靠左版本，因为是链表取左操作空间多余右）
- 新建指针second指向middle.next, 然后断开middle与middle.next。second即后半部分。
- 翻转second后半部分-> reversed
- 交错合并head和reversed

> 暂存middle.next节点后断开middle和其next非常重要，否则head开头链表还会带有middle以后得节点（在reverse操作后虽然也会断开，但会使边界判断非常麻烦，先断开再做翻转操作和合并，减少心智负担）

```java
class Solution {
    public void reorderList(ListNode head) {
        

        ListNode fast = head;
        ListNode slow = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        ListNode middleRight = slow.next;
        slow.next = null;

        ListNode secondReversedHalf = reverseList(middleRight);


        head = mergeAlternately(head, secondReversedHalf);

    }

    private ListNode reverseList(ListNode node) {
        ListNode prev = null;

        while (null != node) {
            ListNode next = node.next;
            node.next = prev;
            prev = node;
            node = next;
        }

        return prev;
    }

    private ListNode mergeAlternately(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            // Link a node from the first list
            current.next = l1;
            l1 = l1.next;
            current = current.next;

            // Link a node from the second list
            current.next = l2;
            l2 = l2.next;
            current = current.next;
        }

        // If one list is longer than the other, link the remaining nodes
        if (l1 != null) {
            current.next = l1;
        }
        if (l2 != null) {
            current.next = l2;
        }

        return dummy.next;
    }
}
```