---
title: Swift
categories: Apple Dev
tags:
  - Apple Dev
---

# Syntax

### Data Type

### Operator

#### if let


### Function

#### argument label

#### inout
```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var a = 3
var b = 107

swap(&a, &b)
```

#### Function type
在Swift中，函数类型（Function Types）是一种描述函数的类型。

函数类型可以像其他类型一样被用作变量、常量、和参数的类型，也可以作为函数的返回类型。

Swift 中的函数类型由参数类型和返回类型组成。让我们来看一下函数类型的基本结构。

```swift
// 定义一个函数类型，接受两个整数参数，返回一个整数
var additionFunction: (Int, Int) -> Int

// 定义一个函数，符合上述函数类型的声明
func addTwoNumbers(_ a: Int, _ b: Int) -> Int {
    return a + b
}

// 将函数赋值给函数类型的变量
additionFunction = addTwoNumbers

// 调用函数类型的变量，执行相应的函数
let result = additionFunction(3, 4)
print(result) // 输出 7

```

### Closure

在Swift中，闭包（Closure）是一种自包含的功能块，它可以在代码中被传递和使用。

**闭包类似于其他编程语言中的匿名函数或 Lambda 表达式**。Swift中的闭包有简洁的语法，可以捕获和存储其所在上下文中任意常量和变量的引用。

闭包可以用来作为函数的参数，也可以作为函数的返回值。

它们在Swift中广泛用于实现轻量级的、灵活的功能，比如在函数式编程范式中。

#### Capture Values
闭包可以捕获并存储在其上下文中定义的常量和变量的引用，即使这些常量和变量在闭包被执行时已经不存在。这就是所谓的“捕获值”（Capturing Values）。例如：

```swift
// 返回一个闭包：() -> Int
func makeIncrementer(incrementAmount: Int) -> () -> Int {
    var total = 0

    let incrementer: () -> Int = {
        total += incrementAmount
        return total
    }

    return incrementer
}

let incrementByTwo = makeIncrementer(incrementAmount: 2)
print(incrementByTwo())  // 输出 2
print(incrementByTwo())  // 输出 4
```
在这个例子中，makeIncrementer 函数返回一个闭包，该闭包会捕获 total 和 incrementAmount 的引用。

每次调用 incrementByTwo 闭包时，total 会增加 incrementAmount 的值。


#### Hashable, 

#### Codable

#### Identifiable 


#### NavigationLink

NavigationLink 是 SwiftUI 中用于创建导航的视图组件之一。它允许用户点击一个视图，然后导航到另一个视图。通常，NavigationLink 会在你的界面中创建一个可点击的链接，当用户点击它时，会自动推送（push）到与链接相关联的目标视图。

以下是一个简单的例子，演示了如何在 SwiftUI 中使用 NavigationLink：

```swift
ForEach(items) { landmark in
    NavigationLink {
        LandmarkDetail(landmark: landmark) // 前往的目标
    } label: {
        CategoryItem(landmark: landmark) // 选取
    }
}
```

#### @State
```swift
// Use the @State property wrapper to mark a value as state, declare the property as private, and give it a default value.
@State private var showFavoritesOnly = false
```
在SwiftUI中，@State是一个属性包装器，用于在SwiftUI视图中声明一段可变状态。它被设计用于处理值类型，如结构和枚举，并且提供了一种在视图中存储和管理状态的方法。

当你用@State声明一个属性时，SwiftUI会在状态改变时更新视图。这对于SwiftUI根据底层数据的变化有效地管理和更新UI至关重要。

#### @Observable

#### @Binding
@Binding 属性是一种将数据从一个视图传递到其子视图的方法，允许子视图修改该值并将更改传递回父视图。

A binding controls the storage for a value, so you can pass data around to different views that need to read or write it.

#### @Bindable
```swift
@Bindable var modelData = modelData
```
@Bindable 是一个属性包装器（property wrapper），它用于声明可绑定的属性。
目的是允许你在属性发生变化时触发某些操作，例如更新界面。

在这个特定的例子中，使用 @Bindable 的目的可能是为了监听 modelData 的变化，并在变化发生时更新界面。


#### @Environment & .environment()
```swift
    @Environment(ModelData.self) var modelData
    // ...

    #Preview {
    LandmarkList()
        .environment(ModelData())
    }

```
环境变量（Environment）是一种在整个应用程序中共享数据的方式。
@Environment 用于获取全局环境中的特定类型的数据。
在这个例子中，modelData 可以用来访问应用程序中的全局数据，可能是应用程序的模型数据。

在 SwiftUI 中，.environment() 用于将数据或环境对象传递给视图层次结构的下级视图。在你提供的代码中，.environment(ModelData()) 是为 LandmarkDetail 这个视图设置了环境变量，使其能够访问 ModelData 这个数据对象。

在这个例子中，LandmarkDetail 的视图层次结构中使用了 @Environment(ModelData.self) var modelData 来获取环境中的 ModelData 对象。
通过 .environment(ModelData())，你将一个新的 ModelData 实例传递给了 LandmarkDetail，使得该视图在显示时可以使用这个数据对象中的信息。



#### $0
```swift
var landmarkIndex: Int {
    modelData.landmarks.firstIndex(
        where: {
            $0.id == landmark.id
        }
    )! // 强制解包
}
```
在 Swift 中，$0 是一个简写形式，表示闭包中的第一个参数。


#### GeometryReader
使用GeometryReader动态绘制、定位和调整视图大小，而不是硬编码数字：当您在应用程序中的其他位置或不同大小的显示器上重复使用视图时，这些数字可能不正确。

GeometryReader动态报告有关父视图和设备的大小和位置信息，并在大小改变时更新；例如，当用户旋转他们的iPhone时。


#### extension

extension（扩展）是Swift语言中一种强大的特性，它允许你在不修改原始代码的情况下向现有的类、结构体、枚举或协议添加新功能。